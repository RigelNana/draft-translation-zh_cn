%!TEX root = std.tex
\rSec0[basic]{基础}

\gramSec[gram.basic]{基础}

\rSec1[basic.pre]{序言}

\pnum
\begin{note}
本条款介绍了 \Cpp{} 语言的基本概念。
它解释了对象和
名称之间的区别，以及它们与表达式的值类别的关系。
它介绍了
声明和定义的
概念，并介绍了 \Cpp{} 的类型、作用域、链接和
存储期的概念。讨论了启动和
终止程序的机制。最后，本条款介绍了
语言的基本类型，并列出了从这些类型构造
复合类型的方法。
\end{note}

\pnum
\begin{note}
本条款不涵盖仅影响语言单个
部分的那些概念。这些概念将在相关的
条款中讨论。
\end{note}

\pnum
\indextext{type}%
\indextext{object}%
\indextext{storage class}%
\indextext{scope}%
\indextext{linkage}%
\defn{实体} 是值、对象、引用、
结构化绑定、
函数、枚举器、类型、
类成员、位域、模板、模板特化、命名空间或
形参包。

\pnum
\defn{名称} 是 \grammarterm{identifier}\iref{lex.name}、
\grammarterm{operator-function-id}\iref{over.oper}、
\grammarterm{literal-operator-id}\iref{over.literal} 或
\grammarterm{conversion-function-id}\iref{class.conv.fct}。

\pnum
每个名称都由 \defn{声明} 引入，声明是
\begin{itemize}
\item
\grammarterm{name-declaration}、
\grammarterm{block-declaration} 或
\grammarterm{member-declaration}\iref{dcl.pre,class.mem}，
\item
\grammarterm{init-declarator}\iref{dcl.decl}，
\item
结构化绑定声明中的 \grammarterm{identifier}\iref{dcl.struct.bind}，
\item
\grammarterm{init-capture}\iref{expr.prim.lambda.capture}，
\item
带有 \grammarterm{declarator} 的 \grammarterm{condition}\iref{stmt.pre}，
\item
\grammarterm{member-declarator}\iref{class.mem}，
\item
\grammarterm{using-declarator}\iref{namespace.udecl}，
\item
\grammarterm{parameter-declaration}\iref{dcl.fct}，
\item
\grammarterm{type-parameter}\iref{temp.param}，
\item
引入名称的 \grammarterm{elaborated-type-specifier}
\iref{dcl.type.elab}，
\item
\grammarterm{class-specifier}\iref{class.pre}，
\item
\grammarterm{enum-specifier} 或
\grammarterm{enumerator-definition}\iref{dcl.enum}，
\item
\grammarterm{exception-declaration}\iref{except.pre}，或
\item
注入类名的隐式声明\iref{class.pre}。
\end{itemize}
\begin{note}
\grammarterm{for-range-declaration} 的解释产生
上述一项或多项\iref{stmt.ranged}。
\end{note}
实体 $E$ 由引入 $E$ 的声明
或由指定 $E$ 的声明引入的 \grammarterm{typedef-name}
引入的名称（如果有）表示。

\pnum
\defn{变量} 由
除静态数据成员之外的引用
或对象的声明引入。变量的名称（如果有）表示引用或对象。

\pnum
\defnadj{局部}{实体} 是具有
自动存储期\iref{basic.stc.auto} 的变量、
其对应变量为此类实体的结构化绑定\iref{dcl.struct.bind}
或 \tcode{*\keyword{this}} 对象\iref{expr.prim.this}。

\pnum
\begin{note}
一些名称表示类型或模板。
一般来说，每当遇到一个名称时，
都需要查找它\iref{basic.lookup}
以确定该名称是否表示这些实体之一，
然后再继续解析包含它的程序。
\end{note}

\pnum
如果满足以下条件，则两个名称是 \defnx{相同}{name!same} 的：
\begin{itemize}
\item 它们是由相同字符序列组成的 \grammarterm{identifier}，或
\item 它们是用相同运算符形成的 \grammarterm{operator-function-id}，或
\item 它们是用等效\iref{temp.over.link} 类型形成的 \grammarterm{conversion-function-id}，或
\item 它们是用相同的字面量后缀标识符形成的 \grammarterm{literal-operator-id}\iref{over.literal}。
\end{itemize}

\pnum
\indextext{translation unit!name and}%
\indextext{linkage}%
在多个翻译单元中使用的名称可能
指这些翻译单元中的相同实体，具体取决于
每个翻译单元中指定的名称的链接\iref{basic.link}。

\rSec1[basic.def]{声明与定义}

\pnum
\indextext{declaration!definition versus}%
\indextext{declaration}%
\indextext{declaration!name}%
声明\iref{dcl.dcl} 可以（重新）将
一个或多个名称和/或实体引入翻译
单元。
如果是这样，则
声明指定这些名称的解释和语义属性。
如果实体或 \grammarterm{typedef-name} $X$ 的另一个声明
可以从它到达\iref{module.reach}，则它是 $X$ 的重复声明。
声明也可能有以下影响：
\begin{itemize}
\item 静态断言\iref{dcl.pre}，
\item 控制模板实例化\iref{temp.explicit}，
\item 指导构造函数的模板实参推导\iref{temp.deduct.guide}，
\item 使用属性\iref{dcl.attr}，以及
\item 什么也不做（在 \grammarterm{empty-declaration} 的情况下）。
\end{itemize}

\pnum
\indextext{declaration!function}%
\indextext{definition}%
由 \grammarterm{declaration} 声明的每个实体
也由该声明 \defnx{定义}{define}，除非：
\begin{itemize}
\item
它声明一个函数
而不指定函数体\iref{dcl.fct.def}，
\item
它包含
\indextext{declaration!\idxcode{extern}}%
\keyword{extern} 说明符\iref{dcl.stc} 或
\grammarterm{linkage-specification}
\begin{footnote}
出现在 \grammarterm{linkage-specification} 中大括号括起来的
\grammarterm{declaration-seq} 内部
不会影响声明是否为定义。
\end{footnote}
\iref{dcl.link}
并且既没有 \grammarterm{initializer} 也没有
\grammarterm{function-body}，
\item
\indextext{declaration!static member@\tcode{static} member}%
它在类定义中声明一个非内联静态数据成员\iref{class.mem,class.static}，
\item
它在类定义之外声明一个静态数据成员
并且该变量在类中使用 \keyword{constexpr}
说明符定义（此用法已弃用；参见 \ref{depr.static.constexpr}），
\item
\indextext{declaration!class name}%
它是一个 \grammarterm{elaborated-type-specifier}\iref{class.name}，
\item
它是
\indextext{declaration!opaque enum}%
\grammarterm{opaque-enum-declaration}\iref{dcl.enum}，
\item
它是一个
\indextext{parameter!template}\indextext{template parameter}%
\grammarterm{template-parameter}\iref{temp.param}，
\item
它是在不是
\grammarterm{function-definition} 的 \grammarterm{declarator} 的函数
\indextext{declaration!parameter}\indextext{parameter declaration}%
\grammarterm{parameter-declaration}\iref{dcl.fct}
\indextext{declarator}%
中，
\item
它是
\indextext{declaration!\idxcode{typedef}}%
\keyword{typedef} 声明\iref{dcl.typedef}，
\item 它是
\grammarterm{alias-declaration}\iref{dcl.typedef}，
\item 它是
\grammarterm{using-declaration}\iref{namespace.udecl}，
\item 它是
\grammarterm{deduction-guide}\iref{temp.deduct.guide}，
\item 它是
\grammarterm{static_assert-declaration}\iref{dcl.pre}，
\item
它是
\grammarterm{attribute-declaration}\iref{dcl.pre}，
\item
它是
\grammarterm{empty-declaration}\iref{dcl.pre}，
\item 它是
\grammarterm{using-directive}\iref{namespace.udir}，
\item 它是
\grammarterm{using-enum-declaration}\iref{enum.udecl}，
\item 它是
\grammarterm{template-declaration}\iref{temp.pre}
其 \grammarterm{template-head} 后面没有
\grammarterm{concept-definition} 或定义
函数、类、变量或静态数据成员的 \grammarterm{declaration}，
\item 它是
显式实例化声明\iref{temp.explicit}，或
\item 它是
显式特化\iref{temp.expl.spec}，其
\grammarterm{declaration} 不是定义。
\end{itemize}
声明被称为它定义的每个实体的 \defn{定义}。
\begin{example}
以下各项中除一项外均为定义：
\begin{codeblock}
int a;                          // defines \tcode{a}
extern const int c = 1;         // defines \tcode{c}
int f(int x) { return x+a; }    // defines \tcode{f} and defines \tcode{x}
struct S { int a; int b; };     // defines \tcode{S}, \tcode{S::a}, and \tcode{S::b}
struct X {                      // defines \tcode{X}
  int x;                        // defines non-static data member \tcode{x}
  static int y;                 // declares static data member \tcode{y}
  X(): x(0) { }                 // defines a constructor of \tcode{X}
};
int X::y = 1;                   // defines \tcode{X::y}
enum { up, down };              // defines \tcode{up} and \tcode{down}
namespace N { int d; }          // defines \tcode{N} and \tcode{N::d}
namespace N1 = N;               // defines \tcode{N1}
X anX;                          // defines \tcode{anX}

\end{codeblock}
而这些只是声明：
\begin{codeblock}
extern int a;                   // declares \tcode{a}
extern const int c;             // declares \tcode{c}
int f(int);                     // declares \tcode{f}
struct S;                       // declares \tcode{S}
typedef int Int;                // declares \tcode{Int}
extern X anotherX;              // declares \tcode{anotherX}
using N::d;                     // declares \tcode{d}
\end{codeblock}
\end{example}

\pnum
\begin{note}
\indextext{implementation-generated}%
在某些情况下，\Cpp{} 实现会隐式定义
默认构造函数\iref{class.default.ctor}、
复制构造函数、移动构造函数\iref{class.copy.ctor}、
复制赋值运算符、移动赋值运算符\iref{class.copy.assign}
或析构函数\iref{class.dtor} 成员函数。
\end{note}
\begin{example}
给定
\begin{codeblock}
#include <string>

struct C {
  std::string s;                // \tcode{std::string} is the standard library class\iref{string.classes}
};

int main() {
  C a;
  C b = a;
  b = a;
}
\end{codeblock}
实现将隐式定义函数以使 \tcode{C} 的定义等效于
\begin{codeblock}
struct C {
  std::string s;
  C() : s() { }
  C(const C& x): s(x.s) { }
  C(C&& x): s(static_cast<std::string&&>(x.s)) { }
      @\rlap{\textnormal{\textit{//}}}@    : s(std::move(x.s)) { }
  C& operator=(const C& x) { s = x.s; return *this; }
  C& operator=(C&& x) { s = static_cast<std::string&&>(x.s); return *this; }
      @\rlap{\textnormal{\textit{//}}}@                { s = std::move(x.s); return *this; }
  ~C() { }
};
\end{codeblock}
\end{example}

\pnum
\begin{note}
类名也可以由
\grammarterm{elaborated-type-specifier}\iref{dcl.type.elab} 隐式声明。
\end{note}

\pnum
\indextext{type!incomplete}%
在对象的定义中，
该对象的类型不应是
不完整类型\iref{term.incomplete.type}、
抽象类类型\iref{class.abstract} 或
其（可能是多维的）数组。

\rSec1[basic.def.odr]{单一定义规则}%
\indextext{object!definition}%
\indextext{function!definition}%
\indextext{class!definition}%
\indextext{enumerator!definition}%
\indextext{one-definition rule|(}%

\pnum
以下各项中的每一项都被称为 \defnadj{可定义}{项}：
\begin{itemize}
\item 类类型\iref{class}，
\item 枚举类型\iref{dcl.enum}，
\item 函数\iref{dcl.fct}，
\item 变量\iref{basic.pre}，
\item 模板实体\iref{temp.pre}，
\item 参数的默认实参
（对于给定作用域中的函数）\iref{dcl.fct.default}，或
\item 默认模板实参\iref{temp.param}。
\end{itemize}

\pnum
任何翻译单元都不得包含任何
可定义项的多个定义。

\pnum
\indextext{expression!potentially evaluated}%
表达式或转换是 \defn{潜在求值} 的，除非它是
未求值操作数\iref{expr.context}、
其子表达式或
此类上下文中的初始化或转换序列中的转换。
表达式 $E$ 的 \defn{潜在结果} 集
定义如下：
\begin{itemize}
\item 如果 $E$ 是
\grammarterm{id-expression}\iref{expr.prim.id}，则该集合
仅包含 $E$。
\item 如果 $E$ 是带有
数组操作数的下标操作\iref{expr.sub}，则该集合包含该操作数的潜在结果。
\item 如果 $E$ 是命名非静态数据成员的
$E_1$ \tcode{.} \opt{\keyword{template}} $E_2$ 形式的类成员访问
表达式\iref{expr.ref}，
则该集合包含 $E_1$ 的潜在结果。
\item 如果 $E$ 是命名静态数据成员的类成员访问表达式，
则该集合包含指定数据成员的 \grammarterm{id-expression}。
\item 如果 $E$ 是 $E_1$ \tcode{.*} $E_2$ 形式的成员指针
表达式\iref{expr.mptr.oper}，
则该集合包含 $E_1$ 的潜在结果。
\item 如果 $E$ 具有 \tcode{($E_1$)} 的形式，则该集合包含
$E_1$ 的潜在结果。
\item 如果 $E$ 是泛左值条件
表达式\iref{expr.cond}，则该集合是
第二个和第三个操作数的潜在结果集的并集。
\item 如果 $E$ 是逗号表达式\iref{expr.comma}，则该集合
包含右操作数的潜在结果。
\item 否则，该集合为空。
\end{itemize}
\begin{note}
此集合是（可能为空的）\grammarterm{id-expression} 集合，
其中每个都是 $E$ 或 $E$ 的子表达式。
\begin{example}
在以下示例中，\tcode{n} 的初始化器的潜在结果集
包含第一个 \tcode{S::x} 子表达式，但不包含第二个
\tcode{S::x} 子表达式。
\begin{codeblock}
struct S { static const int x = 0; };
const int &f(const int &r);
int n = b ? (1, S::x)           // \tcode{S::x} is not odr-used here
          : f(S::x);            // \tcode{S::x} is odr-used here, so a definition is required
\end{codeblock}
\end{example}
\end{note}

\pnum
函数由表达式或转换 \defnx{命名}{function!named by expression or conversion} 如下：
\begin{itemize}
\item
  如果函数是作为构成该表达式或转换的一部分执行的重载解析中
  重载集\iref{basic.lookup,over.match,over.over} 的选定成员，
  则函数由表达式或转换命名，
  除非它是纯虚函数并且表达式
  不是命名具有显式限定名的函数的 \grammarterm{id-expression}，或
  表达式构成成员指针\iref{expr.unary.op}。
  \begin{note}
这涵盖了
  获取函数的地址\iref{conv.func,expr.unary.op}，
  对命名函数的调用\iref{expr.call}，
  运算符重载\iref{over}，
  用户定义的转换\iref{class.conv.fct}，
  \grammarterm{new-expression} 的分配函数\iref{expr.new}，以及
  非默认初始化\iref{dcl.init}。
  选择复制或移动类类型对象的构造函数
  被认为由表达式或转换命名，
  即使该调用实际上被实现省略\iref{class.copy.elision}。
\end{note}
\item
  如果类
  的释放函数是如 \ref{expr.new} 中所指定的，
  由重载解析选择的分配函数的单个匹配释放函数，则它由 \grammarterm{new-expression} 命名。
\item
  如果类的释放函数
  是如 \ref{expr.delete} 和 \ref{class.free} 中所指定的选定常用释放函数，则它由 \grammarterm{delete-expression} 命名。
\end{itemize}

\pnum
\label{term.odr.use}%
如果表达式是表示它的 \grammarterm{id-expression}，则变量由表达式命名。
如果一个变量 \tcode{x} 被出现在点 $P$ 的
潜在求值表达式 $N$ 命名，则 \tcode{x}
被 $N$ \defnx{odr 使用}{odr-use}，除非
\begin{itemize}
\item
\tcode{x} 是
在 $P$ 处可用于常量表达式\iref{expr.const} 的引用，或
\item
$N$ 是表达式 $E$ 的潜在结果集的一个元素，其中
\begin{itemize}
\item
$E$ 是未应用左值到右值转换的舍弃值表达式\iref{expr.context}，或
\item
\tcode{x} 是在 $P$ 处可用于常量表达式且没有可变子对象的非 volatile 对象，并且
\begin{itemize}
\item
$E$ 是命名引用类型的非静态数据成员的类成员访问表达式\iref{expr.ref}，
并且其对象表达式具有非 volatile 限定类型，或
\item
左值到右值转换\iref{conv.lval} 应用于 $E$ 并且
$E$ 具有非 volatile 限定的非类类型
\end{itemize}
\end{itemize}
\end{itemize}
\begin{example}
\begin{codeblock}
int f(int);
int g(int&);
struct A {
  int x;
};
struct B {
  int& r;
};
int h(bool cond) {
  constexpr A a = {1};
  constexpr const volatile A& r = a;    // odr-uses \tcode{a}
  int _ = f(cond ? a.x : r.x);          // does not odr-use \tcode{a} or \tcode{r}
  int x, y;
  constexpr B b1 = {x}, b2 = {y};       // odr-uses \tcode{x} and \tcode{y}
  int _ = g(cond ? b1.r : b2.r);        // does not odr-use \tcode{b1} or \tcode{b2}
  int _ = ((cond ? x : y), 0);          // does not odr-use \tcode{x} or \tcode{y}
  return [] {
    return b1.r;                        // error: \tcode{b1} is odr-used here because the object
                                        // referred to by \tcode{b1.r} is not constexpr-referenceable here
  }();
}
\end{codeblock}
\end{example}

\pnum
结构化绑定如果作为潜在求值表达式出现，则它是 odr 使用的。

\pnum
如果 \keyword{this} 作为潜在求值表达式出现（包括作为任何隐式转换为
类成员访问表达式\iref{expr.prim.id.general} 的结果），
则 \tcode{*\keyword{this}} 是 odr 使用的。

\pnum
如果虚成员
函数不是纯虚函数，则它是 odr 使用的。
如果函数由潜在求值表达式或转换命名，则该函数是 odr 使用的。
类的非布局分配或释放
函数由该类的构造函数的定义 odr 使用。类的非布局释放函数由该类的
析构函数的定义 odr 使用，或由在虚
析构函数\iref{class.dtor} 的定义点进行查找来选择。
\begin{footnote}
不要求实现
从构造函数或析构函数调用分配和
释放函数；但是，这
是一种允许的实现技术。
\end{footnote}

\pnum
类中的赋值运算符函数由另一个类的
隐式定义的
复制赋值或移动赋值函数 odr 使用，如 \ref{class.copy.assign} 中所述。
类的构造函数如 \ref{dcl.init} 中所述被 odr 使用。如果类的析构函数是潜在
调用的\iref{class.dtor}，则它是 odr 使用的。

\pnum
局部实体\iref{basic.pre}
在作用域\iref{basic.scope.scope} 中是 \defn{odr 可用} 的，如果
\begin{itemize}
\item 局部实体不是 \tcode{*\keyword{this}}，或
存在一个外围类或非 lambda 函数形参作用域，并且
如果最内层的此类作用域是函数形参作用域，
则它对应于一个非静态成员函数，并且
\item
对于引入实体的点和作用域
（其中 \tcode{*\keyword{this}} 被认为是在
最内层外围类或非 lambda 函数定义作用域内引入）
之间的每个中间作用域\iref{basic.scope.scope}，
满足以下条件之一：
\begin{itemize}
\item 中间作用域是块作用域，或
\item 中间作用域是
\grammarterm{lambda-expression} 或 \grammarterm{requires-expression} 的函数形参作用域，或
\item 中间作用域是
具有命名实体或具有 \grammarterm{capture-default} 的 \grammarterm{simple-capture} 的 \grammarterm{lambda-expression} 的 lambda 作用域，并且
\grammarterm{lambda-expression} 的块作用域
也是一个中间作用域。
\end{itemize}
\end{itemize}

如果局部实体在
它不是 odr 可用的作用域中被 odr 使用，
则程序是病构的。
\begin{example}
\begin{codeblock}
void f(int n) {
  [] { n = 1; };                // error: \tcode{n} is not odr-usable due to intervening lambda-expression
  struct A {
    void f() { n = 2; }         // error: \tcode{n} is not odr-usable due to intervening function definition scope
  };
  void g(int = n);              // error: \tcode{n} is not odr-usable due to intervening function parameter scope
  [=](int k = n) {};            // error: \tcode{n} is not odr-usable due to being
                                // outside the block scope of the \grammarterm{lambda-expression}
  [&] { [n]{ return n; }; };    // OK
}
\end{codeblock}
\end{example}

\pnum
\begin{example}
\begin{codeblock}
void g() {
  constexpr int x = 1;
  auto lambda = [] <typename T, int = ((T)x, 0)> {};    // OK
  lambda.operator()<int, 1>();          // OK, does not consider \tcode{x} at all
  lambda.operator()<int>();             // OK, does not odr-use \tcode{x}
  lambda.operator()<const int&>();      // error: odr-uses \tcode{x} from a context where \tcode{x} is not odr-usable
}

void h() {
  constexpr int x = 1;
  auto lambda = [] <typename T> { (T)x; };      // OK
  lambda.operator()<int>();             // OK, does not odr-use \tcode{x}
  lambda.operator()<void>();            // OK, does not odr-use \tcode{x}
  lambda.operator()<const int&>();      // error: odr-uses \tcode{x} from a context where \tcode{x} is not odr-usable
}
\end{codeblock}
\end{example}

\pnum
每个程序都应至少包含一个
在该程序中
除弃置语句\iref{stmt.if} 外被 odr 使用的每个函数或变量的定义；不需要诊断。
定义可以显式地出现在程序中，它可以在
标准库或用户定义的库中找到，或者（在适当的情况下）它是
隐式定义的（参见 \ref{class.default.ctor}、\ref{class.copy.ctor}、
\ref{class.dtor} 和 \ref{class.copy.assign}）。
\begin{example}
\begin{codeblock}
auto f() {
  struct A {};
  return A{};
}
decltype(f()) g();
auto x = g();
\end{codeblock}
包含此翻译单元的程序是病构的，
因为 \tcode{g} 被 odr 使用但未定义，
并且不能在任何其他翻译单元中定义，
因为局部类 \tcode{A} 不能在此翻译单元外命名。
\end{example}

\pnum
\defn{定义域} 是
\grammarterm{private-module-fragment} 或
翻译单元中
排除其 \grammarterm{private-module-fragment}（如果有）的部分。
内联函数或变量的定义应可以从
它在弃置语句外被 odr 使用的每个定义域的末尾到达。

\pnum
\indextext{type!incomplete}%
类的定义应在
以需要类类型完整的方式使用该类的每个上下文中可到达。
\begin{example}
以下完整的翻译单元是良构的，
即使它从未定义 \tcode{X}：
\begin{codeblock}
struct X;                       // declare \tcode{X} as a struct type
struct X* x1;                   // use \tcode{X} in pointer formation
X* x2;                          // use \tcode{X} in pointer formation
\end{codeblock}
\end{example}
\begin{note}
声明和表达式的规则
描述了需要完整类类型的上下文。类
类型 \tcode{T} 必须是完整的，如果
\begin{itemize}
\item 定义了类型为 \tcode{T} 的对象\iref{basic.def}，或
\item 声明了类型为 \tcode{T} 的非静态类数据成员\iref{class.mem}，或
\item \tcode{T} 用作 \grammarterm{new-expression}\iref{expr.new} 中的分配类型或数组元素类型，或
\item 将左值到右值转换应用于引用
类型为 \tcode{T} 的对象的泛左值\iref{conv.lval}，或
\item 将表达式（隐式或显式）转换为
类型 \tcode{T}\iref{conv,expr.type.conv,
expr.dynamic.cast,expr.static.cast,expr.cast}，或
\item 将不是空指针常量且类型
不是 \cv{} \tcode{\keyword{void}*} 的表达式使用标准转换\iref{conv}、
\keyword{dynamic_cast}\iref{expr.dynamic.cast} 或
\keyword{static_cast}\iref{expr.static.cast} 转换为指向 \tcode{T} 的指针类型或对 \tcode{T} 的引用类型，或
\item 将类成员访问运算符应用于类型为
\tcode{T} 的表达式\iref{expr.ref}，或
\item 将 \keyword{typeid} 运算符\iref{expr.typeid} 或 \keyword{sizeof} 运算符\iref{expr.sizeof} 应用于
类型为 \tcode{T} 的操作数，或
\item 定义或调用\iref{basic.def} 具有类型为 \tcode{T} 的返回类型或实参类型的函数\iref{expr.call}，或
\item 定义了具有类型为 \tcode{T} 的基类的类\iref{class.derived}，或
\item 将类型为 \tcode{T} 的左值赋值给\iref{expr.ass}，或
\item 类型 \tcode{T} 是
\keyword{alignof} 表达式\iref{expr.alignof} 的主题，或
\item \grammarterm{exception-declaration} 具有类型 \tcode{T}、对
\tcode{T} 的引用或指向 \tcode{T} 的指针\iref{except.handle}。
\end{itemize}
\end{note}

\pnum
对于在多个翻译单元中具有定义的任何可定义项 \tcode{D}，
\begin{itemize}
\item
如果 \tcode{D} 是非内联非模板函数或变量，或
\item
如果不同翻译单元中的定义
不满足以下要求，
\end{itemize}
则程序是病构的；
仅当可定义项附加到命名模块并且
在稍后出现定义的位置可以到达先前的定义时，才需要诊断。
给定这样一个项目，
对于 \tcode{D} 的所有定义，或者，
如果 \tcode{D} 是未命名枚举，
对于在任何给定程序点可到达的 \tcode{D} 的所有定义，
应满足以下要求。
\begin{itemize}
\item 每个此类定义
不应附加到命名模块\iref{module.unit}。
\item 每个此类定义应由
相同的记号序列组成，
其中闭包类型的定义
被认为由
相应的 \grammarterm{lambda-expression} 的记号序列组成。
\item 在每个此类定义中，根据 \ref{basic.lookup} 查找的对应名称应指代相同的实体，在
重载解析\iref{over.match} 和部分
模板特化匹配\iref{temp.spec.partial.match} 之后，但名称可以指代
\begin{itemize}
\item
具有内部或无链接的非 volatile const 对象，如果该对象
\begin{itemize}
\item 在 \tcode{D} 的所有定义中具有相同的字面量类型，
\item 用常量表达式\iref{expr.const} 初始化，
\item 在 \tcode{D} 的任何定义中都未被 odr 使用，并且
\item 在 \tcode{D} 的所有定义中具有相同的值，
\end{itemize}
或
\item
用常量表达式初始化的具有内部或无链接的引用，使得
该引用在 \tcode{D} 的所有定义中指代相同的实体。
\end{itemize}

\item 在每个此类定义中，除了在
\tcode{D} 的默认实参和默认模板实参中，
相应的 \grammarterm{lambda-expression} 应具有
相同的闭包类型（见下文）。

\item 在每个此类定义中，对应的实体应具有
相同的语言链接。

\item 在每个此类定义中，
如果对象在任何此类定义中是常量初始化的，则
具有静态或线程存储期的 const 对象
应是常量初始化的。

\item 在每个此类定义中，
不是值依赖的相应显式常量求值表达式
应具有相同的值\iref{expr.const,temp.dep.constexpr}。

\item 在每个此类定义中，引用的重载运算符、
对转换函数、构造函数、运算符
new 函数和运算符 delete 函数的隐式调用应指代相同的
函数。

\item 在每个此类定义中，
（隐式或显式）函数调用使用的默认实参或
（隐式或显式）
\grammarterm{template-id} 或 \grammarterm{simple-template-id} 使用的默认模板实参
被视为其记号序列
存在于 \tcode{D} 的定义中；
也就是说，默认实参或默认模板实参
受本段中描述的要求的约束（递归地）。
\end{itemize}

\pnum
出于上述要求的目的：

\begin{itemize}
\item 如果 \tcode{D} 是具有隐式声明的
构造函数\iref{class.default.ctor,class.copy.ctor} 的类，
则就好像构造函数
在它被 odr 使用的每个翻译单元中都是隐式定义的，并且
每个翻译单元中的隐式定义都应为 \tcode{D} 的子对象调用相同的
构造函数。
\begin{example}
\begin{codeblock}
// translation unit 1:
struct X {
  X(int, int);
  X(int, int, int);
};
X::X(int, int = 0) { }
class D {
  X x = 0;
};
D d1;                           // \tcode{X(int, int)} called by \tcode{D()}

// translation unit 2:
struct X {
  X(int, int);
  X(int, int, int);
};
X::X(int, int = 0, int = 0) { }
class D {
  X x = 0;
};
D d2;                           // \tcode{X(int, int, int)} called by \tcode{D()};
                                // \tcode{D()}'s implicit definition violates the ODR
\end{codeblock}
\end{example}

\item 如果 \tcode{D} 是具有
默认的三向比较运算符函数\iref{class.spaceship} 的类，
则就好像该运算符
在它被 odr 使用的每个翻译单元中都是隐式定义的，并且
每个翻译单元中的隐式定义都应为 \tcode{D} 的每个子对象调用相同的
比较运算符。

\item
如果 \tcode{D} 是一个模板并且在多个
翻译单元中定义，则这些要求
既适用于模板定义中使用的模板外围作用域的名称，也适用于
实例化点的依赖名称\iref{temp.dep}。
\end{itemize}

\pnum
这些要求也适用于
在 \tcode{D} 的每个定义中定义的相应实体
（包括 \grammarterm{lambda-expression} 的闭包类型，
但不包括在 \tcode{D} 或
未在 \tcode{D} 中定义的实体的默认实参或
默认模板实参中定义的实体）。
对于每个此类实体和 \tcode{D} 本身，
其行为就好像只有一个具有单个定义的实体，
包括在将这些要求应用于其他实体时。
\begin{note}
该实体仍然在多个翻译单元中声明，并且 \ref{basic.link}
仍然适用于这些声明。特别是，
出现在 \tcode{D} 的类型中的 \grammarterm{lambda-expression}\iref{expr.prim.lambda}
可能导致不同的声明具有不同的类型，并且
出现在 \tcode{D} 的默认实参中的 \grammarterm{lambda-expression}
在不同的翻译单元中可能仍然表示不同的类型。
\end{note}

\pnum
\begin{example}
\begin{codeblock}
inline void f(bool cond, void (*p)()) {
  if (cond) f(false, []{});
}
inline void g(bool cond, void (*p)() = []{}) {
  if (cond) g(false);
}
struct X {
  void h(bool cond, void (*p)() = []{}) {
    if (cond) h(false);
  }
};
\end{codeblock}

如果 \tcode{f} 的定义出现在多个翻译单元中，
则程序的行为就好像
\tcode{f} 只有一个定义。
如果 \tcode{g} 的定义出现在多个翻译单元中，
则程序是病构的（不需要诊断），因为
每个此类定义都使用
引用不同 \grammarterm{lambda-expression} 闭包类型的默认实参。
\tcode{X} 的定义可以
出现在有效程序的多个翻译单元中；
在 \tcode{X} 的定义中 \tcode{X::h} 的默认实参中定义的 \grammarterm{lambda-expression}
在每个翻译单元中表示相同的闭包类型。
\end{example}

\pnum
如果在程序的任何点，
在相同作用域中有多个
具有相同第一个枚举器名称并且
没有用于链接目的的 typedef 名称\iref{dcl.enum} 的可到达未命名枚举定义，
则这些未命名枚举类型应相同；不需要诊断。
\indextext{one-definition rule|)}

\rSec1[basic.scope]{作用域}%
\indextext{scope|(}

\rSec2[basic.scope.scope]{概述}

\pnum
程序中的声明出现在许多通常不连续的 \defnx{作用域}{scope} 中。
\defnadj{全局}{作用域} 包含整个程序；
每个其他作用域 $S$ 都由
声明、
\grammarterm{parameter-declaration-clause}、
\grammarterm{statement} 或 \grammarterm{handler}
（如 \ref{basic.scope} 的以下子条款中所述）
引入，出现在另一个从而包含 $S$ 的作用域中。
程序点处的 \defnadj{外围}{作用域} 是包含它的任何作用域；
最小的此类作用域被称为该点处的 \defnadj{直接}{作用域}。
如果一个作用域是或包含 $S$ 但不包含 $P$，则该作用域 \defnx{介入}{scope!intervene}
程序点 $P$ 和作用域 $S$（不包含 $P$）之间。

\pnum
除非另有说明：
\begin{itemize}
\item
包含作用域 $S$ 的最小作用域是 $S$ 的 \defnadj{父}{作用域}。
\item
没有两个声明（重新）引入相同的实体。
\item
声明 \defnx{位于}{scope!inhabit} 其位置\iref{basic.scope.pdecl} 处的直接作用域。
\item
声明的 \defnadj{目标}{作用域} 是它所在的作用域。
\item
由声明（重新）引入的任何名称都 \defnx{绑定}{name!bound} 到其目标作用域中的声明。
\end{itemize}
如果 $S$ 是实体声明的目标作用域，则实体 \defnx{属于}{entity!belong} 作用域 $S$。
\begin{note}
特殊情况包括：
\begin{itemize}
\item
模板形参作用域仅为
其他模板形参作用域的父作用域\iref{basic.scope.temp}。
\item
具有适当链接的相应声明
声明相同的实体\iref{basic.link}。
\item
\grammarterm{template-declaration} 中的声明
与 \grammarterm{template-declaration} 位于同一作用域。
\item
友元声明和
模板特化声明不绑定名称\iref{dcl.meaning}；
具有限定名的那些以指定的作用域为目标，而
其他友元声明和
某些 \grammarterm{elaborated-type-specifier}
\iref{dcl.type.elab} 以更大的外围作用域为目标。
\item
块作用域 extern 声明以更大的外围作用域为目标，
但在其直接作用域中绑定名称。
\item
未限定作用域的枚举器的名称绑定
在两个最内层外围作用域中\iref{dcl.enum}。
\item
类的名称也绑定在其自身的作用域中\iref{class.pre}。
\item
匿名联合的成员的名称绑定在
联合的父作用域中\iref{class.union.anon}。
\end{itemize}
\end{note}

\pnum
如果满足以下条件，则两个非静态成员函数具有
\defnadjx{相应的}{对象形参}{object parameter}：
\begin{itemize}
\item
恰好一个是没有 \grammarterm{ref-qualifier} 的隐式对象成员函数，
并且它们的对象形参\iref{dcl.fct} 的类型
在移除引用后
相同，或者
\item
它们的对象形参具有相同的类型。
\end{itemize}
\indextext{template!function!corresponding object parameter}%
如果满足以下条件，则两个非静态成员函数模板具有
\defnadjx{相应的}{对象形参}{object parameter}：
\begin{itemize}
\item
恰好一个是没有 \grammarterm{ref-qualifier} 的隐式对象成员函数，
并且它们的对象形参的类型，
在移除任何引用后，
是等效的，或者
\item
它们的对象形参的类型是等效的。
\end{itemize}
\indextext{template!function!corresponding signature}%
如果满足以下条件，则两个函数模板具有
\defnadjx{相应的}{签名}{signature}：
它们的 \grammarterm{template-parameter-list} 具有相同的长度，
它们对应的 \grammarterm{template-parameter} 是等效的，
它们具有等效的非对象形参类型列表和返回类型（如果有），并且，
如果两者都是非静态成员，则它们具有相应的对象形参。

\pnum
如果两个声明满足以下条件，则它们 \defn{对应}：
它们（重新）引入相同的名称，
都声明构造函数，或
都声明析构函数，
除非
\begin{itemize}
\item
其中之一是 \grammarterm{using-declarator}，或
\item
一个声明类型（不是 \grammarterm{typedef-name}）而另一个声明
变量、
除匿名联合\iref{class.union.anon} 之外的非静态数据成员、
枚举器、
函数或
函数模板，或
\item
每个都声明一个函数或函数模板，
并且它们没有声明相应的重载。
\end{itemize}
如果满足以下条件，则两个函数或函数模板声明声明
\defn{相应的重载}：
\begin{itemize}
\item
两者都声明具有相同的非对象形参类型列表的函数，
\begin{footnote}
隐式对象形参\iref{over.match.funcs}
不是形参类型列表的一部分。
\end{footnote}
等效的\iref{temp.over.link} 尾随 \grammarterm{requires-clause}
（如果有，除了 \ref{temp.friend} 中指定的），并且，
如果两者都是非静态成员，
则它们具有相应的对象形参，或
\item
两者都声明具有相应签名和等效
\grammarterm{template-head} 和
尾随 \grammarterm{requires-clause}（如果有）的函数模板。
\end{itemize}
\begin{note}
即使两者都不绑定名称，声明也可以对应。
\begin{example}
\begin{codeblock}
struct A {
  friend void f();      // \#1
};
struct B {
  friend void f() {}    // corresponds to, and defines, \#1
};
\end{codeblock}
\end{example}
\end{note}
\begin{example}
\begin{codeblock}
typedef int Int;
enum E : int { a };
void f(int);                    // \#1
void f(Int) {}                  // defines \#1
void f(E) {}                    // OK, another overload

struct X {
  static void f();
  void f() const;               // error: redeclaration
  void g();
  void g() const;               // OK
  void g() &;                   // error: redeclaration

  void h(this X&, int);
  void h(int) &&;               // OK, another overload
  void j(this const X&);
  void j() const &;             // error: redeclaration
  void k();
  void k(this X&);              // error: redeclaration
};
\end{codeblock}
\end{example}

\pnum
如果声明的名称是 \tcode{_}（\unicode{005f}{下划线}）并且它声明
\begin{itemize}
\item
具有自动存储期的变量，
\item
没有 \grammarterm{storage-class-specifier} 且
不在命名空间作用域中的结构化绑定，
\item
由 \grammarterm{init-capture} 引入的变量，或
\item
除匿名联合之外的非静态数据成员。
\end{itemize}
则声明是 \defnx{名称无关}{declaration!name-independent} 的。

\recommended
实现不应发出
使用或未使用名称无关声明的警告。

\pnum
\indextext{declaration!potentially conflict}%
如果两个声明对应并且
导致它们的共享名称表示不同的实体\iref{basic.link}，则它们 \defn{潜在冲突}。
如果在任何作用域中，名称绑定到两个声明 $A$ 和 $B$，
它们潜在冲突并且 $A$ 在 $B$ 之前\iref{basic.lookup}，
则程序是病构的，除非 $B$ 是名称无关的。
\begin{note}
命名唯一的名称无关声明的 \grammarterm{id-expression}
在同一作用域中引入相同名称的其他声明之前是可用的\iref{basic.lookup.general}。
\end{note}
\begin{note}
重载解析可以考虑
在多个作用域中找到的潜在冲突声明
（例如，通过 \grammarterm{using-directive} 或对于运算符函数），
在这种情况下，它通常是模棱两可的。
\end{note}
\begin{example}
\begin{codeblock}
void f() {
  int x,y;
  void x();             // error: different entity for \tcode{x}
  int y;                // error: redefinition
}
enum { f };             // error: different entity for \tcode{::f}
namespace A {}
namespace B = A;
namespace B = A;        // OK, no effect
namespace B = B;        // OK, no effect
namespace A = B;        // OK, no effect
namespace B {}          // error: different entity for \tcode{B}

void g() {
  int _;
  _ = 0;                // OK
  int _;                // OK, name-independent declaration
  _ = 0;                // error: two non-function declarations in the lookup set
}
void h () {
  int _;                // \#1
  _ ++;                 // OK
  static int _;         // error: conflicts with \#1 because static variables are not name-independent
}
\end{codeblock}
\end{example}

\pnum
\indextext{declaration!nominable}%
如果声明满足以下条件，则它在类、类模板或命名空间 $E$ 中的点 $P$ 处是 \defn{可提名} 的：
它在 $P$ 之前，
它不在块作用域中，并且
它的目标作用域是与 $E$ 关联的作用域，或者，
如果 $E$ 是命名空间，
则是 $E$ 的内联命名空间集的任何元素\iref{namespace.def}。
\begin{example}
\begin{codeblock}
namespace A {
  void f() {void g();}
  inline namespace B {
    struct S {
      friend void h();
      static int i;
    };
  }
}
\end{codeblock}
在本例的末尾，
\tcode{f}、\tcode{B}、\tcode{S} 和 \tcode{h} 的声明
在 \tcode{A} 中是可提名的，但 \tcode{g} 和 \tcode{i} 的声明不是。
\end{example}

\pnum
当实例化模板实体\iref{temp.pre} 时，
由模板定义的任何部分引入的任何作用域 $S$ 都被视为
由实例化的实体引入，并且
包含位于 $S$ 中的任何声明的实例化。

\rSec2[basic.scope.pdecl]{声明点}

\indextext{declaration!point of|see{locus}}%
\indextext{scope!declarations and|see{locus}}%
\indextext{locus|(}%

\pnum
\indextext{declaration!locus|see{locus}}%
作为声明符的声明\iref{basic.pre} 的 \defn{位置}
紧跟在完整声明符\iref{dcl.decl} 之后。
\begin{example}
\begin{codeblock}
unsigned char x = 12;
{ unsigned char x = x; }
\end{codeblock}
这里，第二个 \tcode{x} 的初始化具有未定义行为，
因为初始化器在其生存期\iref{basic.life} 之外访问第二个 \tcode{x}。
\end{example}

\pnum
\begin{note}
\indextext{name hiding}%
来自外部作用域的名称保持可见，直到
隐藏它的声明的位置。
\begin{example}
\begin{codeblock}
const int i = 2;
{ int i[i]; }
\end{codeblock}
声明一个包含两个整数的块作用域数组。
\end{example}
\end{note}

\pnum
\grammarterm{class-specifier} 的位置紧跟在
其 \grammarterm{class-head}\iref{class.pre} 中的 \grammarterm{identifier} 或 \grammarterm{simple-template-id}（如果有）之后。
\grammarterm{enum-specifier} 的位置紧跟在
其 \grammarterm{enum-head} 之后；
\grammarterm{opaque-enum-declaration} 的位置
紧跟在其后\iref{dcl.enum}。
%FIXME: What's "it" below? What's "it" above?
\grammarterm{alias-declaration} 的位置紧跟在其后。

\pnum
不命名构造函数的 \grammarterm{using-declarator}
的位置紧跟在 \grammarterm{using-declarator}\iref{namespace.udecl} 之后。

\pnum
\grammarterm{enumerator-definition} 的位置紧跟在其后。
\begin{example}
\begin{codeblock}
const int x = 12;
{ enum { x = x }; }
\end{codeblock}
这里，枚举器 \tcode{x} 用
常量 \tcode{x} 的值（即 12）初始化。
\end{example}

\pnum
\begin{note}
\indextext{type!incomplete}%
在类成员声明之后，
即使类是不完整类，也可以在其类的作用域中找到成员名称。
\begin{example}
\begin{codeblock}
struct X {
  enum E { z = 16 };
  int b[X::z];          // OK
};
\end{codeblock}
\end{example}
\end{note}

\pnum
作为声明\iref{dcl.type.elab} 的 \grammarterm{elaborated-type-specifier}
的位置紧跟在其后。

\pnum
注入类名声明\iref{class.pre}
的位置紧跟在类定义的左大括号之后。

\pnum
函数局部预定义变量\iref{dcl.fct.def.general}
的隐式声明的位置紧接在
其函数定义的 \grammarterm{function-body} 之前。

\pnum
结构化绑定\iref{dcl.struct.bind}
的声明的位置紧跟在
结构化绑定声明的 \grammarterm{identifier-list} 之后。

\pnum
基于范围的 \keyword{for} 语句\iref{stmt.ranged} 的 \grammarterm{for-range-declaration}
的位置紧跟在 \grammarterm{for-range-initializer} 之后。

\pnum
\grammarterm{template-parameter} 的位置紧跟在其后。
\begin{example}
\begin{codeblock}
typedef unsigned char T;
template<class T
  = T               // lookup finds the \grammarterm{typedef-name}
  , T               // lookup finds the template parameter
    N = 0> struct A { };
\end{codeblock}
\end{example}

\pnum
\grammarterm{concept-definition} 的位置
紧跟在其 \grammarterm{concept-name}\iref{temp.concept} 之后。
\begin{note}
\grammarterm{constraint-expression} 不能使用
\grammarterm{concept-name}。
\end{note}

\pnum
具有 \grammarterm{identifier} 的 \grammarterm{namespace-definition}
的位置紧跟在 \grammarterm{identifier} 之后。
\begin{note}
为 \grammarterm{unnamed-namespace-definition}\iref{namespace.unnamed}
发明了一个标识符。
\end{note}

\pnum
\begin{note}
友元声明可以引入属于最近的外围命名空间或块作用域的函数或类，
但它们不在任何地方绑定名称\iref{class.friend}。
块作用域中的函数声明和
在块作用域中使用 \keyword{extern} 说明符的变量声明声明
属于最近的外围命名空间的实体，
但它们不在其中绑定名称。
\end{note}

\pnum
\begin{note}
有关模板的实例化点，请参见 \ref{temp.point}。
\end{note}
\indextext{locus|)}

\pnum
作为声明\iref{dcl.type.elab} 的 \grammarterm{elaborated-type-specifier}
的位置紧跟在其后。

\pnum
注入类名声明\iref{class.pre}
的位置紧跟在类定义的左大括号之后。

\pnum
函数局部预定义变量\iref{dcl.fct.def.general}
的隐式声明的位置紧接在
其函数定义的 \grammarterm{function-body} 之前。

\pnum
结构化绑定\iref{dcl.struct.bind}
的声明的位置紧跟在
结构化绑定声明的 \grammarterm{identifier-list} 之后。

\pnum
基于范围的 \keyword{for} 语句\iref{stmt.ranged} 的 \grammarterm{for-range-declaration}
的位置紧跟在 \grammarterm{for-range-initializer} 之后。

\pnum
\grammarterm{template-parameter} 的位置紧跟在其后。
\begin{example}
\begin{codeblock}
typedef unsigned char T;
template<class T
  = T               // lookup finds the \grammarterm{typedef-name}
  , T               // lookup finds the template parameter
    N = 0> struct A { };
\end{codeblock}
\end{example}

\pnum
\grammarterm{concept-definition} 的位置
紧跟在其 \grammarterm{concept-name}\iref{temp.concept} 之后。
\begin{note}
\grammarterm{constraint-expression} 不能使用
\grammarterm{concept-name}。
\end{note}

\pnum
具有 \grammarterm{identifier} 的 \grammarterm{namespace-definition}
的位置紧跟在 \grammarterm{identifier} 之后。
\begin{note}
为 \grammarterm{unnamed-namespace-definition}\iref{namespace.unnamed}
发明了一个标识符。
\end{note}

\pnum
\begin{note}
友元声明可以引入属于最近的外围命名空间或块作用域的函数或类，
但它们不在任何地方绑定名称\iref{class.friend}。
块作用域中的函数声明和
在块作用域中使用 \keyword{extern} 说明符的变量声明声明
属于最近的外围命名空间的实体，
但它们不在其中绑定名称。
\end{note}

\pnum
\begin{note}
有关模板的实例化点，请参见 \ref{temp.point}。
\end{note}
\indextext{locus|)}

\rSec2[basic.scope.block]{块作用域}

\indextext{local scope|see{scope, block}}%

\pnum
每个
\begin{itemize}
\item
选择或迭代语句\iref{stmt.select,stmt.iter}，
\item
此类语句的子语句，
\item
\indextext{scope!\idxgram{handler}}%
\grammarterm{handler}\iref{except.pre}，或
\item
不是 \grammarterm{handler} 的 \grammarterm{compound-statement} 的
复合语句\iref{stmt.block}
\end{itemize}
引入一个包含该语句或 \grammarterm{handler} 的 \defnadj{块}{作用域}。
\begin{note}
同时也是块的子语句只有一个作用域。
\end{note}
属于块作用域的变量是 \defn{块变量}。
\begin{example}
\begin{codeblock}
int i = 42;
int a[10];

for (int i = 0; i < 10; i++)
  a[i] = i;

int j = i;          // \tcode{j = 42}
\end{codeblock}
\end{example}

\pnum
如果一个声明
不是名称无关声明并且
在
\begin{itemize}
\item
\grammarterm{lambda-expression}、\grammarterm{function-body} 或 \grammarterm{function-try-block} 的 \grammarterm{compound-statement}，
\item
本身不是选择或迭代语句的选择或迭代语句的子语句，或
\item
\grammarterm{function-try-block} 的 \grammarterm{handler}
\end{itemize}
的块作用域 $S$ 中绑定一个名称，
与目标作用域为 $S$ 的父作用域的声明
潜在冲突，
则程序是病构的。
\begin{example}
\begin{codeblock}
if (int x = f()) {
  int x;            // error: redeclaration of \tcode{x}
}
else {
  int x;            // error: redeclaration of \tcode{x}
}
\end{codeblock}
\end{example}

\rSec2[basic.scope.param]{函数形参作用域}

\indextext{scope!function prototype|see{scope, function parameter}}%
\indextext{parameter!scope of}%

\pnum
\grammarterm{parameter-declaration-clause} $P$ 引入
一个包含 $P$ 的 \defnadj{函数形参}{作用域}。
\begin{note}
函数形参不能在其值
在 \grammarterm{parameter-declaration-clause}\iref{dcl.fct.default} 中使用。
\end{note}
\begin{itemize}
\item
如果 $P$ 与 \grammarterm{declarator} 关联并且
在形式为
\grammarterm{declarator-id} \opt{\grammarterm{attribute-specifier-seq}} 的（可能是带括号的）\grammarterm{noptr-declarator} 之前，
则其作用域扩展到最近的外围
\grammarterm{init-declarator}、
\grammarterm{member-declarator}、
\grammarterm{parameter-declaration} 的 \grammarterm{declarator} 或
\grammarterm{nodeclspec-function-declaration} 或
\grammarterm{function-definition} 的末尾，
但不包括关联的 \grammarterm{declarator} 的位置。
\begin{note}
在这种情况下，$P$ 声明函数
（或使用函数类型声明的函数或模板形参）的形参。
成员函数的形参作用域嵌套在其类的作用域内。
\end{note}
\item
如果 $P$ 与 \grammarterm{lambda-declarator} 关联，
则其作用域扩展到 \grammarterm{lambda-expression} 中 \grammarterm{compound-statement} 的末尾。
\item
如果 $P$ 与 \grammarterm{requirement-parameter-list} 关联，
则其作用域扩展到 \grammarterm{requires-expression} 的 \grammarterm{requirement-body} 的末尾。
\item
如果 $P$ 与 \grammarterm{deduction-guide} 关联，
则其作用域扩展到 \grammarterm{deduction-guide} 的末尾。
\end{itemize}

\rSec2[basic.scope.lambda]{Lambda 作用域}

\grammarterm{lambda-expression} \tcode{E} 引入一个 \defnadj{lambda}{作用域}，
该作用域从 \tcode{E} 的 \grammarterm{lambda-introducer} 之后立即开始，
并扩展到 \tcode{E} 的 \grammarterm{compound-statement} 的末尾。

\rSec2[basic.scope.namespace]{命名空间作用域}

\pnum
命名空间 $N$ 的任何 \grammarterm{namespace-definition} 都引入
一个 \defnadj{命名空间}{作用域}，
该作用域包括 $N$ 的每个 \grammarterm{namespace-definition} 的 \grammarterm{namespace-body}。
对于目标作用域是或包含在该作用域中的每个非友元重复声明或特化，
\grammarterm{declarator-id}、
\grammarterm{class-head-name} 或
\grammarterm{enum-head-name} 之后的部分
也包含在该作用域中。
全局作用域是
全局命名空间\iref{basic.namespace} 的命名空间作用域。
\begin{example}
\begin{codeblock}
namespace Q {
  namespace V { void f(); }
  void V::f() {         // in the scope of \tcode{V}
    void h();           // declares \tcode{Q::V::h}
  }
}
\end{codeblock}
\end{example}

\rSec2[basic.scope.class]{类作用域}

\pnum
类或类模板 $C$ 的任何声明都引入
一个 \defnadj{类}{作用域}，
该作用域包括 $C$ 的 \grammarterm{class-specifier} 的 \grammarterm{member-specification}（如果有）。
对于目标作用域是或包含在该作用域中的每个非友元重复声明或特化，
\grammarterm{declarator-id}、
\grammarterm{class-head-name} 或
\grammarterm{enum-head-name} 之后的部分
也包含在该作用域中。
\begin{note}
从类的 \grammarterm{class-specifier} 之前的程序点进行查找
将不会在类作用域中找到任何绑定。
\begin{example}
\begin{codeblock}
template<class D>
struct B {
  D::type x;            // \#1
};

struct A { using type = int; };
struct C : A, B<C> {};  // error at \#1: \tcode{C::type} not found
\end{codeblock}
\end{example}
\end{note}

\rSec2[basic.scope.enum]{枚举作用域}%

\pnum
枚举 $E$ 的任何声明都引入
一个 \defnadj{枚举}{作用域}，
该作用域包括 $E$ 的 \grammarterm{enum-specifier} 的 \grammarterm{enumerator-list}（如果有）。

\rSec2[basic.scope.temp]{模板形参作用域}%

\pnum
每个模板 \grammarterm{template-parameter} 都引入
一个 \defnadj{模板形参}{作用域}，
该作用域包括 \grammarterm{template-parameter} 的 \grammarterm{template-head}。

\pnum
每个 \grammarterm{template-declaration} $D$ 都引入
一个模板形参作用域，
该作用域从其 \grammarterm{template-parameter-list} 的开头
扩展到 \grammarterm{template-declaration} 的末尾。
\grammarterm{template-parameter-list} 之外的任何声明
如果位于该作用域中，则将位于与 $D$ 相同的作用域中。
任何不是模板形参作用域的作用域 $S$ 的父作用域
是包含 $S$ 且不是模板形参作用域的最小作用域。
\begin{note}
因此，只有模板形参属于模板形参作用域，并且
只有模板形参作用域具有
模板形参作用域作为父作用域。
\end{note}

\indextext{scope|)}

\rSec1[basic.lookup]{名称查找}%

\indextext{lookup!name|(}

\rSec2[basic.lookup.general]{概述}%
\indextext{scope!name lookup and|see{lookup, name}}%

\pnum
\defnx{名称查找}{lookup!name} 将名称的使用与
该名称的一组声明\iref{basic.def} 相关联。
名称查找规则统一适用于所有名称（包括
\grammarterm{typedef-name}{s}\iref{dcl.typedef}、
\grammarterm{namespace-name}{s}\iref{basic.namespace} 和
\grammarterm{class-name}{s}\iref{class.name}），只要语法允许
在特定规则讨论的上下文中使用此类名称。
除非另有说明，
否则如果未找到任何声明，则程序是病构的。
如果名称查找找到的声明
都表示函数或函数模板，
则这些声明被称为形成一个 \defn{重载集}。
否则，
如果名称查找找到的声明并非都表示相同的实体，
则它们是 \defn{模棱两可} 的，并且程序是病构的。
重载解析\iref{over.match,over.over}
在名称查找成功后进行。访问规则\iref{class.access}
仅在名称查找和
函数重载解析（如果适用）成功后才会被考虑。只有在
名称查找、函数重载解析（如果适用）和访问
检查成功后，
才会引入由声明引入的语义属性
以供进一步处理。

\pnum
程序点 $P$ 被称为跟在
同一翻译单元中
位置\iref{basic.scope.pdecl} 在 $P$ 之前的任何声明之后。
\begin{note}
该声明可能出现在不包含 $P$ 的作用域中。
\end{note}
\indextext{precede|see{declaration, precede}}%
如果满足以下条件，则声明 $X$ \defnx{先于}{declaration!precede}
翻译单元 $L$ 中的程序点 $P$：
$P$ 跟在 $X$ 之后，$X$ 位于类作用域中并且可以从 $P$ 到达，或者
$X$ 出现在翻译单元 $D$ 中并且
\begin{itemize}
\item
$P$ 跟在
导入 $D$（直接或间接）的 \grammarterm{module-import-declaration} 或 \grammarterm{module-declaration} 之后，并且
\item
$X$ 出现在 $D$ 中的 \grammarterm{module-declaration} 之后（如果有）和
$D$ 中的 \grammarterm{private-module-fragment} 之前（如果有），并且
\item
$X$ 是导出的，或者 $D$ 和 $L$ 属于同一个模块并且
$X$ 不位于具有内部链接的命名空间中或
声明具有内部链接的名称。
\begin{note}
由 \grammarterm{using-declaration} 声明的名称没有链接。
\end{note}
\end{itemize}
\begin{note}
\grammarterm{module-import-declaration} 既导入
命名的翻译单元，也导入
其中导出的 \grammarterm{module-import-declaration} 命名的任何模块，
递归地。
\begin{example}
\begin{codeblocktu}{Translation unit \#1}
export module Q;
export int sq(int i) { return i*i; }
\end{codeblocktu}

\begin{codeblocktu}{Translation unit \#2}
export module R;
export import Q;
\end{codeblocktu}

\begin{codeblocktu}{Translation unit \#3}
import R;
int main() { return sq(9); }    // OK, \tcode{sq} from module \tcode{Q}
\end{codeblocktu}
\end{example}
\end{note}

\pnum
\indextext{scope!search!single}%
在作用域 $S$ 中为来自程序点 $P$ 的名称 $N$ 进行的 \defnadj{单次}{查找}
会找到所有先于 $P$ 的声明，
其中任何与 $N$\iref{basic.pre} 相同的名称都绑定在 $S$ 中。
如果任何此类声明是 \grammarterm{using-declarator}，
其终结名称\iref{expr.prim.id.unqual}
不是依赖的\iref{temp.dep.type}，
则它将被 \grammarterm{using-declarator} 命名的声明替换\iref{namespace.udecl}。

\pnum
在某些上下文中，只包含某些类型的声明。
在任何此类限制之后，如果找到任何其他声明，则丢弃类或枚举的任何声明。
\begin{note}
因此，类型（但不是 \grammarterm{typedef-name} 或模板）
会被其作用域中的任何其他实体隐藏。
\end{note}
\indextext{type-only!lookup|see{lookup, type-only}}%
但是，如果查找是 \defnx{仅类型}{lookup!type-only} 的，
则只考虑类型和
其特化是类型的模板的声明；
此外，如果找到 \grammarterm{typedef-name} 及其引用的类型的声明，
则丢弃 \grammarterm{typedef-name} 的声明
而不是类型声明。

\rSec2[class.member.lookup]{成员名称查找}%
\indextext{lookup!member name}%
\indextext{ambiguity!base class member}%
\indextext{ambiguity!member access}

\pnum
\indextext{scope!search}%
在作用域 $X$ 中为来自程序点 $P$ 的名称 $M$ 进行的 \defn{查找}
是在 $X$ 中为 $M$ 从 $P$ 进行的单次查找，
除非 $X$ 是类或类模板 $T$ 的作用域，在这种情况下，以下
步骤定义查找的结果。
\begin{note}
仅当 $M$ 是 \grammarterm{conversion-function-id} 或
单次查找将找不到任何内容时，结果才会有所不同。
\end{note}

\pnum
类或类模板 $C$ 中名称 $N$ 的 \defn{查找集}（称为 $S(N,C)$）
由两个组件集组成：
\term{声明集}，一组名为 $N$ 的成员；以及
\term{子对象集}，
一组找到这些成员的声明的子对象
（可能通过 \grammarterm{using-declaration}）。
在声明集中，类型声明（包括注入类名）
被它们指定的类型替换。$S(N,C)$ 的计算方式如下：

\pnum
如果 $P$ 位于 $C$ 的完整类上下文中，
则声明集是在 $C$ 的作用域中为 $N$
从 $C$ 的 \grammarterm{class-specifier} 之后立即进行的单次查找的结果，
否则从 $P$ 进行。
如果生成的声明集不为空，则子对象集
包含 $C$ 本身，并且计算完成。

\pnum
否则（即，$C$ 不包含 $N$ 的声明
或生成的声明集为空），$S(N,C)$ 最初为空。
计算每个直接非依赖\iref{temp.dep.type} 基类子对象 $B_i$ 中 $N$ 的查找集，并且
依次将每个此类查找集 $S(N,B_i)$ 合并到 $S(N,C)$ 中。
\begin{note}
如果 $C$ 不完整，
则仅考虑其 \grammarterm{base-specifier} 出现在 $P$ 之前的基类。
如果 $C$ 是实例化的类，则其基类不是依赖的。
\end{note}

\pnum
以下步骤定义将查找集 $S(N,B_i)$
合并到中间 $S(N,C)$ 的结果：

\begin{itemize}
\item 如果 $S(N,B_i)$ 的每个子对象成员都是 $S(N,C)$ 的至少一个子对象成员的基类
子对象，或者如果 $S(N,B_i)$ 为空，则 $S(N,C)$ 不变，合并完成。
相反，如果 $S(N,C)$ 的每个子对象成员都是 $S(N,B_i)$ 的至少一个子对象成员的基类
子对象，或者如果 $S(N,C)$ 为空，则新的 $S(N,C)$ 是 $S(N,B_i)$ 的副本。

\item 否则，如果 $S(N,B_i)$ 和 $S(N,C)$ 的声明集
不同，则合并是模棱两可的：新的 $S(N,C)$ 是一个具有
无效声明集的查找集，以及子对象集的并集。在
后续合并中，无效声明集被认为与任何其他声明集不同。

\item 否则，新的 $S(N,C)$ 是一个具有共享声明集
和子对象集并集的查找集。
\end{itemize}

\pnum
查找的结果是 $S(M,T)$ 的声明集。
如果它是无效集，则程序是病构的。
如果它与在 $T$ 的完整类上下文\iref{class.mem} 中为 $M$ 进行查找的结果不同，
则程序是病构的，不需要诊断。
\begin{example}
\begin{codeblock}
struct A { int x; };                    // S(x,A) = \{ \{ \tcode{A::x} \}, \{ \tcode{A} \} \}
struct B { float x; };                  // S(x,B) = \{ \{ \tcode{B::x} \}, \{ \tcode{B} \} \}
struct C: public A, public B { };       // S(x,C) = \{ invalid, \{ \tcode{A} in \tcode{C}, \tcode{B} in \tcode{C} \} \}
struct D: public virtual C { };         // S(x,D) = S(x,C)
struct E: public virtual C { char x; }; // S(x,E) = \{ \{ \tcode{E::x} \}, \{ \tcode{E} \} \}
struct F: public D, public E { };       // S(x,F) = S(x,E)
int main() {
  F f;
  f.x = 0;                              // OK, lookup finds \tcode{E::x}
}
\end{codeblock}

$S(\tcode{x},\tcode{F})$ 是明确的，因为 \tcode{D} 的 \tcode{A} 和 \tcode{B} 基类
子对象也是 \tcode{E} 的基类子对象，所以
$S(\tcode{x},\tcode{D})$ 在第一次合并步骤中被丢弃。
\end{example}

\pnum
如果 $M$ 是非依赖 \grammarterm{conversion-function-id}，
则考虑 $T$ 的成员的转换函数模板。
对于每个此类模板 $F$，构造查找集 $S(t,T)$，
认为函数模板声明具有名称 $t$
仅当它对应于 $F$ 的声明\iref{basic.scope.scope} 时。
每个此类查找集的声明集的成员（不应是无效集）都包含在结果中。
\begin{note}
重载解析将丢弃那些
无法转换为 $M$\iref{temp.over} 指定的类型的成员。
\end{note}

\pnum
\begin{note}
即使对象具有多个类型为 \tcode{T} 的
基类子对象，也可以明确找到在基类 \tcode{T} 中定义的静态成员、嵌套类型或枚举器。
两个基类子对象共享其公共虚基类的非静态成员子对象。
\end{note}
\begin{example}
\begin{codeblock}
struct V {
  int v;
};
struct A {
  int a;
  static int s;
  enum { e };
};
struct B : A, virtual V { };
struct C : A, virtual V { };
struct D : B, C { };

void f(D* pd) {
  pd->v++;          // OK, only one \tcode{v} (virtual)
  pd->s++;          // OK, only one \tcode{s} (static)
  int i = pd->e;    // OK, only one \tcode{e} (enumerator)
  pd->a++;          // error: ambiguous: two \tcode{a}{s} in \tcode{D}
}
\end{codeblock}
\end{example}

\pnum
\begin{note}
\indextext{dominance!virtual base class}%
当使用虚基类时，可以通过
不经过隐藏声明的子对象格路径到达隐藏的声明。这不是歧义。
非虚基类的相同使用是歧义的；在这种情况下，没有
唯一的实例名称隐藏所有其他名称。
\end{note}
\begin{example}
\begin{codeblock}
struct V { int f();  int x; };
struct W { int g();  int y; };
struct B : virtual V, W {
  int f();  int x;
  int g();  int y;
};
struct C : virtual V, W { };

struct D : B, C { void glorp(); };
\end{codeblock}

\begin{importgraphic}
{Name lookup}
{class.lookup}
{figname.pdf}
\end{importgraphic}

如 \fref{class.lookup} 所示，
在 \tcode{V} 和左侧 \tcode{W} 实例中声明的名称
被 \tcode{B} 中的名称隐藏，但右侧 \tcode{W} 实例中声明的名称
根本没有被隐藏。
\begin{codeblock}
void D::glorp() {
  x++;              // OK, \tcode{B::x} hides \tcode{V::x}
  f();              // OK, \tcode{B::f()} hides \tcode{V::f()}
  y++;              // error: \tcode{B::y} and \tcode{C}'s \tcode{W::y}
  g();              // error: \tcode{B::g()} and \tcode{C}'s \tcode{W::g()}
}
\end{codeblock}
\end{example}
\indextext{ambiguity!class conversion}%

\pnum
从指向派生类对象的指针或
指定派生类对象的表达式到指向或引用其基类之一的指针或引用的显式或隐式转换，应
明确地引用表示基类的唯一对象。
\begin{example}
\begin{codeblock}
struct V { };
struct A { };
struct B : A, virtual V { };
struct C : A, virtual V { };
struct D : B, C { };

void g() {
  D d;
  B* pb = &d;
  A* pa = &d;       // error: ambiguous: \tcode{C}'s \tcode{A} or \tcode{B}'s \tcode{A}?
  V* pv = &d;       // OK, only one \tcode{V} subobject
}
\end{codeblock}
\end{example}

\pnum
\begin{note}
即使名称查找的结果是明确的，使用在
多个子对象中找到的名称仍然可能是
模棱两可的\iref{conv.mem,expr.ref,class.access.base}。
\end{note}
\begin{example}
\begin{codeblock}
struct B1 {
  void f();
  static void f(int);
  int i;
};
struct B2 {
  void f(double);
};
struct I1: B1 { };
struct I2: B1 { };

struct D: I1, I2, B2 {
  using B1::f;
  using B2::f;
  void g() {
    f();                        // Ambiguous conversion of \keyword{this}
    f(0);                       // Unambiguous (static)
    f(0.0);                     // Unambiguous (only one \tcode{B2})
    int B1::* mpB1 = &D::i;     // Unambiguous
    int D::* mpD = &D::i;       // Ambiguous conversion
  }
};
\end{codeblock}
\end{example}

\rSec2[basic.lookup.unqual]{非限定名称查找}

\indextext{name!unqualified}%

\pnum
如果 \grammarterm{using-directive}
先于 $P$ 并且位于 $S$ 中或
位于在 $P$ 处在 $U$ 中处于活动状态的 \grammarterm{using-directive} 提名的命名空间的作用域中，
则 \grammarterm{using-directive} 在作用域 $S$ 中的程序点 $P$ 处是 \term{活动} 的。

\pnum
在作用域 $S$ 中为来自程序点 $P$ 的名称 $N$ 进行的 \term{非限定查找}
包括在以下各项中为 $P$ 进行查找的结果
\begin{itemize}
\item
$S$，以及
\item
对于任何包含 $P$ 并且是或包含在 $S$ 中的作用域 $U$，
由在 $U$ 中的 $P$ 处处于活动状态的 \grammarterm{using-directive} 提名的 $S$ 包含的每个命名空间。
\end{itemize}
如果未找到任何声明，
则非限定查找的结果是
在 $S$ 的父作用域（如果有）中为 $P$ 进行非限定查找的结果。
\begin{note}
当搜索类作用域时，
也会搜索其基类的作用域\iref{class.member.lookup}。
如果它从单个基类继承，
则就好像基类的作用域立即包含
派生类的作用域。
也考虑
与父作用域链中的一个作用域关联的模板形参作用域\iref{temp.local}。
\end{note}

\pnum
\defnx{非限定名称查找}{lookup!unqualified name}
从程序点执行在其直接作用域中的非限定查找。

\pnum
\defnadj{非限定}{名称} 是
不紧跟在 \grammarterm{nested-name-specifier} 或
类成员访问表达式\iref{expr.ref} 中的 \tcode{.} 或 \tcode{->} 之后的名称，
可能在 \keyword{template} 关键字或 \tcode{\~} 之后。
除非另有说明，
否则此类名称从其出现的点进行非限定名称查找。

\pnum
作为 \grammarterm{conversion-type-id} 的 \grammarterm{type-specifier} 或 \grammarterm{ptr-operator} 的
组件名称\iref{expr.prim.id.unqual} 的非限定名称
以与它出现的 \grammarterm{conversion-function-id} 相同的方式查找。
如果该查找未找到任何内容，则它进行非限定名称查找；
在每种情况下，只考虑表示
类型或其特化为类型的模板的名称。
\begin{example}
\begin{codeblock}
struct T1 { struct U { int i; }; };
struct T2 { };
struct U1 {};
struct U2 {};

struct B {
  using T = T1;
  using U = U1;
  operator U1 T1::*();
  operator U1 T2::*();
  operator U2 T1::*();
  operator U2 T2::*();
};

template<class X, class T>
int g() {
  using U = U2;
  X().operator U T::*();                // \#1, searches for \tcode{T} in the scope of \tcode{X} first
  X().operator U decltype(T())::*();    // \#2
  return 0;
}
int x = g<B, T2>();                     // \#1 calls \tcode{B::operator U1 T1::*}
                                        // \#2 calls \tcode{B::operator U1 T2::*}
\end{codeblock}
\end{example}

\pnum
在 \grammarterm{declarator-id} 是 \grammarterm{qualified-id} 的友元声明 \grammarterm{declarator} 中，
其查找上下文\iref{basic.lookup.qual} 是类或命名空间 $S$，
对出现在 \grammarterm{declarator-id} 之后的非限定名称的查找
在与 $S$ 关联的作用域中执行搜索。
如果该查找未找到任何内容，则它进行非限定名称查找。
\begin{example}
\begin{codeblock}
using I = int;
using D = double;
namespace A {
  inline namespace N {using C = char; }
  using F = float;
  void f(I);
  void f(D);
  void f(C);
  void f(F);
}
struct X0 {using F = float; };
struct W {
  using D = void;
  struct X : X0 {
    void g(I);
    void g(::D);
    void g(F);
  };
};
namespace B {
  typedef short I, F;
  class Y {
    friend void A::f(I);        // error: no \tcode{void A::f(short)}
    friend void A::f(D);        // OK
    friend void A::f(C);        // error: \tcode{A::N::C} not found
    friend void A::f(F);        // OK
    friend void W::X::g(I);     // error: no \tcode{void X::g(short)}
    friend void W::X::g(D);     // OK
    friend void W::X::g(F);     // OK
  };
}
\end{codeblock}
\end{example}

\rSec2[basic.lookup.argdep]{依赖于实参的名称查找}%
\indextext{lookup!argument-dependent}

\pnum
当函数调用\iref{expr.call} 中的 \grammarterm{postfix-expression} 是 \grammarterm{unqualified-id}，
并且 \grammarterm{unqualified-id} 中名称的非限定查找\iref{basic.lookup.unqual} 未找到任何
\begin{itemize}
\item
类成员的声明，或
\item
位于块作用域中的函数声明，或
\item
不是函数或函数模板的声明
\end{itemize}
则名称的查找还包括
在一组依赖于实参类型的关联命名空间中的
\defnadj{依赖于实参的}{查找} 的结果
（对于模板模板实参，还包括模板实参的命名空间），
如下所述。
\begin{example}
\begin{codeblock}
namespace N {
  struct S { };
  void f(S);
}

void g() {
  N::S s;
  f(s);             // OK, calls \tcode{N::f}
  (f)(s);           // error: \tcode{N::f} not considered; parentheses prevent argument-dependent lookup
}
\end{codeblock}
\end{example}

\pnum
\begin{note}
为了确定
（在解析期间）表达式是否为函数调用的
\grammarterm{postfix-expression}，适用通常的名称查找
规则。
在某些情况下
后跟 \tcode{<} 的名称被视为 \grammarterm{template-name}，
即使名称查找未找到 \grammarterm{template-name}
（参见 \ref{temp.names}）。
例如，
\begin{codeblock}
int h;
void g();
namespace N {
  struct A {};
  template <class T> int f(T);
  template <class T> int g(T);
  template <class T> int h(T);
}

int x = f<N::A>(N::A());        // OK, lookup of \tcode{f} finds nothing, \tcode{f} treated as template name
int y = g<N::A>(N::A());        // OK, lookup of \tcode{g} finds a function, \tcode{g} treated as template name
int z = h<N::A>(N::A());        // error: \tcode{h<} does not begin a \grammarterm{template-id}
\end{codeblock}

这些规则对表达式的语法解释没有影响。
例如，
\begin{codeblock}
typedef int f;
namespace N {
  struct A {
    friend void f(A &);
    operator int();
    void g(A a) {
      int i = f(a);             // \tcode{f} is the typedef, not the friend function: equivalent to \tcode{int(a)}
    }
  };
}
\end{codeblock}
因为表达式不是函数调用，
所以不应用依赖于实参的名称查找，并且
找不到友元函数 \tcode{f}。
\end{note}

\pnum
对于函数调用中的每个实参类型 \tcode{T}，
都有一个要考虑的零个或多个 \defnx{关联实体}{entity!associated} 的集合。
实体集完全由
函数实参的类型
（以及任何模板模板实参）确定。
用于指定类型的任何 \grammarterm{typedef-name} 和 \grammarterm{using-declaration}
对该集合没有贡献。
实体集
通过以下方式确定：
\begin{itemize}
\item 如果 \tcode{T} 是基本类型，则其关联实体集
为空。

\item 如果 \tcode{T} 是类类型（包括联合），
则其关联实体是：
类本身；
它是其成员的类（如果有）；
并且，如果它是完整类型，则为其直接和间接基类。
此外，如果 \tcode{T} 是类模板特化，
则其关联实体还包括：
与为模板类型形参提供的模板实参类型关联的实体；
用作模板模板实参的模板；以及
任何用作模板模板实参的成员模板所属的类。
\begin{note}
非类型模板实参不
对关联实体集有贡献。
\end{note}

\item 如果 \tcode{T} 是枚举类型，
则其关联实体是 \tcode{T}，
并且如果它是类成员，则为成员的类。

\item 如果 \tcode{T} 是指向 \tcode{U} 的指针或 \tcode{U} 的数组，
则其关联实体是与 \tcode{U} 关联的那些实体。

\item 如果 \tcode{T} 是函数类型，则其关联
实体是与函数形参类型关联的那些实体以及与
返回类型关联的那些实体。

\item 如果 \tcode{T} 是指向类 \tcode{X} 的成员函数的指针，则其关联
实体是与函数形参类型和返回类型关联的那些实体，以及与
\tcode{X} 关联的那些实体。

\item 如果 \tcode{T} 是指向类 \tcode{X} 的数据成员的指针，则其
关联实体是与成员
类型关联的那些实体以及与 \tcode{X} 关联的那些实体。
\end{itemize}
此外，如果实参是重载集或此类集合的地址，
则其关联实体
是与集合的每个成员关联的那些实体的并集，即与
其形参类型和返回类型关联的实体。
此外，如果上述重载集使用
\grammarterm{template-id} 命名，则其关联实体还包括
其模板模板实参和
与其类型模板实参关联的那些实体。

\pnum
调用的 \term{关联命名空间} 是
其关联实体的最内层外围非内联命名空间
以及这些命名空间的内联命名空间集\iref{namespace.def} 的每个元素。
依赖于实参的查找会找到
函数和函数模板的所有声明，这些声明
\begin{itemize}
\item
通过任何关联命名空间的搜索找到，或
\item
声明为具有关联实体集中可到达定义的任何类的友元\iref{class.friend}，或
\item
是导出的，
附加到命名模块 \tcode{M}\iref{module.interface}，
不出现在包含查找点的翻译单元中，并且
与附加到 \tcode{M}\iref{basic.link} 的关联实体的声明具有相同的最内层外围非内联命名空间作用域。
\end{itemize}
如果查找是针对依赖名称\iref{temp.dep,temp.dep.candidate}，
则上述查找也会从查找的每个实例化上下文\iref{module.context} 中的点执行，
另外忽略任何
出现在另一个翻译单元中、
附加到全局模块并且
被丢弃\iref{module.global.frag} 或具有内部链接的声明。

\pnum
\begin{example}
\begin{codeblocktu}{Translation unit \#1}
export module M;
namespace R {
  export struct X {};
  export void f(X);
}
namespace S {
  export void f(R::X, R::X);
}
\end{codeblocktu}

\begin{codeblocktu}{Translation unit \#2}
export module N;
import M;
export R::X make();
namespace R { static int g(X); }
export template<typename T, typename U> void apply(T t, U u) {
  f(t, u);
  g(t);
}
\end{codeblocktu}

\begin{codeblocktu}{Translation unit \#3}
module Q;
import N;
namespace S {
  struct Z { template<typename T> operator T(); };
}
void test() {
  auto x = make();              // OK, \tcode{decltype(x)} is \tcode{R::X} in module \tcode{M}
  R::f(x);                      // error: \tcode{R} and \tcode{R::f} are not visible here
  f(x);                         // OK, calls \tcode{R::f} from interface of \tcode{M}
  f(x, S::Z());                 // error: \tcode{S::f} in module \tcode{M} not considered
                                // even though \tcode{S} is an associated namespace
  apply(x, S::Z());             // error: \tcode{S::f} is visible in instantiation context, but
                                // \tcode{R::g} has internal linkage and cannot be used outside TU \#2
}
\end{codeblocktu}
\end{example}

\pnum
\begin{note}
关联命名空间可以包括
已被普通非限定查找考虑的命名空间。
\end{note}
\begin{example}
\begin{codeblock}
namespace NS {
  class T { };
  void f(T);
  void g(T, int);
}
NS::T parm;
void g(NS::T, float);
int main() {
  f(parm);                      // OK, calls \tcode{NS::f}
  extern void g(NS::T, float);
  g(parm, 1);                   // OK, calls \tcode{g(NS::T, float)}
}
\end{codeblock}
\end{example}

\rSec2[basic.lookup.qual]{限定名称查找}

\rSec3[basic.lookup.qual.general]{概述}

\pnum
\indextext{lookup!qualified name|(}%
\indextext{name!qualified}%
\indextext{qualification!explicit}%
查找后跟 \tcode{::} 作用域解析运算符的 \grammarterm{identifier}
仅考虑
命名空间、类型和其特化为类型的模板。
如果名称、\grammarterm{template-id} 或 \grammarterm{computed-type-specifier}
后跟 \tcode{::}，
则它应指定命名空间、类、枚举或依赖类型，
并且 \tcode{::} 永远不会被解释为
完整的 \grammarterm{nested-name-specifier}。
\begin{example}
\begin{codeblock}
class A {
public:
  static int n;
};
int main() {
  int A;
  A::n = 42;            // OK
  A b;                  // error: \tcode{A} does not name a type
}
template<int> struct B : A {};
namespace N {
  template<int> void B();
  int f() {
    return B<0>::n;     // error: \tcode{N::B<0>} is not a type
  }
}
\end{codeblock}
\end{example}

\pnum
\indextext{operator!scope resolution}%
\indextext{scope resolution operator|see{operator, scope resolution}}%

\pnum
成员限定名是
\begin{itemize}
\item
\grammarterm{unqualified-id} 或
\item
形式为
\grammarterm{type-name} \tcode{::} 或 \grammarterm{namespace-name} \tcode{::} 的 \grammarterm{nested-name-specifier}
\end{itemize}
的类成员访问表达式\iref{expr.ref} 的 \grammarterm{id-expression} 中
（唯一的）组件名称\iref{expr.prim.id.unqual}（如果有）。
\defnadj{限定}{名称} 是
\begin{itemize}
\item 成员限定名称或
\item 以下各项的终结名称
\begin{itemize}
\item \grammarterm{qualified-id}，
\item \grammarterm{using-declarator}，
\item \grammarterm{typename-specifier}，
\item \grammarterm{qualified-namespace-specifier}，或
\item 具有 \grammarterm{nested-name-specifier}\iref{expr.prim.id.qual} 的 \grammarterm{nested-name-specifier}、
\grammarterm{elaborated-type-specifier} 或
\grammarterm{class-or-decltype}。
\end{itemize}
\end{itemize}
成员限定名的 \defn{查找上下文} 是
其关联对象表达式的类型
（如果对象表达式是类型依赖的，则认为是依赖的）。
任何其他限定名称的查找上下文是
前面的 \grammarterm{nested-name-specifier} 指定的
类型、模板或命名空间。
\begin{note}
当解析类成员访问时，
\tcode{->} 或 \tcode{.} 之后的名称是
限定名称，即使尚不知道它是哪种名称。
\end{note}
\begin{example}
在
\begin{codeblock}
  N::C::m.Base::f()
\end{codeblock}
中，\tcode{Base} 是成员限定名；
其他限定名称是 \tcode{C}、\tcode{m} 和 \tcode{f}。
\end{example}

\pnum
\defnx{限定名称查找}{lookup!qualified name}
在类、命名空间或枚举中执行
与其关联的作用域的搜索\iref{class.member.lookup}，
但如下所述除外。
除非另有说明，
否则限定名称在其查找上下文中
从其出现的点进行限定名称查找，
除非查找上下文是依赖的并且不是当前实例化\iref{temp.dep.type} 或
不是类或类模板。
如果对作为 \grammarterm{nested-name-specifier} 的终结名称\iref{expr.prim.id.unqual} 并且
不是依赖的成员限定名称进行限定查找未找到任何内容，
则它进行非限定查找。
\begin{note}
在查找模板特化期间，没有名称是依赖的。
\end{note}
\begin{example}
\begin{codeblock}
int f();
struct A {
  int B, C;
  template<int> using D = void;
  using T = void;
  void f();
};
using B = A;
template<int> using C = A;
template<int> using D = A;
template<int> using X = A;

template<class T>
void g(T *p) {                  // as instantiated for \tcode{g<A>}:
  p->X<0>::f();                 // error: \tcode{A::X} not found in \tcode{((p->X) < 0) > ::f()}
  p->template X<0>::f();        // OK, \tcode{::X} found in definition context
  p->B::f();                    // OK, non-type \tcode{A::B} ignored
  p->template C<0>::f();        // error: \tcode{A::C} is not a template
  p->template D<0>::f();        // error: \tcode{A::D<0>} is not a class type
  p->T::f();                    // error: \tcode{A::T} is not a class type
}
template void g(A*);
\end{codeblock}
\end{example}

\pnum
如果限定名称 $Q$ 跟在 \tcode{\~} 之后：
\begin{itemize}
\item
如果 $Q$ 是成员限定名，
则它进行非限定查找以及限定查找。
\item
否则，其 \grammarterm{nested-name-specifier} $N$ 应指定一个类型。
如果 $N$ 具有另一个 \grammarterm{nested-name-specifier} $S$，
则 $Q$ 的查找就好像其查找上下文是由 $S$ 指定的一样。
\item
否则，如果 $N$ 的终结名是成员限定名 $M$，
则 $Q$ 的查找就好像 \tcode{\~}Q 出现在 $M$ 的位置（如上所述）。
\item
否则，$Q$ 进行非限定查找。
\item
$Q$ 的每次查找都只考虑
类型（如果 $Q$ 后面没有 \tcode{<}）和
其特化是类型的模板。
如果未找到任何内容或是模棱两可的，则将其丢弃。
\item
作为或包含 $Q$ 的 \grammarterm{type-name}
应在其（原始）查找上下文（忽略 cv 限定）下引用
至少一次（成功）查找所建立的解释。
\end{itemize}
\begin{example}
\begin{codeblock}
struct C {
  typedef int I;
};
typedef int I1, I2;
extern int* p;
extern int* q;
void f() {
  p->C::I::~I();        // \tcode{I} is looked up in the scope of \tcode{C}
  q->I1::~I2();         // \tcode{I2} is found by unqualified lookup
}
struct A {
  ~A();
};
typedef A AB;
int main() {
  AB* p;
  p->AB::~AB();         // explicitly calls the destructor for \tcode{A}
}
\end{codeblock}
\end{example}

\rSec3[class.qual]{类成员}

\indextext{lookup!class member}%

\pnum
在查找其查找上下文为类 $C$ 的限定名称 $N$ 时，
如果其中不忽略函数名称，
\begin{footnote}
在其中
忽略函数名称的查找包括出现在
\grammarterm{nested-name-specifier}、
\grammarterm{elaborated-type-specifier} 或 \grammarterm{base-specifier} 中的名称。
\end{footnote}
\begin{itemize}
\item
如果搜索找到 \tcode{C}\iref{class.pre} 的注入类名，或
\item
如果 $N$ 是依赖的并且
是命名构造函数的 \grammarterm{using-declarator}\iref{namespace.udecl}
的终结名称，
\end{itemize}
则 $N$ 被视为命名类 \tcode{C} 的构造函数。
此类构造函数名称只能
在构造函数的（友元）声明的 \grammarterm{declarator-id} 中使用，或
在 \grammarterm{using-declaration} 中使用。
\begin{example}
\begin{codeblock}
struct A { A(); };
struct B: public A { B(); };

A::A() { }
B::B() { }

B::A ba;            // object of type \tcode{A}
A::A a;             // error: \tcode{A::A} is not a type name
struct A::A a2;     // object of type \tcode{A}
\end{codeblock}
\end{example}

\rSec3[namespace.qual]{命名空间成员}

\pnum
命名空间 $N$ 中的限定名称查找还搜索
$N$\iref{namespace.def} 的内联命名空间集的每个元素。
如果未找到任何内容，
则查找的结果是
在由先于查找点并且
位于 $N$ 或 $N$ 的内联命名空间集的元素中的 \grammarterm{using-directive}
提名的每个命名空间中进行限定名称查找的结果。
\begin{note}
如果 \grammarterm{using-directive} 引用
已考虑过的命名空间，则它不会影响结果。
\end{note}
\begin{example}
\begin{codeblock}
int x;
namespace Y {
  void f(float);
  void h(int);
}

namespace Z {
  void h(double);
}

namespace A {
  using namespace Y;
  void f(int);
  void g(int);
  int i;
}

namespace B {
  using namespace Z;
  void f(char);
  int i;
}

namespace AB {
  using namespace A;
  using namespace B;
  void g();
}

void h()
{
  AB::g();          // \tcode{g} is declared directly in \tcode{AB}, therefore \tcode{S} is $\{ \tcode{AB::g()} \}$ and \tcode{AB::g()} is chosen

  AB::f(1);         // \tcode{f} is not declared directly in \tcode{AB} so the rules are applied recursively to \tcode{A} and \tcode{B};
                    // namespace \tcode{Y} is not searched and \tcode{Y::f(float)} is not considered;
                    // \tcode{S} is $\{ \tcode{A::f(int)}, \tcode{B::f(char)} \}$ and overload resolution chooses \tcode{A::f(int)}

  AB::f('c');       // as above but resolution chooses \tcode{B::f(char)}

  AB::x++;          // \tcode{x} is not declared directly in \tcode{AB}, and is not declared in \tcode{A} or \tcode{B}, so the rules
                    // are applied recursively to \tcode{Y} and \tcode{Z}, \tcode{S} is $\{ \}$ so the program is ill-formed

  AB::i++;          // \tcode{i} is not declared directly in \tcode{AB} so the rules are applied recursively to \tcode{A} and \tcode{B},
                    // \tcode{S} is $\{ \tcode{A::i}, \tcode{B::i} \}$ so the use is ambiguous and the program is ill-formed

  AB::h(16.8);      // \tcode{h} is not declared directly in \tcode{AB} and not declared directly in \tcode{A} or \tcode{B} so the rules
                    // are applied recursively to \tcode{Y} and \tcode{Z}, \tcode{S} is $\{ \tcode{Y::h(int)}, \tcode{Z::h(double)} \}$ and
                    // overload resolution chooses \tcode{Z::h(double)}
}
\end{codeblock}
\end{example}

\pnum
\begin{note}
多次找到相同的声明不是歧义（因为它仍然是唯一的声明）。
\begin{example}
\begin{codeblock}
namespace A {
  int a;
}

namespace B {
  using namespace A;
}

namespace C {
  using namespace A;
}

namespace BC {
  using namespace B;
  using namespace C;
}

void f()
{
  BC::a++;          // OK, \tcode{S} is $\{ \tcode{A::a}, \tcode{A::a} \}$
}

namespace D {
  using A::a;
}

namespace BD {
  using namespace B;
  using namespace D;
}

void g()
{
  BD::a++;          // OK, \tcode{S} is $\{ \tcode{A::a}, \tcode{A::a} \}$
}
\end{codeblock}
\end{example}
\end{note}

\pnum
\begin{example}
因为每个引用的命名空间最多搜索一次，
所以以下内容是良定义的：
\begin{codeblock}
namespace B {
  int b;
}

namespace A {
  using namespace B;
  int a;
}

namespace B {
  using namespace A;
}

void f()
{
  A::a++;           // OK, \tcode{a} declared directly in \tcode{A}, \tcode{S} is $\{ \tcode{A::a} \}$
  B::a++;           // OK, both \tcode{A} and \tcode{B} searched (once), \tcode{S} is $\{ \tcode{A::a} \}$
  A::b++;           // OK, both \tcode{A} and \tcode{B} searched (once), \tcode{S} is $\{ \tcode{B::b} \}$
  B::b++;           // OK, \tcode{b} declared directly in \tcode{B}, \tcode{S} is $\{ \tcode{B::b} \}$
}
\end{codeblock}
\end{example}

\pnum
\begin{note}
类和枚举声明不会
因为在其他搜索中找到的其他声明而被丢弃。
\end{note}
\begin{example}
\begin{codeblock}
namespace A {
  struct x { };
  int x;
  int y;
}

namespace B {
  struct y { };
}

namespace C {
  using namespace A;
  using namespace B;
  int i = C::x;     // OK, \tcode{A::x} (of type \tcode{int})
  int j = C::y;     // ambiguous, \tcode{A::y} or \tcode{B::y}
}
\end{codeblock}
\end{example}

\indextext{lookup!qualified name|)}%

\rSec2[basic.lookup.elab]{详述类型说明符}%
\indextext{lookup!elaborated type specifier|(}%
\indextext{type specifier!elaborated}

\pnum
如果 \grammarterm{elaborated-type-specifier} 中的 \grammarterm{class-key} 或 \keyword{enum} 关键字
后跟一个不后跟 \tcode{::} 的 \grammarterm{identifier}，
则对 \grammarterm{identifier} 的查找是仅类型\iref{basic.lookup.general} 的。
\begin{note}
通常，\grammarterm{elaborated-type-specifier} 的识别
取决于以下记号。
如果 \grammarterm{identifier} 后跟 \tcode{::}，
请参见 \ref{basic.lookup.qual}。
\end{note}

\pnum
如果 \grammarterm{elaborated-type-specifier} 的终结名称
是限定名称，
则对其的查找是仅类型的。
如果名称查找未找到先前声明的 \grammarterm{type-name}，
则 \grammarterm{elaborated-type-specifier} 是病构的。

\pnum
\begin{example}
\begin{codeblock}
struct Node {
  struct Node* Next;            // OK, refers to injected-class-name \tcode{Node}
  struct Data* Data;            // OK, declares type \tcode{Data} at global scope and member \tcode{Data}
};

struct Data {
  struct Node* Node;            // OK, refers to \tcode{Node} at global scope
  friend struct ::Glob;         // error: \tcode{Glob} is not declared, cannot introduce a qualified type\iref{dcl.type.elab}
  friend struct Glob;           // OK, refers to (as yet) undeclared \tcode{Glob} at global scope.
  @\commentellip@
};

struct Base {
  struct Data;                  // OK, declares nested \tcode{Data}
  struct ::Data*     thatData;  // OK, refers to \tcode{::Data}
  struct Base::Data* thisData;  // OK, refers to nested \tcode{Data}
  friend class ::Data;          // OK, global \tcode{Data} is a friend
  friend class Data;            // OK, nested \tcode{Data} is a friend
  struct Data { @\commentellip@ };    // Defines nested \tcode{Data}
};

struct Data;                    // OK, redeclares \tcode{Data} at global scope
struct ::Data;                  // error: cannot introduce a qualified type\iref{dcl.type.elab}
struct Base::Data;              // error: cannot introduce a qualified type\iref{dcl.type.elab}
struct Base::Datum;             // error: \tcode{Datum} undefined
struct Base::Data* pBase;       // OK, refers to nested \tcode{Data}
\end{codeblock}
\end{example}
\indextext{lookup!elaborated type specifier|)}%

\rSec2[basic.lookup.udir]{Using 指令和命名空间别名}

\pnum
\indextext{lookup!using-directives and}%
\indextext{lookup!namespace aliases and}%
在 \grammarterm{using-directive} 或 \grammarterm{namespace-alias-definition} 中，
在查找 \grammarterm{namespace-name} 或
\grammarterm{nested-name-specifier} 中的名称时，
只考虑命名空间名称。%
\indextext{lookup!name|)}%

\rSec1[basic.link]{程序和链接}%
\indextext{linkage|(}

\pnum
\indextext{program}%
\defn{程序} 由一个或多个链接在一起的翻译单元\iref{lex.separate} 组成。翻译单元由
声明序列组成。

\begin{bnf}
\nontermdef{translation-unit}\br
    \opt{declaration-seq}\br
    \opt{global-module-fragment} module-declaration \opt{declaration-seq} \opt{private-module-fragment}
\end{bnf}

\pnum
\indextext{translation unit}%
名称可以具有
\defnadj{外部}{链接}、
\defnadj{模块}{链接}、
\defnadj{内部}{链接} 或
\defnadj{无}{链接}，
由以下规则确定。
\begin{note}
具有内部链接的名称的实体的所有声明
都出现在同一个翻译单元中。
具有模块链接的实体的所有声明
都附加到同一个模块。
\end{note}

\pnum
\indextext{linkage!\idxcode{static} and}%
\indextext{\idxcode{static}!linkage of}%
\indextext{linkage!\idxcode{const} and}%
\indextext{\idxcode{const}!linkage of}%
\indextext{linkage!\idxcode{inline} and}%
\indextext{\idxcode{inline}!linkage of}%
属于命名空间作用域\iref{basic.scope.namespace} 的实体的名称
如果它是以下各项的名称，则具有内部链接
\begin{itemize}
\item
  显式声明为 \keyword{static} 的变量、变量模板、函数或函数模板；或
\item
  非 volatile const 限定类型的非模板变量，除非
  \begin{itemize}
  \item 它在模块接口单元的 purview 中声明
    （在 \grammarterm{private-module-fragment} 之外，如果有）或
    模块分区，或
  \item 它显式声明为 \keyword{extern}，或
  \item 它是内联的，或
  \item 它之前已声明并且先前的声明
  没有内部链接；或
  \end{itemize}
\item
  匿名联合的数据成员。
\end{itemize}
\begin{note}
具有 const 限定类型的实例化变量模板
可以具有外部或模块链接，即使未声明为 \keyword{extern}。
\end{note}

\pnum
未命名命名空间或在未命名命名空间中直接或间接声明的命名空间
具有内部链接。所有其他命名空间都具有外部链接。
属于命名空间作用域的实体名称，
上面没有给出内部链接，
并且是以下各项的名称
\begin{itemize}
\item 变量；或
\item 函数；或
\item
\indextext{class!linkage of}%
命名类\iref{class.pre}，或在
typedef 声明中定义的未命名类，其中类具有用于链接
目的\iref{dcl.typedef} 的 typedef 名称；或
\item
\indextext{enumeration!linkage of}%
命名枚举\iref{dcl.enum}，或在
typedef 声明中定义的未命名枚举，其中枚举具有用于链接
目的\iref{dcl.typedef} 的 typedef 名称；或
\item 未命名枚举，
该枚举具有作为用于链接目的\iref{dcl.enum} 的名称的枚举器；或
\item 模板
\end{itemize}
其链接确定如下：
\begin{itemize}
\item
\indextext{friend function!linkage of}%
如果实体是函数或函数模板
首先在友元声明中声明并且
该声明是定义并且
外围类在 \grammarterm{export-declaration} 中定义，
则该名称具有与外围类名称相同的链接（如果有）\iref{class.friend}；
\item
否则，
\indextext{friend function!linkage of}%
如果实体是函数或函数模板
在友元声明中声明并且
可以访问相应的非友元声明，
%FIXME: Which declaration is "that prior declaration"?
%FIXME: "prior" with respect to what? And what about dependent lookup?
则名称具有从先前声明确定的链接，
\item
否则，
如果外围命名空间具有内部链接，
则该名称具有内部链接；
\item
否则，
如果名称的声明
附加到命名模块\iref{module.unit}
并且未导出\iref{module.interface}，
则该名称具有模块链接；
\item
否则，
该名称具有外部链接。
\end{itemize}

\pnum
此外，
成员函数、
静态数据成员、
位于类作用域中的命名类或枚举，或
在位于类作用域中的 typedef 声明中定义的未命名类或枚举，
使得类或枚举
具有用于链接目的\iref{dcl.typedef} 的 typedef 名称，
具有与其所属的类的名称相同的链接（如果有）。

\pnum
\begin{example}
\begin{codeblock}
static void f();
extern "C" void h();
static int i = 0;               // \#1
void q() {
  extern void f();              // internal linkage
  extern void g();              // \tcode{::g}, external linkage
  extern void h();              // C language linkage
  int i;                        // \#2: \tcode{i} has no linkage
  {
    extern void f();            // internal linkage
    extern int i;               // \#3: internal linkage
  }
}
\end{codeblock}
即使第 \#2 行的声明隐藏了第 \#1 行的声明，
第 \#3 行的声明仍然重新声明了 \#1 并接收内部链接。
\end{example}

\pnum
\indextext{linkage!no}%
这些规则未涵盖的名称没有链接。此外，除非
另有说明，否则在块作用域\iref{basic.scope.block} 中声明的名称没有
链接。

\pnum
如果考虑到为链接目的引入其名称的未命名类型的声明\iref{dcl.typedef,dcl.enum}，
两个实体声明声明相同的实体，
它们对应\iref{basic.scope.scope}，
具有相同的目标作用域，该作用域不是函数或模板形参作用域，
都不是名称无关声明，
并且满足以下条件之一
\begin{itemize}
\item
它们出现在同一个翻译单元中，或
\item
它们都声明具有模块链接的名称并且附加到同一个模块，或
\item
它们都声明具有外部链接的名称。
\end{itemize}
\begin{note}
还有其他情况下声明声明相同的实体%
\iref{dcl.link,temp.type,temp.spec.partial}。
\end{note}

\pnum
如果声明具有内部链接的名称的声明 $H$
先于另一个翻译单元 $U$ 中的声明 $D$，并且
如果它出现在 $U$ 中将声明与 $D$ 相同的实体，
则程序是病构的。
\begin{note}
这样的 $H$ 只能出现在头单元中。
\end{note}

\pnum
如果实体的两个声明
附加到不同的模块，则程序是病构的；
如果两者都不能从另一个到达，则不需要诊断。
\begin{example}
\begin{codeblocktu}{\tcode{"decls.h"}}
int f();            // \#1, attached to the global module
int g();            // \#2, attached to the global module
\end{codeblocktu}

\begin{codeblocktu}{Module interface of \tcode{M}}
module;
#include "decls.h"
export module M;
export using ::f;   // OK, does not declare an entity, exports \#1
int g();            // error: matches \#2, but attached to \tcode{M}
export int h();     // \#3
export int k();     // \#4
\end{codeblocktu}

\begin{codeblocktu}{Other translation unit}
import M;
static int h();     // error: matches \#3
int k();            // error: matches \#4
\end{codeblocktu}
\end{example}
作为这些规则的结果，
实体的所有声明都附加到同一个模块；
该实体被称为 \defnx{附加}{attached!entity} 到该模块。

\pnum
\indextext{consistency!type declaration}%
\indextext{declaration!multiple}%
对于实体 $E$ 的任何两个声明：
\begin{itemize}
\item
如果一个声明 $E$ 为变量或函数，
则另一个应声明 $E$ 为相同类型。
\item
如果一个声明 $E$ 为枚举器，则另一个应这样做。
\item
如果一个声明 $E$ 为命名空间，则另一个应这样做。
\item
如果一个声明 $E$ 为类型，
则另一个应声明 $E$ 为相同类型的类型\iref{dcl.type.elab}。
\item
如果一个声明 $E$ 为类模板，
则另一个应使用相同的类型和
等效的 \grammarterm{template-head}\iref{temp.over.link} 这样做。
\begin{note}
声明可以提供不同的默认模板实参。
\end{note}
\item
如果一个声明 $E$ 为函数模板或
变量模板的（部分特化），
则另一个应声明 $E$ 为具有
等效 \grammarterm{template-head} 和类型的模板。
\item
如果一个声明 $E$ 为别名模板，
则另一个应声明 $E$ 为具有
等效 \grammarterm{template-head} 和 \grammarterm{defining-type-id} 的模板。
\item
如果一个声明 $E$ 为概念，则另一个应这样做。
\end{itemize}
在所有类型调整之后比较类型（在此期间
typedef\iref{dcl.typedef} 被其定义替换）；
数组对象的声明
可以指定因存在或不存在
主数组边界\iref{dcl.array} 而不同的数组类型。
如果两个声明都不能从另一个到达，则不需要诊断。
\begin{example}
\begin{codeblock}
int f(int x, int x);    // error: different entities for \tcode{x}
void g();               // \#1
void g(int);            // OK, different entity from \#1
int g();                // error: same entity as \#1 with different type
void h();               // \#2
namespace h {}          // error: same entity as \#2, but not a function
\end{codeblock}
\end{example}

\pnum
\begin{note}
可以使用
\grammarterm{linkage-specification}\iref{dcl.link} 实现与非 \Cpp{} 声明的链接。
\end{note}
\indextext{linkage|)}

\pnum
如果满足以下条件，则声明 $D$ \defnx{命名}{name} 实体 $E$：
\begin{itemize}
\item
$D$ 包含一个其闭包类型为 $E$ 的 \grammarterm{lambda-expression}，
\item
$E$ 不是函数或函数模板，并且 $D$ 包含
\grammarterm{id-expression}、
\grammarterm{type-specifier}、
\grammarterm{nested-name-specifier}、
\grammarterm{template-name} 或
\grammarterm{concept-name}
表示 $E$，或
\item
$E$ 是函数或函数模板，并且
$D$ 包含命名 $E$\iref{basic.def.odr} 的表达式或
引用包含 $E$ 的重载集的 \grammarterm{id-expression}。
\begin{note}
实例化声明中的非依赖名称
不引用重载集\iref{temp.res}。
\end{note}
\end{itemize}

\pnum
如果声明满足以下条件，则它是 \defn{暴露}：
它命名一个 TU-local 实体（定义如下），忽略
\begin{itemize}
\item
非内联函数或函数模板的 \grammarterm{function-body}
（但不是具有使用占位符类型的声明返回类型的函数
（可能是实例化的）定义的推导返回类型\iref{dcl.spec.auto}），
\item
变量或变量模板的 \grammarterm{initializer}
（但不是变量的类型），
\item
类定义中的友元声明，以及
\item
对任何使用不是 odr 使用\iref{term.odr.use} 的常量表达式初始化的
具有内部或无链接的非 volatile const 对象或引用的任何引用，
\end{itemize}
或定义初始化为 TU-local 值（定义如下）的 constexpr 变量。
\begin{note}
内联函数模板可以是暴露，即使
它的某些显式特化可以在其他翻译单元中使用。
\end{note}

\pnum
如果满足以下条件，则实体是 \defnx{TU-local}{TU-local!entity} 的：
\begin{itemize}
\item
它是类型、函数、变量或模板，
\begin{itemize}
\item
具有内部链接的名称，或
\item
没有链接名称并且在
TU-local 实体的定义内声明
或由 \grammarterm{lambda-expression} 引入，
\end{itemize}
\item
它是在 \grammarterm{class-specifier}、
函数体或 \grammarterm{initializer} 之外定义的
没有名称的类型，
或由用于仅声明 TU-local 实体的 \grammarterm{defining-type-specifier} 引入，
\item
它是 TU-local 模板的特化，
\item
它是具有任何 TU-local 模板实参的模板的特化，或
\item
它是模板的特化，
其（可能是实例化的）声明是暴露。
\begin{note}
特化可以通过隐式或显式实例化产生。
\end{note}
\end{itemize}

\pnum
如果满足以下条件，则值或对象是 \defnx{TU-local}{TU-local!value or object} 的：
\begin{itemize}
\item
它是或指向
TU-local 函数或与 TU-local 变量关联的对象，或
\item
它是类或数组类型的对象，并且
其任何子对象或
其引用类型的非静态数据成员引用的任何对象或函数
是 TU-local 并且可在常量表达式中使用。
\end{itemize}

\pnum
如果在模块接口单元
（\grammarterm{private-module-fragment} 之外，如果有）或
模块分区\iref{module.unit} 中
非 TU-local 实体的（可能是实例化的）声明或推导向导是暴露，
则程序是病构的。
任何其他上下文中的此类声明都已弃用\iref{depr.local}。

\pnum
如果出现在一个翻译单元中的声明
命名在另一个不是头单元的翻译单元中声明的 TU-local 实体，
则程序是病构的。
为模板特化实例化的声明\iref{temp.spec}
出现在特化的实例化点\iref{temp.point}。

\pnum
\begin{example}
\begin{codeblocktu}{Translation unit \#1}
export module A;
static void f() {}
inline void it() { f(); }           // error: is an exposure of \tcode{f}
static inline void its() { f(); }   // OK
template<int> void g() { its(); }   // OK
template void g<0>();

decltype(f) *fp;                    // error: \tcode{f} (though not its type) is TU-local
auto &fr = f;                       // OK
constexpr auto &fr2 = fr;           // error: is an exposure of \tcode{f}
constexpr static auto fp2 = fr;     // OK

struct S { void (&ref)(); } s{f};               // OK, value is TU-local
constexpr extern struct W { S &s; } wrap{s};    // OK, value is not TU-local

static auto x = []{f();};           // OK
auto x2 = x;                        // error: the closure type is TU-local
int y = ([]{f();}(),0);             // error: the closure type is not TU-local
int y2 = (x,0);                     // OK

namespace N {
  struct A {};
  void adl(A);
  static void adl(int);
}
void adl(double);

inline void h(auto x) { adl(x); }   // OK, but certain specializations are exposures
\end{codeblocktu}
\begin{codeblocktu}{Translation unit \#2}
module A;
void other() {
  g<0>();                           // OK, specialization is explicitly instantiated
  g<1>();                           // error: instantiation uses TU-local \tcode{its}
  h(N::A{});                        // error: overload set contains TU-local \tcode{N::adl(int)}
  h(0);                             // OK, calls \tcode{adl(double)}
  adl(N::A{});                      // OK; \tcode{N::adl(int)} not found, calls \tcode{N::adl(N::A)}
  fr();                             // OK, calls \tcode{f}
  constexpr auto ptr = fr;          // error: \tcode{fr} is not usable in constant expressions here
}
\end{codeblocktu}
\end{example}

\rSec1[basic.memobj]{内存和对象}

\rSec2[intro.memory]{内存模型}

\pnum
\indextext{memory model|(}%
\Cpp{} 内存模型中的基本存储单元是
\defn{字节}。
一个字节至少要大到足以包含
基本字面字符集\iref{lex.charset} 的任何元素的
普通字面量编码
\indextext{character set!basic literal}%
和 Unicode
\indextext{UTF-8}%
UTF-8 编码形式的八位代码单元，
并且由连续的位序列组成，
\begin{footnote}
字节中的位数由
头文件 \libheaderref{climits} 中的宏
\tcode{CHAR_BIT} 报告。
\end{footnote}
其数量是 \impldef{字节中的位数}。
\Cpp{} 程序可用的内存由一个或多个连续字节序列组成。
每个字节都有一个唯一的地址。

\pnum
\begin{note}
类型的表示在 \ref{basic.types.general} 中描述。
\end{note}

\pnum
\defn{内存位置} 是
由不是位域的标量类型对象的对象表示形式
或所有具有非零宽度的相邻位域的最大序列占用的存储。
\begin{note}
语言的各种
特性，例如引用和虚函数，可能
涉及程序无法访问但由
实现管理的额外内存位置。
\end{note}
两个或多个
执行线程\iref{intro.multithread} 可以访问单独的内存
位置而不会相互干扰。

\pnum
\begin{note}
因此，位域和相邻的非位域位于单独的内存
位置中，因此可以由两个执行线程同时更新
而不会干扰。这同样适用于两个位域，如果一个在
嵌套结构声明中声明而另一个不在，或者如果两者
由零长度位域声明分隔，或者如果它们由
非位域声明分隔。如果同一结构中的两个位域
之间的所有字段也是非零
宽度的位域，则不安全地同时更新这两个位域。
\end{note}

\pnum
\begin{example}
声明为
\begin{codeblock}
struct {
  char a;
  int b:5,
  c:11,
  :0,
  d:8;
  struct {int ee:8;} e;
};
\end{codeblock}
的类包含四个单独的内存位置：成员 \tcode{a} 和位域
\tcode{d} 和 \tcode{e.ee} 各自是单独的内存位置，并且可以
同时修改而不会相互干扰。位域
\tcode{b} 和 \tcode{c} 一起构成第四个内存位置。
位域 \tcode{b} 和 \tcode{c} 不能同时修改，但
\tcode{b} 和 \tcode{a} 可以。
\end{example}
\indextext{memory model|)}

\rSec2[intro.object]{对象模型}

\pnum
\indextext{object model|(}%
\Cpp{} 程序中的构造创建、销毁、引用、访问和
操作对象。
\defn{对象} 由
定义\iref{basic.def}、
\grammarterm{new-expression}\iref{expr.new}、
隐式创建对象的操作（见下文）、
隐式更改联合的活动成员\iref{class.union} 时
或
创建临时对象\iref{conv.rval,class.temporary} 时创建。
对象在其构造期间\iref{class.cdtor}、
整个生存期\iref{basic.life}
以及
其销毁期间\iref{class.cdtor} 占用存储区域。
\begin{note}
函数不是对象，无论它是否
以对象的方式占用存储。
\end{note}
对象
的属性在创建对象时确定。对象可以有
名称\iref{basic.pre}。对象具有
影响其生存期\iref{basic.life} 的存储期\iref{basic.stc}。对象具有
类型\iref{basic.types}。
\begin{note}
一些对象是
多态的\iref{class.virtual}；实现
生成与每个此类对象关联的信息，使得
可以在程序执行期间确定该对象的类型。
\end{note}

\pnum
\indextext{subobject}%
对象可以包含其他对象，称为 \defnx{子对象}{subobject}。
子对象可以是
\defn{成员子对象}\iref{class.mem}、\defn{基类子对象}\iref{class.derived}
或数组元素。
\indextext{object!complete}%
不是任何其他对象的子对象的对象称为 \defn{完整
对象}。
如果对象是在
与成员子对象或数组元素 \placeholder{e}
关联的存储中创建的（可能在其生存期内，也可能不在其生存期内），
则创建的对象
是 \placeholder{e} 的包含对象的子对象，如果
\begin{itemize}
\item
\placeholder{e} 的包含对象的生存期已经开始但尚未结束，并且
\item
新对象的存储完全覆盖与 \placeholder{e} 关联的存储位置，并且
\item
新对象与 \placeholder{e} 的类型相同（忽略 cv 限定）。
\end{itemize}

\pnum
\indextext{object!providing storage for}%
如果完整对象是在\iref{expr.new}
与类型为“$N$ 个 \tcode{\keyword{unsigned} \keyword{char}} 的数组”或
类型为“$N$ 个 \tcode{std::byte} 的数组”\iref{cstddef.syn} 的另一个对象 \placeholder{e}
关联的存储中创建的，
则该数组 \defn{提供存储}
给创建的对象，如果
\begin{itemize}
\item
\placeholder{e} 的生存期已经开始但尚未结束，并且
\item
新对象的存储完全位于 \placeholder{e} 内，并且
\item
没有满足这些约束的数组对象嵌套在 \placeholder{e} 中。
\end{itemize}
\begin{note}
如果数组的该部分
先前为另一个对象提供了存储，
则该对象的生存期结束，
因为其存储被重用\iref{basic.life}。
\end{note}
\begin{example}
\begin{codeblock}
// assumes that \tcode{sizeof(int)} is equal to 4

template<typename ...T>
struct AlignedUnion {
  alignas(T...) unsigned char data[max(sizeof(T)...)];
};
int f() {
  AlignedUnion<int, char> au;
  int *p = new (au.data) int;           // OK, \tcode{au.data} provides storage
  char *c = new (au.data) char();       // OK, ends lifetime of \tcode{*p}
  char *d = new (au.data + 1) char();
  return *c + *d;                       // OK
}

struct A { unsigned char a[32]; };
struct B { unsigned char b[16]; };
alignas(int) A a;
B *b = new (a.a + 8) B;                 // \tcode{a.a} provides storage for \tcode{*b}
int *p = new (b->b + 4) int;            // \tcode{b->b} provides storage for \tcode{*p}
                                        // \tcode{a.a} does not provide storage for \tcode{*p} (directly),
                                        // but \tcode{*p} is nested within \tcode{a} (see below)
\end{codeblock}
\end{example}

\pnum
\indextext{object!nested within}%
如果满足以下条件，则对象 \placeholder{a} \defn{嵌套在} 另一个对象 \placeholder{b} 中
\begin{itemize}
\item
\placeholder{a} 是 \placeholder{b} 的子对象，或
\item
\placeholder{b} 为 \placeholder{a} 提供存储，或
\item
存在一个对象 \placeholder{c}，
其中 \placeholder{a} 嵌套在 \placeholder{c} 中，
并且 \placeholder{c} 嵌套在 \placeholder{b} 中。
\end{itemize}

\pnum
对于每个对象 \tcode{x}，都有一个对象称为 \tcode{x} 的 \defn{完整对象}，确定如下：
\begin{itemize}
\item
如果 \tcode{x} 是一个完整对象，则 \tcode{x} 的完整对象
就是它本身。

\item
否则，\tcode{x} 的完整对象是
包含 \tcode{x} 的（唯一）对象的完整对象。
\end{itemize}

\pnum
如果一个完整对象、一个成员子对象或一个数组元素是
类类型，则其类型被认为是 \defn{最派生
类}，以将其与任何基类子对象的类类型区分开来；
最派生类类型或非类类型的对象称为
\defn{最派生对象}。

\pnum
\defn{潜在重叠子对象} 是：
\begin{itemize}
\item 基类子对象，或
\item 使用 \tcode{no_unique_address} 属性\iref{dcl.attr.nouniqueaddr} 声明的非静态数据成员。
\end{itemize}

\pnum
\indextext{object!zero size}%
\indextext{object!nonzero size}%
如果满足以下条件，则对象具有非零大小
\begin{itemize}
\item 不是潜在重叠子对象，或
\item 不是类类型，或
\item 是具有虚成员函数或虚基类的类类型，或
\item 具有非零大小的子对象或非零长度的未命名位域。
\end{itemize}
否则，如果对象是
没有非静态数据成员的标准布局类类型的基类子对象，
则它的大小为零。
否则，对象具有零大小的情况
是 \impldef{哪些不包含数据的非标准布局对象
被视为空}。
\indextext{most derived object!bit-field}%
除非它是位域\iref{class.bit}，
否则具有非零大小的对象
应占用一个或多个字节的存储，
包括其任何子对象完全或部分占用的每个字节。
可平凡复制或
标准布局类型\iref{basic.types.general} 的对象应占用连续的字节
存储。

\pnum
如果对象是字符串字面量对象\iref{lex.string}、
初始化器列表\iref{dcl.init.ref} 的后备数组或
其子对象，则它是 \defnadj{潜在非唯一}{对象}。

\pnum
\indextext{most derived object!bit-field}%
\indextext{most derived object!zero size subobject}%
除非对象是位域或零大小的子对象，否则
该对象的地址是它占用的第一个字节的地址。
具有重叠生存期的两个对象
不是位域
可以具有相同的地址，如果
\begin{itemize}
\item 一个嵌套在另一个中，
\item 至少一个是零大小的子对象，并且它们的类型不相似\iref{conv.qual}，
或
\item 它们都是潜在非唯一对象；
\end{itemize}
否则，它们具有不同的地址
并占用不相交的字节存储。
\begin{footnote}
根据“as-if”规则
如果程序无法观察到
差异\iref{intro.execution}，则允许实现将两个对象存储在同一机器地址或
根本不存储对象。
\end{footnote}
\begin{example}
\begin{codeblock}
static const char test1 = 'x';
static const char test2 = 'x';
const bool b = &test1 != &test2;        // always \tcode{true}

static const char (&r) [] = "x";
static const char *s = "x";
static std::initializer_list<char> il = { 'x' };
const bool b2 = r != il.begin();        // unspecified result
const bool b3 = r != s;                 // unspecified result
const bool b4 = il.begin() != &test1;   // always \tcode{true}
const bool b5 = r != &test1;            // always \tcode{true}
\end{codeblock}
\end{example}
零大小的非位域子对象的地址是
该子对象的完整对象占用的未指定字节的存储地址。

\pnum
一些操作被描述为
\defnx{隐式创建对象}{object!implicit creation}
在指定的存储区域内。
对于每个被指定为隐式创建对象的操作，
该操作在其指定的存储区域中隐式创建并开始
零个或多个隐式生存期类型\iref{term.implicit.lifetime.type} 对象的生存期，
如果这样做会导致程序具有已定义的行为。
如果没有这样的对象集会使程序具有已定义的行为，
则程序的行为是未定义的。
如果多个此类对象集会使程序具有已定义的行为，
则未指定创建哪个此类对象集。
\begin{note}
此类操作不会启动此类对象的子对象的生存期，
这些子对象本身不是隐式生存期类型。
\end{note}

\pnum
此外，在指定的存储区域内隐式创建对象后，
一些操作被描述为产生指向
\defnadj{合适的已创建}{对象} 的指针。
这些操作选择一个
其地址是存储区域开始地址的隐式创建对象，
并产生一个指向该对象的指针值，
如果该值会导致程序具有已定义的行为。
如果没有这样的指针值会使程序具有已定义的行为，
则程序的行为是未定义的。
如果多个此类指针值会使程序具有已定义的行为，
则未指定产生哪个此类指针值。

\pnum
\begin{example}
\begin{codeblock}
#include <cstdlib>
struct X { int a, b; };
X *make_x() {
  // The call to \tcode{std::malloc} implicitly creates an object of type \tcode{X}
  // and its subobjects \tcode{a} and \tcode{b}, and returns a pointer to that \tcode{X} object
  // (or an object that is pointer-interconvertible\iref{basic.compound} with it),
  // in order to give the subsequent class member access operations
  // defined behavior.
  X *p = (X*)std::malloc(sizeof(struct X));
  p->a = 1;
  p->b = 2;
  return p;
}
\end{codeblock}
\end{example}

\pnum
除非是在常量求值期间,
否则开始 \tcode{unsigned char} 或 \tcode{std::byte} 数组的生存期的操作
会在数组占用的存储区域内隐式创建对象。
\begin{note}
数组对象为这些对象提供存储。
\end{note}
除非是在常量求值期间,
否则任何名为 \tcode{\keyword{operator} \keyword{new}} 或 \tcode{\keyword{operator} \keyword{new}[]} 的函数的隐式或显式调用
都会在返回的存储区域中隐式创建对象，并
返回指向合适的已创建对象的指针。
\begin{note}
\Cpp{} 标准库中的一些函数会隐式创建对象%
\iref{obj.lifetime,c.malloc,mem.res.public,bit.cast,cstring.syn}。
\end{note}
\indextext{object model|)}

\rSec2[basic.align]{对齐}

\pnum
对象类型具有 \defnx{对齐要求}{alignment requirement!implementation-defined}\iref{basic.fundamental,basic.compound}，
它限制了可以分配该类型对象的地址。 \defn{对齐} 是一个 \impldef{alignment}
整数值，表示可以分配给定对象的连续地址之间的字节数。对象类型对该类型的每个对象施加对齐
要求；可以使用对齐说明符\iref{dcl.align} 请求更严格的对齐。
尝试在不满足对象类型对齐要求的存储中创建对象\iref{intro.object}
是未定义的行为。

\pnum
\defnadj{基本}{对齐} 由小于或等于
实现支持的所有上下文中的最大对齐的对齐表示，它等于
\tcode{\keyword{alignof}(std::max_align_t)}\iref{support.types}。
当类型用作完整对象的类型时以及当它用作子对象的类型时，
类型所需的对齐可能不同。
\begin{example}
\begin{codeblock}
struct B { long double d; };
struct D : virtual B { char c; };
\end{codeblock}

当 \tcode{D} 是完整对象的类型时，它将具有类型为 \tcode{B} 的子对象，因此必须适当地对齐
\tcode{\keyword{long} \keyword{double}}。
如果 \tcode{D} 作为也具有 \tcode{B}
作为虚基类的另一个对象的子对象出现，则 \tcode{B} 子对象可能是不同
子对象的一部分，从而降低了对 \tcode{D} 子对象的对齐要求。
\end{example}
\keyword{alignof} 运算符的结果反映了
完整对象情况下类型的对齐要求。

\pnum
\defnadj{扩展}{对齐} 由大于 \tcode{\keyword{alignof}(std::max_align_t)} 的对齐表示。 \impldef{support for extended alignments}
是否支持任何扩展对齐以及支持它们的上下文\iref{dcl.align}。具有扩展对齐
要求的类型是 \defnadj{超对齐}{类型}。
\begin{note}
每个超对齐类型都是或包含一个
应用扩展对齐的类类型（可能通过非静态数据成员）。
\end{note}
\defnadj{新扩展}{对齐} 由大于 \mname{STDCPP_DEFAULT_NEW_ALIGNMENT}\iref{cpp.predefined} 的对齐表示。

\pnum
对齐表示为 \tcode{std::size_t} 类型的值。
有效对齐仅包括基本类型加上一组额外的 \impldef{alignment additional
values}
值（可能为空）的 \keyword{alignof} 表达式返回的那些值。
每个对齐值都应为 2 的非负整数幂。

\pnum
对齐具有从 \defnx{较弱}{alignment!weaker} 到
\defnx{较强}{alignment!stronger} 或 \defnx{更严格}{alignment!stricter} 对齐的顺序。更严格的
对齐具有更大的对齐值。满足对齐
要求的地址也满足任何较弱的有效对齐要求。

\pnum
完整类型的对齐要求可以使用
\keyword{alignof} 表达式\iref{expr.alignof} 查询。此外，
窄字符类型\iref{basic.fundamental} 应具有最弱的
对齐要求。
\begin{note}
这使得普通字符类型可以用作
对齐内存区域\iref{dcl.align} 的基础类型。
\end{note}

\pnum
比较对齐是有意义的，并提供明显的结果：

\begin{itemize}
\item 当两个对齐的数值相等时，它们是相等的。
\item 当两个对齐的数值不相等时，它们是不同的。
\item 当一个对齐大于另一个时，它表示更严格的对齐。
\end{itemize}

\pnum
\begin{note}
运行时指针
对齐函数\iref{ptr.align}
可用于获取缓冲区内的对齐指针；
\grammarterm{alignment-specifier}\iref{dcl.align}
可用于显式对齐存储。
\end{note}

\pnum
如果实现不支持在特定上下文中请求特定的扩展对齐，则程序是病构的。

\rSec2[basic.life]{生存期}

\pnum
在本子条款中，“之前”和“之后”指的是“happens before”
关系\iref{intro.multithread}。

\pnum
\indextext{object lifetime|(}%
对象或引用的 \defn{生存期} 是对象
或引用的运行时属性。
如果变量是默认初始化的，没有执行其他初始化，并且
如果它是类类型或其（可能是多维的）数组，
则为默认初始化选择该类类型的平凡构造函数，
则称该变量具有 \defnadj{空}{初始化}。
类型为 \tcode{T} 的对象的生存期在以下情况下开始：
\begin{itemize}
\item 获得具有类型 \tcode{T} 的正确对齐和大小的
  存储，并且
\item 其初始化（如果有）完成
  （包括空初始化）\iref{dcl.init}，
\end{itemize}
但如果对象是联合成员或其子对象，
则仅当该联合成员是联合\iref{dcl.init.aggr,class.base.init} 中初始化的成员时，
或如
\ref{class.union}、\ref{class.copy.ctor} 和 \ref{class.copy.assign} 中所述，
以及如 \ref{allocator.members} 中所述，其生存期才开始。
类型为 \tcode{T} 的对象 \placeholder{o} 的生存期在以下情况下结束：
\begin{itemize}
\item 如果 \tcode{T} 是非类类型，则销毁对象，或
\item 如果 \tcode{T} 是类类型，则析构函数调用开始，或
\item 对象占用的存储被释放，
或被不嵌套在 \placeholder{o}\iref{intro.object} 中的对象重用。
\end{itemize}
当评估 \grammarterm{new-expression} 时，
认为存储在从分配函数返回后但在
评估 \grammarterm{new-initializer}\iref{expr.new} 之前被重用。
\begin{example}
\begin{codeblock}
struct S {
  int m;
};

void f() {
  S x{1};
  new(&x) S(x.m);   // undefined behavior
}
\end{codeblock}
\end{example}

\pnum
\indextext{reference lifetime}%
引用的生存期在其初始化完成时开始。
引用的生存期结束，就好像它是一个需要存储的标量对象。

\pnum
\begin{note}
\ref{class.base.init}
描述了基类和成员子对象的生存期。
\end{note}

\pnum
在本文档中赋予对象和引用的属性
仅适用于给定对象或引用在其生存期内。
\begin{note}
特别是，在对象生存期开始之前和
生存期结束之后，对对象的使用存在重大限制，
如下文、\ref{class.base.init} 和
\ref{class.cdtor} 中所述。此外，正在构造的对象
和正在销毁的对象的行为可能与
生存期已开始且未结束的对象的行为不同。\ref{class.base.init}
和 \ref{class.cdtor} 描述了对象在其构造和
销毁期间的行为。
\end{note}

\pnum
程序可以通过重用或释放存储来结束类类型对象的生存期，而无需调用
析构函数，如上所述。
\begin{note}
\grammarterm{delete-expression}\iref{expr.delete} 在
释放存储之前调用析构函数。
\end{note}
在这种情况下，不会隐式调用析构函数。
\begin{note}
程序的正确行为通常取决于
为每个类类型对象调用析构函数。
\end{note}

\pnum
在对象的生存期开始之前但对象将占用的存储
已分配之后
\begin{footnote}
例如，在具有静态存储期的对象的动态初始化之前\iref{basic.start.dynamic}。

\end{footnote}
或者，在对象的生存期结束后但在对象
占用的存储被重用或释放之前，任何表示
对象将要或曾经所在的存储位置的地址的指针都可以
使用，但只能以有限的方式使用。
对于正在构造或销毁的对象，请参见 \ref{class.cdtor}。
否则，此类
指针引用已分配的
存储\iref{basic.stc.dynamic.allocation}，并且像
指针的类型为 \tcode{\keyword{void}*} 一样使用指针是
良定义的。允许通过此类指针进行间接寻址，但生成的左值只能以
有限的方式使用，如下所述。
如果出现以下情况，则程序具有未定义行为
\begin{itemize}
\item
  指针用作 \grammarterm{delete-expression} 的操作数，
\item
  指针用于访问非静态数据成员或调用
  对象的非静态成员函数，或
\item
  指针隐式转换\iref{conv.ptr} 为指向
  虚基类的指针，或
\item
  指针用作
  \keyword{static_cast}\iref{expr.static.cast} 的操作数，除非转换
  为指向 \cv{} \keyword{void} 的指针，或指向 \cv{} \keyword{void} 的指针
  并随后转换为指向
  \cv{} \keyword{char}、
  \cv{} \tcode{\keyword{unsigned} \keyword{char}} 或
  \cv{} \tcode{std::byte}\iref{cstddef.syn} 的指针，或
\item
  指针用作
  \keyword{dynamic_cast}\iref{expr.dynamic.cast} 的操作数。
\end{itemize}
\begin{example}
\begin{codeblock}
#include <cstdlib>

struct B {
  virtual void f();
  void mutate();
  virtual ~B();
};

struct D1 : B { void f(); };
struct D2 : B { void f(); };

void B::mutate() {
  new (this) D2;    // reuses storage --- ends the lifetime of \tcode{*this}
  f();              // undefined behavior
  ... = this;       // OK, \keyword{this} points to valid memory
}

void g() {
  void* p = std::malloc(sizeof(D1) + sizeof(D2));
  B* pb = new (p) D1;
  pb->mutate();
  *pb;              // OK, \tcode{pb} points to valid memory
  void* q = pb;     // OK, \tcode{pb} points to valid memory
  pb->f();          // undefined behavior: lifetime of \tcode{*pb} has ended
}
\end{codeblock}
\end{example}

\pnum
类似地，在对象的生存期开始之前但对象将
占用的存储已分配之后，或者在
对象的生存期结束后但在对象
占用的存储被重用或释放之前，任何引用原始
对象的泛左值都可以使用，但只能以有限的方式使用。
对于正在构造或销毁的对象，请参见 \ref{class.cdtor}。
否则，此类
泛左值引用
已分配的存储\iref{basic.stc.dynamic.allocation}，并且使用
不依赖于其值的泛左值的属性是
良定义的。如果出现以下情况，则程序具有未定义行为
\begin{itemize}
\item 泛左值用于访问对象，或
\item 泛左值用于调用对象的非静态成员函数，或
\item 泛左值绑定到对虚基类的引用\iref{dcl.init.ref}，或
\item 泛左值用作
\keyword{dynamic_cast}\iref{expr.dynamic.cast} 的操作数或 \keyword{typeid} 的操作数。
\end{itemize}

\begin{note}
因此，如果
一个线程中正在构造的对象被另一个
线程引用而没有足够的同步，则会导致未定义行为。
\end{note}

\pnum
如果满足以下条件，则对象 $o_1$ 可被对象 $o_2$ \defn{透明替换}
\begin{itemize}
\item $o_2$ 占用的存储完全覆盖
$o_1$ 占用的存储，并且

\item $o_1$ 和 $o_2$ 的类型相同
（忽略顶级 cv 限定符），并且

\item $o_1$ 不是 const 的完整对象，并且

\item $o_1$ 和 $o_2$ 都不是
潜在重叠子对象\iref{intro.object}，并且

\item $o_1$ 和 $o_2$ 都是完整对象，或
$o_1$ 和 $o_2$ 分别是对象 $p_1$ 和 $p_2$ 的直接子对象，
并且 $p_1$ 可被 $p_2$ 透明替换。
\end{itemize}

\pnum
在对象的生存期结束后以及对象占用的存储被重用或释放之前，如果在新对象占用的存储位置创建了新对象,
并且原始对象可以被新对象透明替换，则指向原始
对象的指针、引用原始对象的引用或
原始对象的名称将自动引用新对象，并且一旦
新对象的生存期开始，就可以用于操作新
对象。

\begin{example}
\begin{codeblock}
struct C {
  int i;
  void f();
  const C& operator=( const C& );
};

const C& C::operator=( const C& other) {
  if ( this != &other ) {
    this->~C();                 // lifetime of \tcode{*this} ends
    new (this) C(other);        // new object of type \tcode{C} created
    f();                        // well-defined
  }
  return *this;
}

C c1;
C c2;
c1 = c2;                        // well-defined
c1.f();                         // well-defined; \tcode{c1} refers to a new object of type \tcode{C}
\end{codeblock}
\end{example}
\begin{note}
如果不满足这些条件，
则可以通过调用 \tcode{std::launder}\iref{ptr.launder} 从
表示其存储地址的指针获取指向新对象的指针。
\end{note}

\pnum
如果程序结束了具有
static\iref{basic.stc.static}、thread\iref{basic.stc.thread}
或 automatic\iref{basic.stc.auto}
存储期的类型为 \tcode{T} 的对象的生存期，并且如果 \tcode{T} 具有非平凡析构函数，
\begin{footnote}
那是，
为其将隐式调用析构函数的对象---退出
具有自动存储期的对象的块时，退出
具有线程存储期的对象的线程时，或退出
具有静态存储期的对象的程序时。
\end{footnote}
并且当隐式析构函数调用发生时，另一个原始类型的对象没有占用
相同的存储位置，则程序的行为是未定义的。即使
块以异常退出也是如此。
\begin{example}
\begin{codeblock}
class T { };
struct B {
  ~B();
};

void h() {
  B b;
  new (&b) T;
}                               // undefined behavior at block exit
\end{codeblock}
\end{example}

\pnum
在具有静态、线程或自动存储期的 const 完整对象
占用的存储中，
或在此类 const 对象
生存期结束前曾经占用的存储中创建新对象
会导致未定义行为。
\begin{example}
\begin{codeblock}
struct B {
  B();
  ~B();
};

const B b;

void h() {
  b.~B();
  new (const_cast<B*>(&b)) const B;     // undefined behavior
}
\end{codeblock}
\end{example}
\indextext{object lifetime|)}

\rSec2[basic.indet]{不确定值和错误值}

\pnum
当为具有自动或动态存储期的对象获取存储时，
构成对象存储的字节
具有以下初始值：
\begin{itemize}
\item
如果对象具有动态存储期，或
是其第一个声明标有
\tcode{[[indeterminate]]} 属性\iref{dcl.attr.indet} 的变量或函数形参，
则字节具有 \defnadjx{不确定}{值}{value}；
\item
否则，字节具有 \defnadjx{错误}{值}{value}，
其中每个值由实现独立于程序状态确定。
\end{itemize}
如果未对对象（包括子对象）执行初始化，
则此类字节将保留其初始值，
直到该值被替换\iref{dcl.init.general,expr.ass}。
如果值表示中的任何位具有不确定值，
则对象具有不确定值；
否则，如果值表示中的任何位具有错误值，
则对象具有错误值\iref{conv.lval}。
\begin{note}
具有静态或线程存储期的对象是零初始化的，
参见 \ref{basic.start.static}。
\end{note}

\pnum
除了以下情况外，
如果通过求值产生不确定值，
则行为是未定义的，并且
如果通过求值产生错误值，
则行为是错误的，
并且求值的结果是如此产生的值，但不是错误的：
\begin{itemize}
\item
  如果
  无符号普通字符类型\iref{basic.fundamental}
  或 \tcode{std::byte} 类型\iref{cstddef.syn}
  的不确定或错误值
  由以下各项的求值产生：
  \begin{itemize}
  \item
    条件表达式\iref{expr.cond} 的第二个或第三个操作数，
  \item
    逗号表达式\iref{expr.comma} 的右操作数，
  \item
    转换为无符号普通字符类型
    或 \tcode{std::byte} 类型\iref{cstddef.syn} 的强制转换或转换\iref{conv.integral,
    expr.type.conv,expr.static.cast,expr.cast}
    的操作数，或
  \item
    弃值表达式\iref{expr.context}，
  \end{itemize}
  则运算的结果分别是不确定值或
  该错误值。
\item
  如果
  无符号普通字符类型或 \tcode{std::byte} 类型
  的不确定或错误值
  由第一个操作数是
  无符号普通字符类型或 \tcode{std::byte} 类型的左值的简单赋值运算符\iref{expr.ass}
  的右操作数的求值产生，
  则不确定值或该错误值分别替换
  左操作数引用的对象的值。
\item
  如果无符号普通字符类型的不确定或错误值
  由初始化无符号普通字符类型对象时
  初始化表达式的求值产生，
  则该对象分别初始化为不确定
  值或该错误值。
\item
  如果
  无符号普通字符类型或 \tcode{std::byte} 类型的不确定值
  由初始化 \tcode{std::byte} 类型对象时
  初始化表达式的求值产生，
  则该对象分别初始化为不确定值或
  该错误值。
\end{itemize}
转换无符号普通字符类型或 \tcode{std::byte} 类型
的不确定或错误值分别产生
不确定或错误值。
在后一种情况下，
转换的结果是转换后操作数的值。
\begin{example}
\begin{codeblock}
int f(bool b) {
  unsigned char *c = new unsigned char;
  unsigned char d = *c;         // OK, \tcode{d} has an indeterminate value
  int e = d;                    // undefined behavior
  return b ? d : 0;             // undefined behavior if \tcode{b} is \tcode{true}
}

int g(bool b) {
  unsigned char c;
  unsigned char d = c;          // no erroneous behavior, but \tcode{d} has an erroneous value

  assert(c == d);               // holds, both integral promotions have erroneous behavior

  int e = d;                    // erroneous behavior
  return b ? d : 0;             // erroneous behavior if \tcode{b} is \tcode{true}
}

void h() {
  int d1, d2;

  int e1 = d1;                  // erroneous behavior
  int e2 = d1;                  // erroneous behavior

  assert(e1 == e2);             // holds
  assert(e1 == d1);             // holds, erroneous behavior
  assert(e2 == d1);             // holds, erroneous behavior

  std::memcpy(&d2, &d1, sizeof(int));   // no erroneous behavior, but \tcode{d2} has an erroneous value
  assert(e1 == d2);             // holds, erroneous behavior
  assert(e2 == d2);             // holds, erroneous behavior
}
\end{codeblock}
\end{example}

\rSec2[basic.stc]{存储期}

\rSec3[basic.stc.general]{概述}

\pnum
\indextext{storage duration|(}%
\defn{存储期} 是定义
包含对象的存储的最小潜在生存期的对象属性。存储期
由用于创建对象的构造确定，并且是
以下之一：
\begin{itemize}
\item 静态存储期
\item 线程存储期
\item 自动存储期
\item 动态存储期
\end{itemize}
\begin{note}
在存储区域的持续时间结束后，
对指向该存储区域的指针的使用受到限制\iref{basic.compound}。
\end{note}

\pnum
\indextext{storage duration!static}%
\indextext{storage duration!thread}%
\indextext{storage duration!automatic}%
\indextext{storage duration!dynamic}%
静态、线程和自动存储期与
由声明引入的对象\iref{basic.def} 和
临时对象\iref{class.temporary} 相关联。
动态存储期
与由
\grammarterm{new-expression}\iref{expr.new} 创建的对象或
隐式创建的对象\iref{intro.object} 相关联。

\pnum
存储期类别也适用于引用。

\pnum
\indextext{storage duration!class member}%
子对象和引用成员的存储期
是其完整对象\iref{intro.object} 的存储期。
\indextext{storage duration|)}%

\rSec3[basic.stc.static]{静态存储期}

\pnum
所有变量，
\begin{itemize}
\item
不具有线程存储期并且
\item
属于命名空间作用域\iref{basic.scope.namespace} 或
首先使用 \keyword{static} 或 \keyword{extern} 关键字\iref{dcl.stc} 声明
\end{itemize}
具有 \defnadj{静态}{存储期}。
这些实体的存储持续程序的持续时间\iref{basic.start.static,basic.start.term}。

\pnum
如果具有静态存储期的变量具有初始化或具有副作用的
析构函数，则即使它看起来未使用，也不应将其消除，除非类对象或其复制/移动可以
如 \ref{class.copy.elision} 中所述被消除。

\pnum
\begin{note}
\indextext{object!local static@local \tcode{static}}%
关键字 \keyword{static} 可用于声明
具有静态存储期的块变量\iref{basic.scope.block}；
\ref{stmt.dcl} 和 \ref{basic.start.term} 描述了
此类变量的初始化和销毁。
\indextext{member!class static@class \tcode{static}}%
应用于类定义中的类数据成员的关键字 \keyword{static}
为数据成员提供静态存储期\iref{class.static.data}。
\end{note}

\rSec3[basic.stc.thread]{线程存储期}

\pnum
所有使用 \keyword{thread_local} 关键字声明的变量都具有
\defnadj{线程}{存储期}。
这些实体的存储持续
创建它们的线程的持续时间。每个线程都有一个不同的对象或引用，
并且使用声明的名称引用与
当前线程关联的实体。

\pnum
\begin{note}
具有线程存储期的变量如
\ref{basic.start.static}、\ref{basic.start.dynamic} 和 \ref{stmt.dcl} 中所述进行初始化，并且
如果已构造，则在线程退出\iref{basic.start.term} 时销毁。
\end{note}

\rSec3[basic.stc.auto]{自动存储期}

\pnum
\indextext{storage duration!local object}%
属于块作用域且
未显式声明为 \keyword{static}、\keyword{thread_local} 或 \keyword{extern} 的变量具有
\defnadj{自动}{存储期}。
此类变量的存储持续到创建它们的块退出。
\begin{note}
这些变量如 \ref{stmt.dcl} 中所述进行初始化和销毁。
\end{note}
属于形参作用域的变量也具有自动存储期。
函数形参的存储持续到
其析构\iref{expr.call} 之后立即。

\pnum
如果具有自动存储期的变量具有初始化或具有副作用的析构函数，
则实现不应在块结束之前销毁它，
也不应将其作为优化消除，即使它看起来
未使用，除非类对象或其复制/移动可以
如 \ref{class.copy.elision} 中所述被消除。

\rSec3[basic.stc.dynamic]{动态存储期}%

\rSec4[basic.stc.dynamic.general]{概述}%
\indextext{storage duration!dynamic|(}

\pnum
可以使用
\indextext{\idxcode{new}}%
\grammarterm{new-expression}{s}\iref{expr.new} 在程序执行期间动态创建对象\iref{intro.execution}，并使用
\indextext{\idxcode{delete}}%
\grammarterm{delete-expression}{s}\iref{expr.delete} 销毁对象。\Cpp{} 实现
通过
全局 \defnx{分配函数}{allocation function}
\tcode{\keyword{operator} \keyword{new}} 和
\tcode{\keyword{operator} \keyword{new}[]} 以及
全局 \defnx{释放函数}{deallocation function}
\tcode{\keyword{operator} \keyword{delete}} 和
\tcode{\keyword{operator} \keyword{delete}[]} 提供对动态存储的访问和管理。
\begin{note}
\ref{new.delete.placement} 中描述的非分配形式
不执行分配或释放。
\end{note}

\pnum
库为全局分配和
释放函数提供默认定义。一些全局分配和释放
函数是可替换的\iref{new.delete}；
这些附加到全局模块\iref{module.unit}。
\Cpp{} 程序应
最多提供一个可替换分配或
释放函数的定义。任何此类函数定义都将替换
库中提供的默认版本\iref{replacement.functions}。
以下分配和释放函数\iref{support.dynamic}
在程序的每个翻译单元的全局作用域中隐式声明。

\begin{codeblock}
void* operator new(std::size_t);
void* operator new(std::size_t, std::align_val_t);

void operator delete(void*) noexcept;
void operator delete(void*, std::size_t) noexcept;
void operator delete(void*, std::align_val_t) noexcept;
void operator delete(void*, std::size_t, std::align_val_t) noexcept;

void* operator new[](std::size_t);
void* operator new[](std::size_t, std::align_val_t);

void operator delete[](void*) noexcept;
void operator delete[](void*, std::size_t) noexcept;
void operator delete[](void*, std::align_val_t) noexcept;
void operator delete[](void*, std::size_t, std::align_val_t) noexcept;
\end{codeblock}

这些隐式声明仅引入函数名称
\tcode{\keyword{operator} \keyword{new}}、
\tcode{\keyword{operator} \keyword{new}[]}、
\tcode{\keyword{operator} \keyword{delete}} 和
\tcode{\keyword{operator} \keyword{delete}[]}。
\begin{note}
隐式声明不引入
名称 \tcode{std}、
\tcode{std::size_t}、
\tcode{std::align_val_t}
或库用于
声明这些名称的任何其他名称。因此，\grammarterm{new-expression}、
\grammarterm{delete-expression} 或引用这些函数之一的函数调用
在没有导入或包含头文件 \libheaderref{new}
或导入 \Cpp{} 库模块\iref{std.modules} 的情况下
是良定义的。但是，引用 \tcode{std}
或 \tcode{std::size_t}
或 \tcode{std::align_val_t}
是病构的，除非
该名称的标准库声明\iref{cstddef.syn,new.syn,std.modules}
先于\iref{basic.lookup.general} 该名称的使用。
\end{note}
也可以为任何
类\iref{class.free} 声明和定义分配和/或
释放函数。

\pnum
如果分配或释放函数的行为
不满足 \ref{basic.stc.dynamic.allocation}
和 \ref{basic.stc.dynamic.deallocation} 中指定的语义约束，
则行为是未定义的。

\indextext{storage duration!dynamic|)}

\pnum
\indextext{function!allocation}%
不是类成员函数的分配函数
应属于全局作用域，并且不具有内部链接的名称。
返回类型应为 \tcode{\keyword{void}*}。第一个
形参应具有类型 \tcode{std::size_t}\iref{support.types}。
第一个形参不应具有关联的默认
实参\iref{dcl.fct.default}。第一个形参的值
被解释为请求的分配大小。分配
函数可以是函数模板。此类模板应声明其
返回类型和第一个形参如上所述（即，模板
形参类型不应用于返回类型和第一个形参
类型）。分配函数模板应具有两个或多个形参。

\pnum
分配函数尝试分配请求数量的
存储。如果成功，它将返回起始地址
一个长度至少与
请求大小一样大的字节块的存储。
顺序，
连续性，以及通过连续调用分配的存储的初始值
分配函数是未指定的。
即使空间的大小
请求为零，请求也可能失败。如果请求成功，则
可替换分配函数返回的值
是与任何先前返回的值 \tcode{p1} 不同的非空指针值\iref{basic.compound}
\tcode{p0}，
除非该值 \tcode{p1} 随后被传递给
可替换的释放函数。
此外，对于库分配函数
在 \ref{new.delete.single} 和 \ref{new.delete.array} 中，
\tcode{p0} 表示与
调用者可访问的任何其他对象的存储不相交的存储块的地址。
通过从请求零大小返回的指针
进行间接寻址的效果是未定义的。
\begin{footnote}
意图
是让 \tcode{\keyword{operator} \keyword{new}()} 可以通过
调用 \tcode{std::malloc()} 或 \tcode{std::calloc()} 来实现，因此规则
基本相同。\Cpp{} 与 C 的不同之处在于要求零请求
返回一个非空指针。
\end{footnote}

\pnum
对于
保留的布局分配函数\iref{new.delete.placement} 之外的分配函数，
成功调用时返回的指针
应表示按以下方式对齐的存储的地址：
\begin{itemize}
\item
  如果分配函数采用
  类型为 \tcode{std::align_val_t} 的实参，
  则存储将具有此实参的值指定的对齐方式。
\item
  否则，如果分配函数名为 \tcode{\keyword{operator} \keyword{new}[]}，
  则存储对于任何对象对齐
  不具有新扩展对齐\iref{basic.align} 并且
  不大于请求的大小。
\item
  否则，存储将针对任何对象对齐
  不具有新扩展对齐并且具有请求的大小。
\end{itemize}

\pnum
无法分配存储的分配函数可以调用
当前安装的 new-handler 函数\iref{new.handler}（如果有）。
\begin{note}
\indextext{\idxcode{new_handler}}%
程序提供的分配函数可以使用
\tcode{std::get_new_handler} 函数\iref{get.new.handler} 获取
当前安装的 \tcode{new_handler}。
\end{note}
具有非抛出
异常规范\iref{except.spec} 的分配函数
通过返回
空指针值来指示失败。
任何其他分配函数
永远不会返回空指针值，并且
仅通过抛出\iref{except.throw}
会与类型为
\tcode{std::bad_alloc}\iref{bad.alloc} 的处理程序\iref{except.handle} 匹配的异常类型来指示失败。

\pnum
全局分配函数仅作为 new
表达式\iref{expr.new} 的结果调用，或使用函数调用
语法\iref{expr.call} 直接调用，或间接调用以为
协程状态\iref{dcl.fct.def.coroutine} 分配存储，
或通过调用
\Cpp{} 标准库中的函数间接调用。
\begin{note}
特别是，
全局分配函数不会被调用来为具有静态存储期\iref{basic.stc.static} 的对象分配存储，
对于具有线程存储期\iref{basic.stc.thread} 的对象或引用，对于
类型为 \tcode{std::type_info}\iref{expr.typeid} 的对象，或对于
异常对象\iref{except.throw}。
\end{note}

\rSec4[basic.stc.dynamic.deallocation]{释放函数}

\pnum
\indextext{function!deallocation}%
不是类成员函数的释放函数
应属于全局作用域，并且不具有内部链接的名称。

\pnum
如果释放函数
至少有两个形参
并且其第二个形参
的类型为 \tcode{std::destroying_delete_t}，则它是 \defnadj{销毁}{operator delete}。
销毁 operator delete
应是名为 \tcode{\keyword{operator} \keyword{delete}} 的类成员函数。
\begin{note}
数组删除不能使用销毁 operator delete。
\end{note}

\pnum
\indextext{\idxcode{delete}!overloading and}%
每个释放函数都应返回 \keyword{void}。
如果函数是
在类类型 \tcode{C} 中声明的销毁 operator delete，
则其第一个形参的类型应为 \tcode{C*}；
否则，其第一个
形参的类型应为 \tcode{\keyword{void}*}。释放函数可能有多个
形参。
\indextext{deallocation function!usual}%
\defn{常用释放函数} 是一个释放函数，
其第一个之后的形参是
\begin{itemize}
\item
可选地，类型为 \tcode{std::destroying_delete_t} 的形参，然后
\item
可选地，类型为 \tcode{std::size_t} 的形参，
\begin{footnote}
全局 \tcode{\keyword{operator} \keyword{delete}(\keyword{void}*, std::size_t)}
排除了将分配函数 \tcode{\keyword{void} \keyword{operator} \keyword{new}(std::size_t, std::size_t)} 用作
布局分配函数\iref{diff.cpp11.basic}。
\end{footnote}
然后
\item
可选地，类型为 \tcode{std::align_val_t} 的形参。
\end{itemize}
销毁 operator delete 应是常用释放函数。
释放函数可以是函数
模板的实例。第一个形参和返回类型都不应依赖于
模板形参。去分配
函数模板应具有两个或多个函数形参。模板
实例永远不是常用的释放函数，无论其
签名如何。

\pnum
如果释放函数因抛出异常而终止，则行为未定义。
提供给释放函数的第一个实参的值可能
是空指针值；如果是这样，并且如果释放函数是
标准库中提供的，则调用不起作用。

\pnum
如果提供给标准库中的释放函数的实参
是不是空指针值\iref{basic.compound} 的指针，则
释放函数应释放指针引用的存储，
结束存储区域的持续时间。

\rSec2[class.temporary]{临时对象}

\pnum
\indextext{object temporary|see{temporary}}%
\indextext{temporary}%
\indextext{optimization of temporary|see{temporary, elimination of}}%
\indextext{temporary!elimination of}%
\indextext{temporary!implementation-defined generation of}%
临时对象是在以下情况下创建的
\begin{itemize}
\item
当纯右值转换为泛左值\iref{conv.rval} 时，以及
\item
当实现需要传递或返回可平凡复制类型的对象时（见下文）。
\end{itemize}
即使临时对象的创建是
未求值的\iref{expr.context}，
所有语义限制都应得到遵守，就好像临时对象
已被创建然后销毁一样。
\begin{note}
这包括可访问性\iref{class.access} 以及它是否被删除，
对于选择的构造函数和析构函数。但是，在
\grammarterm{decltype-specifier}\iref{dcl.type.decltype} 的操作数的特殊情况下，不会引入临时对象，
因此上述内容不适用于此类纯右值。
\end{note}

\pnum
临时对象的实质化通常
会尽可能延迟，
以避免创建不必要的临时对象。
\begin{note}
临时对象被实质化：
\begin{itemize}
\item
当将引用绑定到纯右值\iref{dcl.init.ref,expr.type.conv,
expr.dynamic.cast,expr.static.cast,expr.const.cast,expr.cast} 时，
\item
当对类纯右值执行某些成员访问\iref{expr.ref,expr.mptr.oper} 时，
\item
当在类纯右值上调用隐式对象成员函数\iref{expr.call} 时，
\item
当对数组纯右值执行数组到指针转换或下标\iref{conv.array,expr.sub} 时，
\item
当从 \grammarterm{braced-init-list}\iref{dcl.init.list} 初始化类型为 \tcode{std::initializer_list<T>} 的对象时，
\item
对于某些未求值的操作数\iref{expr.typeid,expr.sizeof}，以及
\item
当类型不是 \cv{} \keyword{void} 的纯右值作为弃值表达式\iref{expr.context} 出现时。
\end{itemize}
\end{note}
\begin{example}
考虑以下代码：
\begin{codeblock}
class X {
public:
  X(int);
  X(const X&);
  X& operator=(const X&);
  ~X();
};

class Y {
public:
  Y(int);
  Y(Y&&);
  ~Y();
};

X f(X);
Y g(Y);

void h() {
  X a(1);
  X b = f(X(2));
  Y c = g(Y(3));
  a = f(a);
}
\end{codeblock}

\indextext{class object copy|see{constructor, copy}}%
\indextext{constructor!copy}%
\tcode{X(2)} 在用于保存 \tcode{f()} 的实参的空间中构造，
\tcode{Y(3)} 在用于保存 \tcode{g()} 的实参的空间中构造。
同样，
\tcode{f()} 的结果直接在 \tcode{b} 中构造，
\tcode{g()} 的结果直接在 \tcode{c} 中构造。
另一方面，表达式
\tcode{a = f(a)}
需要一个临时对象来保存
\tcode{f(a)} 的结果，
它被实质化以便 \tcode{X::operator=(const X\&)} 的引用形参
可以绑定到它。
\end{example}

\pnum
当类类型 \tcode{X} 的对象
传递给或从潜在求值的函数调用返回时，
如果 \tcode{X} 至少有一个合格的复制或移动构造函数\iref{special}，
每个此类构造函数都是平凡的，
并且 \tcode{X} 的析构函数是平凡的或已删除的，
则允许实现
创建一个临时对象
来保存函数形参或结果对象。
临时对象
分别从函数实参或返回值构造，
并且函数的形参或返回对象
被初始化，就好像
使用合格的平凡构造函数来复制临时对象
（即使该构造函数不可访问
或不会被重载解析选择
来执行对象的复制或移动）。
\begin{note}
允许这样做是为了允许类类型的对象在寄存器中传递给函数或从函数返回。
\end{note}

\pnum
\indextext{temporary!constructor for}%
\indextext{temporary!destructor for}%
\indextext{temporary!destruction of}%
临时对象作为评估
（词法上）包含
创建它们的点的完整表达式\iref{intro.execution} 的最后一步被销毁。
即使该评估以抛出异常结束也是如此。
\indextext{value computation}%
销毁临时对象的值计算和
\indextext{side effects}%
副作用仅与完整表达式相关联，而不与任何特定的
子表达式相关联。

\pnum
\indextext{initializer!temporary and declarator}%
\indextext{temporary!order of destruction of}%
临时对象在与完整表达式结束不同的
点被销毁的上下文有五种。
第一种情况是在调用默认构造函数来初始化
没有相应初始化器\iref{dcl.init} 的数组元素时。
第二种情况是在复制数组元素时调用复制构造函数，
而整个数组被复制\iref{expr.prim.lambda.capture,class.copy.ctor}。
在任一情况下，如果构造函数有一个或多个默认实参，
则在默认实参中创建的每个临时对象的销毁都
在下一个数组元素的构造之前排序（如果有）。

\pnum
第三种情况是引用绑定到临时对象时。
\begin{footnote}
相同的规则适用于使用其
基础临时数组初始化
  \tcode{initializer_list} 对象\iref{dcl.init.list}。
\end{footnote}
如果通过以下之一获得引用绑定到的泛左值，则引用绑定到的临时对象或作为引用绑定到的子对象的完整对象的临时对象
将持续引用的生存期：
\begin{itemize}
\item
  临时实质化转换\iref{conv.rval}，
\item
  \tcode{(} \grammarterm{expression} \tcode{)},
  其中 \grammarterm{expression} 是这些表达式之一，
\item
  数组操作数的下标\iref{expr.sub}，
  其中该操作数是这些表达式之一，
\item
  使用 \tcode{.} 运算符的类成员访问\iref{expr.ref}
  其中左操作数是这些表达式之一，并且
  右操作数指定非引用类型的非静态数据成员，
\item
  使用 \tcode{.*} 运算符的成员指针操作\iref{expr.mptr.oper}
  其中左操作数是这些表达式之一，并且
  右操作数是指向非引用类型的数据成员的指针，
\item
  \begin{itemize}
  \item \keyword{const_cast}\iref{expr.const.cast}，
  \item \keyword{static_cast}\iref{expr.static.cast}，
  \item \keyword{dynamic_cast}\iref{expr.dynamic.cast}，或
  \item \keyword{reinterpret_cast}\iref{expr.reinterpret.cast}
  \end{itemize}
  在没有用户定义的转换的情况下，转换
  作为这些表达式之一的泛左值操作数
  为引用
  由操作数指定的对象的泛左值，或
  到其完整对象或其子对象，
\item
  作为泛左值的条件表达式\iref{expr.cond}
  其中第二个或第三个操作数是这些表达式之一，或
\item
  作为泛左值的逗号表达式\iref{expr.comma}
  其中右操作数是这些表达式之一。
\end{itemize}
\begin{example}
\begin{codeblock}
template<typename T> using id = T;

int i = 1;
int&& a = id<int[3]>{1, 2, 3}[i];           // temporary array has same lifetime as \tcode{a}
const int& b = static_cast<const int&>(0);  // temporary \tcode{int} has same lifetime as \tcode{b}
int&& c = cond ? id<int[3]>{1, 2, 3}[i] : static_cast<int&&>(0);
                                            // exactly one of the two temporaries is lifetime-extended
\end{codeblock}
\end{example}
\begin{note}
显式类型转换\iref{expr.type.conv,expr.cast}
被解释为
基本强制转换的序列，
如上所述。
\begin{example}
\begin{codeblock}
const int& x = (const int&)1;   // temporary for value 1 has same lifetime as x
\end{codeblock}
\end{example}
\end{note}
\begin{note}
如果临时对象具有由另一个临时对象初始化的引用成员，
则生存期扩展递归地应用于此类成员的初始化器。
\begin{example}
\begin{codeblock}
struct S {
  const int& m;
};
const S& s = S{1};              // both \tcode{S} and \tcode{int} temporaries have lifetime of \tcode{s}
\end{codeblock}
\end{example}
\end{note}

此生存期规则的例外情况是：
\begin{itemize}
\item 函数调用\iref{expr.call} 中绑定到引用形参的临时对象
持续到包含调用的完整表达式完成。

\item 绑定到从
带括号的 \grammarterm{expression-list}\iref{dcl.init} 初始化的类类型的聚合的引用元素的临时对象
持续到包含 \grammarterm{expression-list} 的完整表达式
完成。

\item \grammarterm{new-initializer}\iref{expr.new} 中绑定到引用的临时对象持续到包含 \grammarterm{new-initializer} 的完整表达式完成。
\begin{note}
这可能会引入悬空引用。
\end{note}
\begin{example}
\begin{codeblock}
struct S { int mi; const std::pair<int,int>& mp; };
S a { 1, {2,3} };
S* p = new S{ 1, {2,3} };       // creates dangling reference
\end{codeblock}
\end{example}
\end{itemize}

\pnum
临时对象的第四种情况是在基于范围的 \keyword{for} 语句的 \grammarterm{for-range-initializer} 中
创建临时对象时。
如果这样的临时对象原本会在
\grammarterm{for-range-initializer} 完整表达式的末尾被销毁，
则该对象的生存期将持续到由 \grammarterm{for-range-initializer} 初始化的引用的生存期。

\pnum
第五种情况是在结构化绑定声明\iref{dcl.struct.bind} 中创建临时对象时。
由具有唯一名称的变量
的 \grammarterm{initializer} 引入的任何临时对象
将在结构化绑定声明结束时销毁。

\pnum
设 \tcode{x} 和 \tcode{y} 分别是
生存期未延长的临时对象，或
函数形参。
如果 \tcode{x} 和 \tcode{y} 的生存期在
同一个完整表达式的末尾结束，并且
\tcode{x} 在 \tcode{y} 之前初始化，则
\tcode{y} 的销毁在 \tcode{x} 的销毁之前排序。
如果两个或多个临时对象
的生存期延长到创建它们的完整表达式之外，
并且在同一点结束，
则这些临时对象在该点以
其构造完成的相反顺序销毁。
此外，此类临时对象的销毁应
考虑具有静态、线程或
自动存储期\iref{basic.stc.static,basic.stc.thread,basic.stc.auto} 的对象的销毁顺序；
也就是说，如果
\tcode{obj1}
是与临时对象具有相同存储期的对象，并且
在创建临时对象之前创建，
则临时对象应在
\tcode{obj1}
被销毁之前销毁；
如果
\tcode{obj2}
是与临时对象具有相同存储期的对象，并且
在创建临时对象之后创建，
则临时对象应在
\tcode{obj2}
被销毁之后销毁。

\pnum
\begin{example}
\begin{codeblock}
struct S {
  S();
  S(int);
  friend S operator+(const S&, const S&);
  ~S();
};
S obj1;
const S& cr = S(16)+S(23);
S obj2;
\end{codeblock}

表达式
\tcode{S(16) + S(23)}
创建三个临时对象：
第一个临时对象
\tcode{T1}
保存表达式
\tcode{S(16)} 的结果，
第二个临时对象
\tcode{T2}
保存表达式
\tcode{S(23)} 的结果，
以及第三个临时对象
\tcode{T3}
保存这两个表达式相加的结果。
然后将临时对象
\tcode{T3}
绑定到引用
\tcode{cr}。
未指定是
\tcode{T1}
还是
\tcode{T2}
先创建。
在 \tcode{T1}
在 \tcode{T2} 之前创建的实现上，
\tcode{T2}
应在 \tcode{T1} 之前销毁。
临时对象
\tcode{T1}
和
\tcode{T2}
绑定到
\tcode{\keyword{operator}+} 的引用形参；
这些临时对象在包含对
\tcode{\keyword{operator}+} 的调用的完整表达式
结束时销毁。
绑定到引用
\tcode{cr}
的临时对象
\tcode{T3}
在 \tcode{cr} 的
生存期结束时（即在程序结束时）销毁。
此外，\tcode{T3}
被销毁的顺序考虑了具有
静态存储期的其他对象的销毁顺序。
也就是说，因为
\tcode{obj1}
在 \tcode{T3} 之前构造，
并且
\tcode{T3}
在 \tcode{obj2} 之前构造，
所以 \tcode{obj2}
应在 \tcode{T3} 之前销毁，
并且 \tcode{T3}
应在 \tcode{obj1} 之前销毁。
\end{example}

\rSec1[basic.types]{类型}%

\rSec2[basic.types.general]{概述}%
\indextext{type|(}

\pnum
\begin{note}
\ref{basic.types} 及其子条款
对实现施加了关于类型表示的要求。
有两种类型：基本类型和复合类型。
类型描述对象\iref{intro.object}、
引用\iref{dcl.ref}
或函数\iref{dcl.fct}。
\end{note}

\pnum
\indextext{object!byte copying and|(}%
\indextext{type!trivially copyable}%
对于任何可平凡复制类型 \tcode{T} 的对象（潜在重叠子对象除外），
无论该对象是否持有类型 \tcode{T} 的有效值，构成
对象的底层字节\iref{intro.memory} 都可以复制到
\keyword{char}、
\tcode{\keyword{unsigned} \keyword{char}} 或
\tcode{std::byte}\iref{cstddef.syn} 的数组中。
\begin{footnote}
例如，通过使用库
函数\iref{headers} \tcode{std::memcpy} 或 \tcode{std::memmove}。
\end{footnote}
如果该数组的内容
复制回对象，则对象应
随后持有其原始值。
\begin{example}
\begin{codeblock}
constexpr std::size_t N = sizeof(T);
char buf[N];
T obj;                          // \tcode{obj} initialized to its original value
std::memcpy(buf, &obj, N);      // between these two calls to \tcode{std::memcpy}, \tcode{obj} might be modified
std::memcpy(&obj, buf, N);      // at this point, each subobject of \tcode{obj} of scalar type holds its original value
\end{codeblock}
\end{example}

\pnum
对于可平凡复制类型 \tcode{T} 的两个不同对象 \tcode{obj1} 和 \tcode{obj2}，
其中 \tcode{obj1} 和 \tcode{obj2} 都不是潜在重叠子对象，
如果构成
\tcode{obj1} 的底层字节\iref{intro.memory} 被复制到 \tcode{obj2} 中，
\begin{footnote}
例如，通过使用
库函数\iref{headers} \tcode{std::memcpy} 或 \tcode{std::memmove}。
\end{footnote}
则 \tcode{obj2} 应随后持有与
\tcode{obj1} 相同的值。
\begin{example}
\begin{codeblock}
T* t1p;
T* t2p;
    // provided that \tcode{t2p} points to an initialized object ...
std::memcpy(t1p, t2p, sizeof(T));
    // at this point, every subobject of trivially copyable type in \tcode{*t1p} contains
    // the same value as the corresponding subobject in \tcode{*t2p}
\end{codeblock}
\end{example}
\indextext{object!byte copying and|)}

\pnum
\label{term.object.representation}%
完整对象类型 \tcode{T} 的 \defnx{对象表示}{representation!object}
是由类型为 \tcode{T} 的非位域完整对象占用的
\placeholder{N} 个 \tcode{\keyword{unsigned} \keyword{char}} 对象的序列，
其中 \placeholder{N} 等于
\tcode{\keyword{sizeof}(T)}。
类型 \tcode{T} 的 \defnx{值表示}{representation!value}
是 \tcode{T} 的对象表示中
参与表示类型 \tcode{T} 的值的位集。
类型为 \tcode{T} 的非位域完整对象的对象和值表示
分别是
与对象的类型对应的对象和值表示的字节和位。
位域对象的对象表示是
对象占用的 \placeholder{N} 位序列，
其中 \placeholder{N} 是位域的宽度\iref{class.bit}。
位域对象的值表示是
对象表示中参与
表示其值的位集。
\label{term.padding.bits}%
类型或对象的对象表示中
不属于值表示的位
是 \defn{填充位}。
对于可平凡复制类型，值表示是
对象表示中的一组位，用于确定
\defn{值}，它是
\impldef{可平凡复制类型的值} 值集中的一个离散元素。
\begin{footnote}
意图是 \Cpp{} 的内存模型与 C 编程语言的内存模型兼容。
\end{footnote}

\pnum
\indextext{type!incompletely-defined object}%
已声明但未定义的类、某些
上下文中的枚举类型\iref{dcl.enum}，或未知
边界的数组或不完整元素类型的数组，是
\defnadj{不完全定义的}{object type}。
\begin{footnote}
不完全定义的对象类型的实例的大小和布局是未知的。
\end{footnote}
\label{term.incomplete.type}%
不完全定义的对象类型和 \cv{} \keyword{void} 是
\defnadjx{不完整}{类型}{type}\iref{basic.fundamental}。
\begin{note}
不能将对象定义为具有不完整类型\iref{basic.def}。
\end{note}

\pnum
类类型（例如“\tcode{\keyword{class} X}”）可以在一个
翻译单元中的一点不完整，然后在后面完成；类型
“\tcode{\keyword{class} X}” 在这两点是相同的类型。
数组对象的声明类型可以是不完整类类型的数组，
因此是不完整的；如果类类型稍后在
翻译单元中完成，则数组类型变为完整；
这两点的数组类型是相同的类型。数组对象的声明类型
可以是未知边界的数组，因此在
翻译单元中的一点不完整，然后在后面完成；
这两点的数组类型（“未知边界的 \tcode{T} 的数组”和“\tcode{N} 个 \tcode{T} 的数组”）是不同的类型。
\begin{note}
指向或引用未知边界数组的指针或引用的类型
永久指向或引用不完整类型。
由 \keyword{typedef} 声明命名的未知边界数组
永久引用不完整类型。
在任一情况下，数组类型都无法完成。
\end{note}
\begin{example}
\indextext{type!example of incomplete}%
\begin{codeblock}
class X;                        // \tcode{X} is an incomplete type
extern X* xp;                   // \tcode{xp} is a pointer to an incomplete type
extern int arr[];               // the type of arr is incomplete
typedef int UNKA[];             // \tcode{UNKA} is an incomplete type
UNKA* arrp;                     // \tcode{arrp} is a pointer to an incomplete type
UNKA** arrpp;

void foo() {
  xp++;                         // error: \tcode{X} is incomplete
  arrp++;                       // error: incomplete type
  arrpp++;                      // OK, sizeof \tcode{UNKA*} is known
}

struct X { int i; };            // now \tcode{X} is a complete type
int arr[10];                    // now the type of \tcode{arr} is complete

X x;
void bar() {
  xp = &x;                      // OK; type is ``pointer to \tcode{X}''
  arrp = &arr;                  // OK; qualification conversion\iref{conv.qual}
  xp++;                         // OK, \tcode{X} is complete
  arrp++;                       // error: \tcode{UNKA} can't be completed
}
\end{codeblock}
\end{example}

\pnum
\begin{note}
声明和表达式的规则描述了
禁止使用不完整类型的上下文。
\end{note}

\pnum
\label{term.object.type}%
\defn{对象类型} 是一个（可能是 cv 限定的）类型，它不是
函数类型，不是引用类型，也不是 \cv{} \keyword{void}。

\pnum
\indextext{class!trivial}%
\indextext{class!trivially copyable}%
\indextext{class!standard-layout}%
\label{term.scalar.type}%
算术类型\iref{basic.fundamental}、枚举类型、
指针类型、成员指针类型\iref{basic.compound}、
\tcode{std::nullptr_t}
以及
这些类型的 cv 限定\iref{basic.type.qualifier} 版本
统称为 \defnadjx{标量}{类型}{type}。
\label{term.trivially.copyable.type}%
标量类型、可平凡复制类类型\iref{class.prop}、
此类类型的数组以及这些类型的 cv 限定版本
统称为 \defnadjx{可平凡复制}{类型}{type}。
\label{term.standard.layout.type}%
标量类型、标准布局类
类型\iref{class.prop}、此类类型的数组以及
这些类型的 cv 限定版本
统称为 \defnadjx{标准布局}{类型}{type}。
\label{term.implicit.lifetime.type}%
标量类型、隐式生存期类类型\iref{class.prop}、
数组类型以及这些类型的 cv 限定版本
统称为 \defnadjx{隐式生存期}{类型}{type}。

\pnum
\label{term.literal.type}%
如果类型是以下之一，则它是 \defnadj{字面量}{类型}：
\begin{itemize}
\item \cv{} \keyword{void}；或
\item 标量类型；或
\item 引用类型；或
\item 字面量类型的数组；或
\item 可能是 cv 限定的类类型\iref{class}，
具有以下所有属性：
\begin{itemize}
\item 它有一个 constexpr 析构函数\iref{dcl.constexpr}，
\item 它的所有非静态非常量数据成员和基类都是非 volatile 字面量类型，并且
\item 它
\begin{itemize}
\item 是闭包类型\iref{expr.prim.lambda.closure}，
\item 是一个聚合联合类型，它没有变量成员或
至少有一个非 volatile 字面量类型的变量成员，
\item 是一个非联合聚合类型，其每个匿名联合成员
都满足上述聚合联合类型的要求，或者
\item 至少有一个 constexpr 构造函数或构造函数模板
（可能从基类继承\iref{namespace.udecl}）
不是复制或移动构造函数。
\end{itemize}
\end{itemize}
\end{itemize}
\begin{note}
字面量类型是一种
可能可以在常量表达式中创建对象
的类型。
这并不保证可以创建此类对象，
也不保证该类型的任何对象
都将在常量表达式中可用。
\end{note}

\pnum
\label{term.layout.compatible.type}%
如果 \tcode{T1} 和 \tcode{T2} 是相同类型，
则两种类型 \cvqual{cv1} \tcode{T1} 和 \cvqual{cv2} \tcode{T2} 是
\defnadjx{布局兼容}{类型}{type}，
布局兼容的枚举\iref{dcl.enum}，或
布局兼容的标准布局类类型\iref{class.mem}。

\rSec2[basic.fundamental]{基本类型}

\pnum
\indextext{type!implementation-defined \tcode{sizeof}}%
有五种 \defnadjx{标准有符号整型}{类型}{type}：
\indextext{type!\idxcode{signed char}}%
\indextext{type!\idxcode{short}}%
\indextext{type!\idxcode{int}}%
\indextext{type!\idxcode{long}}%
\indextext{type!\idxcode{long long}}%
“\tcode{\keyword{signed} \keyword{char}}”、“\tcode{\keyword{short} \keyword{int}}”、“\keyword{int}”、
“\tcode{\keyword{long} \keyword{int}}”和“\tcode{\keyword{long} \keyword{long} \keyword{int}}”。在
此列表中，每种类型至少提供与
列表中前面的类型一样多的存储。
也可能有 \impldef{extended signed integer types}
\defnadjx{扩展有符号整型}{类型}{type}。
标准和扩展有符号整型统称为
\defnadjx{有符号整型}{类型}{type}。
有符号整型的可表示值范围是
$-2^{N-1}$ 到 $2^{N-1}-1$（含），
其中 \placeholder{N} 称为类型的 \defn{宽度}。
\indextext{integral type!implementation-defined \tcode{sizeof}}%
\begin{note}
普通 \tcode{int} 旨在具有
执行环境的体系结构建议的自然宽度；
提供其他有符号整型以满足特殊需要。
\end{note}

\pnum
\indextext{type!\idxcode{unsigned}}%
对于每个标准有符号整型，
存在一个对应的（但不同的）
\defnadj{标准无符号整型}{类型}：
\indextext{type!\idxcode{unsigned char}}%
\indextext{type!\idxcode{unsigned short}}%
\indextext{type!\idxcode{unsigned int}}%
\indextext{type!\idxcode{unsigned long}}%
\indextext{type!\idxcode{unsigned long long}}%
“\tcode{\keyword{unsigned} \keyword{char}}”、“\tcode{\keyword{unsigned} \keyword{short} \keyword{int}}”、
“\tcode{\keyword{unsigned} \keyword{int}}”、“\tcode{\keyword{unsigned} \keyword{long} \keyword{int}}”和
“\tcode{\keyword{unsigned} \keyword{long} \keyword{long} \keyword{int}}”。
同样，对于每个扩展有符号整型，
存在一个对应的 \defnadj{扩展无符号整型}{类型}。
标准和扩展无符号整型
统称为 \defnadjx{无符号整型}{类型}{type}。
无符号整型具有与
对应的有符号整型相同的宽度 \placeholder{N}。
\indextext{arithmetic!\idxcode{unsigned}}%
无符号类型的可表示值范围是
$0$ 到 $2^N-1$（含）；
无符号类型的算术运算以 $2^N$ 为模执行。
\begin{note}
无符号算术不会溢出。
有符号算术的溢出会产生未定义的行为\iref{expr.pre}。
\end{note}

\pnum
\indextext{signed integer representation!two's complement}%
无符号整型与
对应的有符号整型具有相同的
对象表示、
值表示和
对齐要求\iref{basic.align}。
对于有符号整型的每个值 $x$，
与 $x$ 模 $2^N$ 同余的对应无符号整型的值
在其值表示中具有相同的对应位值。
\begin{footnote}
这
也称为二进制补码表示。
\end{footnote}
\begin{example}
有符号整型的值 $-1$ 与
对应的无符号类型的最大值具有相同的表示。
\end{example}

\begin{floattable}{Minimum width}{basic.fundamental.width}{lc}
\topline
\lhdr{Type} & \rhdr{Minimum width $N$} \\
\capsep
\tcode{\keyword{signed} \keyword{char}} & 8 \\
\tcode{\keyword{short} \keyword{int}} & 16 \\
\keyword{int} & 16 \\
\tcode{\keyword{long} \keyword{int}} & 32 \\
\tcode{\keyword{long} \keyword{long} \keyword{int}} & 64 \\
\end{floattable}

\pnum
每个标准有符号整型的宽度
应不小于 \tref{basic.fundamental.width} 中指定的值。
有符号或无符号整型的值表示
包含 $N$ 位，其中 N 是各自的宽度。
对象表示中任何填充位\iref{basic.types.general} 的每组值都是
由值表示指定的值的替代表示。
\begin{note}
填充位具有未指定的值，但不会导致陷阱。
相比之下，请参见 \IsoC{} 6.2.6.2。
\end{note}
\begin{note}
有符号和无符号整型满足
\IsoC{} 5.2.4.2.1 中给出的约束。
\end{note}
除上述规定外，
有符号或无符号整型的宽度是
\impldef{width of integral type}。

\pnum
宽度为 $N$ 的无符号整型的每个值 $x$ 都有
一个唯一的表示 $x = x_0 2^0 + x_1 2^1 + \ldots + x_{N-1} 2^{N-1}$，
其中每个系数 $x_i$ 为 0 或 1；
这被称为 $x$ 的 \defn{base-2 表示}。
有符号整型的值的 base-2 表示是
对应的无符号整型的同余值的 base-2 表示。
标准有符号整型和标准无符号整型
统称为 \defnadjx{标准整型}{类型}{type}，扩展
有符号整型和扩展
无符号整型统称为
\defnadjx{扩展整型}{类型}{type}。

\pnum
指定以有符号或无符号整型作为其 \defnadj{底层}{类型} 的基本类型具有
与底层类型相同的对象表示、
值表示、
对齐要求\iref{basic.align} 和
可表示值范围。
此外，每个值在两种类型中具有相同的表示。

\pnum
\indextext{type!\idxcode{char}}%
\indextext{type!character}%
\indextext{\idxcode{char}!implementation-defined sign of}%
\indextext{type!\idxcode{signed char}}%
\indextext{character!\idxcode{signed}}%
\indextext{type!\idxcode{unsigned char}}%
类型 \keyword{char} 是一个不同的类型，
它具有 \impldef{underlying type of \tcode{char}} 选择
“\tcode{\keyword{signed} \keyword{char}}”或“\tcode{\keyword{unsigned} \keyword{char}}”作为其底层类型。
\keyword{char}、\tcode{\keyword{signed} \keyword{char}} 和 \tcode{\keyword{unsigned} \keyword{char}} 这三种类型
统称为 \defnadjx{普通字符}{类型}{type}。
普通字符类型和 \keyword{char8_t}
统称为 \defnadjx{窄字符}{类型}{type}。
对于窄字符类型，
对象表示的每个可能的位模式都表示
一个不同的值。
\begin{note}
此要求不适用于其他类型。
\end{note}
\begin{note}
宽度大于
该类型的宽度的窄字符类型的位域具有填充位；参见 \ref{basic.types.general}。
\end{note}

\pnum
\indextext{\idxcode{wchar_t}|see{type, \tcode{wchar_t}}}%
\indextext{type!\idxcode{wchar_t}}%
\indextext{type!underlying!\idxcode{wchar_t}}%
类型 \keyword{wchar_t} 是一个不同的类型，它具有
\impldef{underlying type of \tcode{wchar_t}}
有符号或无符号整型作为其底层类型。

\pnum
\indextext{\idxcode{char8_t}|see{type, \tcode{char8_t}}}%
\indextext{type!\idxcode{char8_t}}%
\indextext{type!underlying!\idxcode{char8_t}}%
类型 \keyword{char8_t} 表示一个不同的类型，
其底层类型为 \tcode{\keyword{unsigned} \keyword{char}}。
\indextext{\idxcode{char16_t}|see{type, \tcode{char16_t}}}%
\indextext{\idxcode{char32_t}|see{type, \tcode{char32_t}}}%
\indextext{type!\idxcode{char16_t}}%
\indextext{type!\idxcode{char32_t}}%
\indextext{type!underlying!\idxcode{char16_t}}%
\indextext{type!underlying!\idxcode{char32_t}}%
类型 \keyword{char16_t} 和 \keyword{char32_t} 表示不同的类型，
其底层类型分别为 \libheaderref{cstdint} 中的 \tcode{uint_least16_t} 和 \tcode{uint_least32_t}。

\pnum
\indextext{Boolean type}%
\indextext{type!Boolean}%
类型 \tcode{bool} 是一个不同的类型，它具有
与 \impldef{underlying type of \tcode{bool}} 无符号整型相同的对象表示、
值表示和
对齐要求。
\keyword{bool} 类型的值是
\keyword{true} 和 \keyword{false}。
\begin{note}
没有 \keyword{signed}、\keyword{unsigned}、
\keyword{short} 或 \tcode{\keyword{long} \keyword{bool}} 类型或值。
\end{note}

\pnum
\indextext{type!integral}%
类型 \keyword{char}、\keyword{wchar_t}、
\keyword{char8_t}、\keyword{char16_t} 和 \keyword{char32_t}
统称为 \defnadjx{字符}{类型}{type}。
字符类型、\keyword{bool}、
有符号和无符号整型
以及其 cv 限定版本\iref{basic.type.qualifier}，
统称为 \defnx{整型}{integral type}。
整型的同义词是 \defn{整数类型}。
\begin{note}
枚举\iref{dcl.enum} 不是整型；
但是，无作用域枚举可以提升为整型，
如 \ref{conv.prom} 中所述。
\end{note}

\pnum
\indextext{floating-point type|see{type, floating-point}}%
三个不同的类型
\indextext{type!\idxcode{float}}%
\keyword{float}、
\indextext{type!\idxcode{double}}%
\keyword{double} 和
\indextext{type!\idxcode{long double}}%
\tcode{\keyword{long} \keyword{double}}
可以表示浮点数。
类型 \keyword{double} 至少提供与 \keyword{float} 一样多的
精度，类型 \tcode{\keyword{long} \keyword{double}} 至少提供与 \keyword{double} 一样多的精度。类型
\keyword{float} 的值集是类型
\keyword{double} 的值集的子集；类型 \keyword{double} 的值集是
类型 \tcode{\keyword{long} \keyword{double}} 的值集的子集。
类型
\keyword{float}、\keyword{double} 和 \tcode{\keyword{long} \keyword{double}}
及其 cv 限定版本\iref{basic.type.qualifier}
统称为 \defnx{标准浮点类型}{type!floating-point!standard}。
实现还可以提供表示
浮点值的附加类型，并将它们（及其 cv 限定版本）定义为
\defnx{扩展浮点类型}{type!floating-point!extended}。
标准和扩展浮点类型
统称为 \defnx{浮点类型}{type!floating-point}。
\begin{note}
未被实现定义为扩展浮点类型的
表示浮点值的任何其他特定于实现的类型
不被视为浮点类型，并且
本文档对它们或
它们与浮点类型的交互没有施加任何要求。
\end{note}
除非在 \ref{basic.extended.fp} 中指定，
否则浮点类型的对象和值表示以及运算精度是 \impldef{representation of floating-point types}。
\pnum
浮点类型的可表示值的最小范围是
可以用该类型表示的最负有限浮点数到
可以用该类型表示的最正有限浮点数。
此外，如果类型可以表示负无穷大，
则该类型的范围扩展到所有负实数；
同样，如果类型可以表示正无穷大，
则该类型的范围扩展到所有正实数。
\begin{note}
由于负无穷大和正无穷大可以在
\IsoFloatUndated{} 格式中表示，
所有实数都位于
符合 \IsoFloatUndated{} 的浮点类型的可表示值范围内。
\end{note}

\pnum
整型和浮点型统称为 \defnx{算术类型}{type!arithmetic}。
\begin{note}
算术类型的属性，
例如它们的最小和最大可表示值，
可以使用标准库头文件
\libheaderref{limits}、
\libheaderref{climits} 和
\libheaderref{cfloat} 中的工具查询。
\end{note}

\pnum
\indextext{type!\idxcode{void}}%
类型 \cv \keyword{void}
是一个无法完成的不完整类型；此类类型具有
一个空的值集。它用作
不返回值的函数的返回
类型。类型为 \cv \keyword{void} 的表达式只能用作
\begin{itemize}
\item 表达式语句\iref{stmt.expr}，
\item 返回类型为 \cv \keyword{void} 的函数的 \keyword{return} 语句\iref{stmt.return} 中的表达式，
\item 逗号表达式\iref{expr.comma} 的操作数，
\item \tcode{?:}\iref{expr.cond} 的第二个或第三个操作数，
\item \keyword{typeid} 表达式\iref{expr.typeid} 的操作数，
\item \keyword{noexcept} 运算符\iref{expr.unary.noexcept} 的操作数，
\item \keyword{decltype} 说明符\iref{dcl.type.decltype} 的操作数，或
\item 到类型 \cv \keyword{void} 的显式转换\iref{expr.type.conv,expr.static.cast,expr.cast} 的操作数。
\end{itemize}

\pnum
\cv \tcode{std::nullptr_t} 表示的类型是不同的类型。
类型为 \tcode{std::nullptr_t} 的纯右值是空指针
常量\iref{conv.ptr}。此类值参与指针和
成员指针转换\iref{conv.ptr,conv.mem}。
\tcode{\keyword{sizeof}(std::nullptr_t)} 应等于 \tcode{\keyword{sizeof}(\keyword{void}*)}。

\pnum
\indextext{type!fundamental}%
本子条款中描述的类型
称为 \defnx{基本类型}{fundamental type}。
\begin{note}
即使实现定义两个或多个基本类型具有
相同的值表示，它们仍然是不同的类型。
\end{note}

\rSec2[basic.extended.fp]{可选的扩展浮点类型}

\pnum
如果实现支持其属性由
\IsoFloatUndated{} 浮点交换格式 binary16 指定的扩展浮点类型\iref{basic.fundamental}，
则 \grammarterm{typedef-name} \tcode{std::float16_t}
在头文件 \libheaderref{stdfloat} 中定义并命名此类类型，
宏 \mname{STDCPP_FLOAT16_T} 被定义\iref{cpp.predefined}，并且
支持浮点字面量后缀 \tcode{f16} 和 \tcode{F16}
\iref{lex.fcon}。

\pnum
如果实现支持其属性由
\IsoFloatUndated{} 浮点交换格式 binary32 指定的扩展浮点类型，
则 \grammarterm{typedef-name} \tcode{std::float32_t}
在头文件 \libheader{stdfloat} 中定义并命名此类类型，
宏 \mname{STDCPP_FLOAT32_T} 被定义，并且
支持浮点字面量后缀 \tcode{f32} 和 \tcode{F32}。

\pnum
如果实现支持其属性由
\IsoFloatUndated{} 浮点交换格式 binary64 指定的扩展浮点类型，
则 \grammarterm{typedef-name} \tcode{std::float64_t}
在头文件 \libheader{stdfloat} 中定义并命名此类类型，
宏 \mname{STDCPP_FLOAT64_T} 被定义，并且
支持浮点字面量后缀 \tcode{f64} 和 \tcode{F64}。

\pnum
如果实现支持其属性由
\IsoFloatUndated{} 浮点交换格式 binary128 指定的扩展浮点类型，
则 \grammarterm{typedef-name} \tcode{std::float128_t}
在头文件 \libheader{stdfloat} 中定义并命名此类类型，
宏 \mname{STDCPP_FLOAT128_T} 被定义，并且
支持浮点字面量后缀 \tcode{f128} 和 \tcode{F128}。

\pnum
如果实现支持具有
\IsoFloatUndated{} 指定的属性的扩展浮点类型，
基数 ($b$) 为 2，
存储宽度（以位为单位）($k$) 为 16，
精度（以位为单位）($p$) 为 8，
最大指数 ($emax$) 为 127，并且
指数域宽度（以位为单位）($w$) 为 8，则
\grammarterm{typedef-name} \tcode{std::bfloat16_t}
在头文件 \libheader{stdfloat} 中定义并命名此类类型，
宏 \mname{STDCPP_BFLOAT16_T} 被定义，并且
支持浮点字面量后缀 \tcode{bf16} 和 \tcode{BF16}。

\pnum
\begin{note}
\tref{basic.extended.fp} 中给出了每种类型的参数摘要。
精度 $p$ 包括有效数开头的隐式 1 位，
因此用于有效数的存储为 $p-1$ 位。
\IsoFloatUndated{} 没有为具有
\tcode{std::bfloat16_t} 指定参数的类型分配名称。
\end{note}
\begin{floattable}
{命名扩展浮点类型的属性}{basic.extended.fp}{llllll}
\topline
\lhdr{Parameter} & \chdr{\tcode{float16_t}} & \chdr{\tcode{float32_t}} &
\chdr{\tcode{float64_t}} & \chdr{\tcode{float128_t}} &
\rhdr{\tcode{bfloat16_t}} \\
\capsep
\IsoFloatUndated{} name & binary16 & binary32 & binary64 & binary128 & \\
$k$，存储宽度（以位为单位） & 16 & 32 & 64 & 128 & 16 \\
$p$，精度（以位为单位） & 11 & 24 & 53 & 113 & 8 \\
$emax$，最大指数 & 15 & 127 & 1023 & 16383 & 127 \\
$w$，指数域宽度（以位为单位） & 5 & 8 & 11 & 15 & 8 \\
\end{floattable}

\pnum
\recommended
实现为
本子条款中描述的扩展浮点类型提供的任何名称
除了 \libheader{stdfloat} 头文件中定义的名称之外
应选择以提高与交换类型
\tcode{_Float16}、\tcode{_Float32}、\tcode{_Float64} 和 \tcode{_Float128}
在 ISO/IEC TS 18661-3 中定义以及与 \IsoCUndated{} 的未来版本
的兼容性和互操作性。

\rSec2[basic.compound]{复合类型}

\pnum
\indextext{type!compound}%
可以通过以下方式构造复合类型：
\begin{itemize}
\item 给定类型的对象的 \defnx{数组}{type!array}，\ref{dcl.array}；

\item \defnx{函数}{type!function}，它具有给定类型的形参并返回
\keyword{void} 或给定类型的结果，\ref{dcl.fct}；

\item 指向 \cv \keyword{void} 或给定类型的对象或函数（包括
类的静态成员）的 \defnx{指针}{type!pointer}，\ref{dcl.ptr}；

\item
\indextext{reference!lvalue}%
\indextext{reference!rvalue}%
\defnx{引用}{reference} 给定类型的对象或函数，\ref{dcl.ref}。有两种类型的引用：
\begin{itemize}
\item 左值引用
\item 右值引用
\end{itemize}

\item
\defnx{类}{class} 包含类成员序列\iref{class,class.mem}，
以及对访问这些实体的一组限制\iref{class.access}；

\item
\defnx{联合}{\idxcode{union}}，它们是能够在不同时间包含不同类型对象的类，\ref{class.union}；

\item
\defnx{枚举}{\idxcode{enum}}，
它包含一组命名的常量值，\ref{dcl.enum}；

\item
\indextext{member pointer to|see{pointer to member}}%
\defnx{指向非静态类成员的指针}{pointer to member}，%
\begin{footnote}
静态类成员是对象或函数，指向它们的指针是
指向对象或函数的普通指针。
\end{footnote}
它标识给定
类型在给定类对象中的成员，\ref{dcl.mptr}。
指向数据成员的指针和指向成员函数的指针统称为
\term{成员指针} 类型。
\end{itemize}

\pnum
这些构造类型的方法可以递归应用；
\ref{dcl.meaning} 中提到了限制。
构造一个类型，使其对象表示中的字节数超过
类型 \tcode{std::size_t}\iref{support.types} 中可表示的最大值是病构的。

\pnum
\indextext{terminology!pointer}%
指向 \cv \keyword{void} 的指针或指向对象类型的指针
称为 \defn{对象指针类型}。
\begin{note}
指向 \keyword{void} 的指针
没有对象指针类型，但是，因为 \keyword{void} 不是
对象类型。
\end{note}
可以指定函数的指针
的类型称为 \defn{函数指针类型}。
指向类型为 \tcode{T} 的对象的指针称为“指向
\tcode{T} 的指针”。
\begin{example}
指向类型为 \keyword{int} 的对象的指针
称为“指向 \keyword{int} 的指针”，指向
类 \tcode{X} 的对象的指针称为“指向 \tcode{X} 的指针”。
\end{example}
除了指向静态成员的指针外，提及“指针”的文本
不适用于成员指针。指针到不完整类型是
允许的，尽管对它们可以做什么有限制\iref{basic.types.general}。
\indextext{address}%
指针类型的每个值都是以下之一：
\begin{itemize}
\item
\defn{指向} 对象或函数（指针被称为 \defn{指向} 对象或函数），或
\item
对象的 \defn{末尾后指针}\iref{expr.add}，或
\item
\indextext{null pointer value|see{value, null pointer}}
该类型的 \defnx{空指针值}{value!null pointer}，或
\item
\indextext{invalid pointer value|see{value, invalid pointer}}
\defnx{无效指针值}{value!invalid pointer}。
\end{itemize}
值为
指针类型
作为指向或超过对象末尾的指针
\defn{表示地址} 内存中\iref{intro.memory} 对象占用的第一个字节
\begin{footnote}
对于不在其生存期内的对象，
这是它将占用或曾经占用的内存中的第一个字节。
\end{footnote}
或存储结束后的内存中的第一个字节
分别由对象占用。
\begin{note}
超过对象末尾的指针\iref{expr.add}
不被视为指向对象的类型的无关对象，
即使无关对象位于该地址。
\end{note}
出于指针算术\iref{expr.add}
和比较\iref{expr.rel,expr.eq} 的目的，
超过 $n$ 个元素的数组 \tcode{x} 的最后一个元素末尾的指针
被认为等效于
指向 \tcode{x} 的假设数组元素 $n$ 的指针，并且
不是数组元素的类型为 \tcode{T} 的对象
被认为属于具有类型为 \tcode{T} 的一个元素的数组。
值表示
指针类型是 \impldef{value representation of pointer types}。指向
布局兼容类型的指针应
具有相同的值表示和对齐
要求\iref{basic.align}。
\begin{note}
指向超对齐类型\iref{basic.align} 的指针没有特殊的
表示，但它们的有效值范围受扩展
对齐要求的限制。
\end{note}

\pnum
指针值 $P$ 在求值 $E$ 的上下文中是
\indextext{value!valid in the context of an evaluation}%
\defn{有效} 的，如果 $P$ 是指向函数的指针或空指针值，或者
如果它是指向对象 $O$ 或对象 $O$ 末尾之后的指针，并且
$E$ 发生在 $O$ 的存储区域的持续时间结束之前。
如果在求值 $E$ 中使用了指针值 $P$，并且
$P$ 在 $E$ 的上下文中无效，
则如果 $E$ 是
间接寻址\iref{expr.unary.op} 或
释放函数的调用\iref{basic.stc.dynamic.deallocation}，则行为未定义，
否则 \impldef{invalid pointer value in the context of an evaluation}。
\begin{footnote}
一些实现可能会定义
复制此类指针值会导致系统生成的运行时故障。
\end{footnote}
\begin{note}
即使 $P$ 指向与 $O$ 的类型无关的类型，或者
如果 $O$ 不在其生存期内，$P$ 也可能在 $E$ 的上下文中有效，
尽管对此类指针值施加了进一步的限制\iref{basic.life, basic.lval, expr.add}。
\end{note}

\pnum
如果满足以下条件，则两个对象 \placeholder{a} 和 \placeholder{b} 是 \defn{指针可互转换} 的
\begin{itemize}
\item
它们是同一个对象，或
\item
一个是联合对象，
另一个是该对象的非静态数据成员\iref{class.union}，或
\item
一个是标准布局类对象，
另一个是该对象的第一个非静态数据成员或
该对象的任何基类子对象\iref{class.mem}，或
\item
存在一个对象 \placeholder{c}，使得
\placeholder{a} 和 \placeholder{c} 是指针可互转换的，并且
\placeholder{c} 和 \placeholder{b} 是指针可互转换的。
\end{itemize}
如果两个对象是指针可互转换的，
则它们具有相同的地址，
并且可以通过 \keyword{reinterpret_cast}\iref{expr.reinterpret.cast} 从指向另一个对象的指针获取指向一个
对象的指针。
\begin{note}
数组对象及其第一个元素不是指针可互转换的，
即使它们具有相同的地址。
\end{note}

\pnum
如果存在一个对象 \placeholder{y}，
使得 \placeholder{b} 位于 \placeholder{y} 占用的存储中，或者
如果 \placeholder{y} 是数组元素，则位于直接外围数组对象中，
则存储 \placeholder{b} 的字节
\defnx{可通过}{storage!reachable through a pointer value}
指向对象 \placeholder{x} 的指针值访问。

\pnum
\indextext{pointer|seealso{\tcode{void*}}}%
\indextext{\idxcode{void*}!type}%
指向 \cv \keyword{void} 的指针
可用于指向
未知类型的对象。这样的指针应该能够容纳任何对象指针。
类型为“指向 \cv \keyword{void} 的指针”的对象
应具有与类型为“指向 \cv \keyword{char} 的指针”的对象相同的表示和对齐
要求。

\rSec2[basic.type.qualifier]{CV 限定符}

\pnum
\indextext{cv-qualifier}%
\indextext{\idxcode{const}}%
\indextext{\idxcode{volatile}}%
除函数或引用类型之外的每个类型
都是四组不同但相关的类型的一部分：
\defn{非 cv 限定} 版本、
\defn{const 限定} 版本、
\defn{volatile 限定} 版本和
\defn{const-volatile 限定} 版本。
每个此类组中的类型应具有
相同的表示和对齐要求\iref{basic.align}。
\begin{footnote}
相同的表示和对齐要求
意味着可以互换作为
函数的参数，
函数的返回值，以及
联合的非静态数据成员。
\end{footnote}
函数或引用类型始终是非 cv 限定的。
\begin{itemize}
\item \defnadj{const}{对象} 是类型为 \tcode{\keyword{const} T} 的对象或
  const 对象的不可变子对象。

\item \defnadj{volatile}{对象} 是类型为
  \tcode{\keyword{volatile} T} 的对象或 volatile 对象的子对象。

\item \defnadj{const volatile}{对象} 是类型为
  \tcode{\keyword{const} \keyword{volatile} T} 的对象、const volatile 对象的不可变子对象、
  volatile 对象的 const 子对象或 const 对象的非易失性
  volatile 子对象。
\end{itemize}
\begin{note}
对象的类型\iref{intro.object} 包括
创建对象时在
\grammarterm{decl-specifier-seq}\iref{dcl.spec}、
\grammarterm{declarator}\iref{dcl.decl}、
\grammarterm{type-id}\iref{dcl.name} 或
\grammarterm{new-type-id}\iref{expr.new}
中指定的 \grammarterm{cv-qualifier}。
\end{note}

\pnum
除了数组类型，复合类型\iref{basic.compound} 不会被
构成它的类型的 cv 限定符（如果有）cv 限定。

\pnum
\indextext{array!\idxcode{const}}%
其元素是 cv 限定的数组类型
也被认为具有与其元素相同的 cv 限定。
\begin{note}
应用于数组
类型的 Cv 限定符附加到底层元素类型，因此符号
“\cv \tcode{T}”，其中 \tcode{T} 是数组类型，指的是
其元素如此限定的数组\iref{dcl.array}。
\end{note}
\begin{example}
\begin{codeblock}
typedef char CA[5];
typedef const char CC;
CC arr1[5] = { 0 };
const CA arr2 = { 0 };
\end{codeblock}
\tcode{arr1} 和 \tcode{arr2} 的类型都是“5 个
\tcode{\keyword{const} \keyword{char}} 的数组”，并且数组类型被认为是
const 限定的。
\end{example}
\indextext{type|)}

\pnum
\begin{note}
有关具有 \grammarterm{cv-qualifier} 的函数类型，
请参见 \ref{dcl.fct} 和 \ref{over.match.funcs}。
\end{note}

\pnum
cv 限定符上存在偏序，因此可以将类型称为
比另一种类型 \defn{更 cv 限定}。
\tref{basic.type.qualifier.rel} 显示了
构成此排序的关系。

\begin{floattable}{Relations on \keyword{const} and \keyword{volatile}}{basic.type.qualifier.rel}
{ccc}
\topline
\cvqual{no cv-qualifier}    &<& \keyword{const}           \\
\cvqual{no cv-qualifier}    &<& \keyword{volatile}        \\
\cvqual{no cv-qualifier}    &<& \tcode{\keyword{const} \keyword{volatile}}  \\
\keyword{const}               &<& \tcode{\keyword{const} \keyword{volatile}}  \\
\keyword{volatile}            &<& \tcode{\keyword{const} \keyword{volatile}}  \\
\end{floattable}

\pnum
在本 文档中，类型描述中使用的符号 \cv{}（或
\cvqual{cv1}、\cvqual{cv2} 等）
表示任意的 cv 限定符集合，即，
\{\keyword{const}\}、\{\keyword{volatile}\}、\{\keyword{const}、
\keyword{volatile}\} 或空集之一。
对于类型 \cv{} \tcode{T}，该类型的 \defnx{顶层 cv 限定符}{cv-qualifier!top-level}
是由 \cv{} 表示的那些限定符。
\begin{example}
对应于 \grammarterm{type-id}
\tcode{\keyword{const} \keyword{int}\&}
的类型没有顶层 cv 限定符。
对应于 \grammarterm{type-id}
\tcode{\keyword{volatile} \keyword{int} * \keyword{const}}
的类型具有顶层 cv 限定符 \keyword{const}。
对于类类型 \tcode{C}，
对应于 \grammarterm{type-id}
\tcode{\keyword{void} (C::* \keyword{volatile})(\keyword{int}) \keyword{const}}
的类型具有顶层 cv 限定符 \keyword{volatile}。
\end{example}

\rSec2[conv.rank]{转换等级}%
\indextext{conversion!integer rank}

\pnum
每个整数类型都有一个 \term{整数转换等级}，定义如下：

\begin{itemize}
\item 除了 \keyword{char} 和 \tcode{\keyword{signed}
\keyword{char}}（如果 \keyword{char} 是有符号的）之外，没有两个有符号整数类型具有相同的等级，即使它们具有
相同的表示。

\item 有符号整数类型的等级大于
任何宽度较小的有符号整数类型的等级。

\item \tcode{\keyword{long} \keyword{long} \keyword{int}} 的等级大于
\tcode{\keyword{long} \keyword{int}} 的等级，后者大于
\keyword{int} 的等级，后者大于
\tcode{\keyword{short} \keyword{int}} 的等级，后者大于
\tcode{\keyword{signed} \keyword{char}} 的等级。

\item 任何无符号整数类型的等级等于
对应的有符号整数类型的等级。

\item 任何标准整数类型的等级大于
任何具有相同宽度的扩展整数类型的等级。

\item \keyword{char} 的等级等于 \tcode{\keyword{signed} \keyword{char}}
和 \tcode{\keyword{unsigned} \keyword{char}} 的等级。

\item \tcode{bool} 的等级小于所有
标准整数类型的等级。

\item
\indextext{type!\idxcode{wchar_t}}%
\indextext{type!\idxcode{char16_t}}%
\indextext{type!\idxcode{char32_t}}%
\keyword{char8_t}、\keyword{char16_t}、\keyword{char32_t} 和
\keyword{wchar_t} 的等级等于其底层类型\iref{basic.fundamental} 的等级。

\item 任何扩展有符号整型相对于另一个
具有相同宽度的扩展有符号整型的等级是 \impldef{rank of extended signed
integer type}，但仍受确定整数
转换等级的其他规则的约束。

\item 对于所有整数类型 \tcode{T1}、\tcode{T2} 和 \tcode{T3}，如果
\tcode{T1} 的等级高于 \tcode{T2} 并且 \tcode{T2} 的等级高于
\tcode{T3}，则 \tcode{T1} 的等级高于
\tcode{T3}。
\end{itemize}

\begin{note}
整数转换等级用于定义整型
提升\iref{conv.prom} 和常用算术
转换\iref{expr.arith.conv}。
\end{note}

\pnum
每个浮点类型都有一个 \defnadj{浮点}{转换等级}
定义如下：
\begin{itemize}
\item
浮点类型 \tcode{T} 的等级大于
任何浮点类型的等级
其值集是 \tcode{T} 的值集的真子集。
\item
\tcode{\keyword{long} \keyword{double}} 的等级大于
\keyword{double} 的等级，
后者大于 \keyword{float} 的等级。
\item
具有相同值集的两个扩展浮点类型具有相等的等级。
\item
与
恰好一个 cv 非限定标准浮点类型具有相同值集的扩展浮点类型
具有与该标准浮点类型相等的等级。
\item
与
多个 cv 非限定标准浮点类型具有相同值集的扩展浮点类型
具有与 \keyword{double} 相等的等级。
\begin{tailnote}
\tcode{std::float64_t} 的处理与
C 中的类似 \tcode{_Float64} 不同，
例如在所有
\tcode{\keyword{long} \keyword{double}}、
\keyword{double} 和
\tcode{std::float64_t}
具有相同值集的平台上（参见 \IsoCUndated{}:2024 H.4.2）。
\end{tailnote}
\end{itemize}
\begin{note}
如果浮点类型 \tcode{T1} 的值集
既不是 \tcode{T2} 的值集的子集也不是超集，则浮点类型 \tcode{T1} 和 \tcode{T2}
的转换等级是无序的。
当一种类型具有比另一种类型更大的范围和更低的精度时，
就会发生这种情况。
\end{note}

\pnum
具有相等浮点转换等级的浮点类型
按浮点转换子等级排序。
子等级在具有相等等级的类型中形成全序。
类型
\tcode{std::float16_t}、
\tcode{std::float32_t}、
\tcode{std::float64_t} 和
\tcode{std::float128_t}\iref{stdfloat.syn}
具有比任何具有相等转换等级的标准浮点类型
更大的转换子等级。
否则，转换子等级顺序是
\impldef{floating-point conversion subrank}。

\pnum
\begin{note}
浮点转换等级和子等级用于
常用算术转换\iref{expr.arith.conv} 的定义。
\end{note}

\rSec1[basic.exec]{程序执行}

\rSec2[intro.execution]{顺序执行}
\indextext{program execution|(}

\pnum
具有自动存储期\iref{basic.stc.auto} 的每个对象的实例都与每次进入其
块相关联。此类对象存在并在块执行期间以及块暂停期间（通过调用
函数、暂停协程\iref{expr.await} 或接收信号）保留其最后存储的值。

\pnum
\defn{构成表达式} 定义如下：
\begin{itemize}
\item
表达式的构成表达式是该表达式。
\item
转换的构成表达式是
相应的隐式函数调用（如果有），
否则是转换后的表达式。
\item
\grammarterm{braced-init-list} 或
（可能是带括号的）\grammarterm{expression-list} 的构成表达式
分别是列表元素的构成表达式。
\item
形式为 \tcode{=} \grammarterm{initializer-clause} 的 \grammarterm{brace-or-equal-initializer}
的构成表达式是 \grammarterm{initializer-clause} 的构成表达式。
\end{itemize}
\begin{example}
\begin{codeblock}
struct A { int x; };
struct B { int y; struct A a; };
B b = { 5, { 1+1 } };
\end{codeblock}
用于初始化 \tcode{b} 的 \grammarterm{initializer}
的构成表达式是 \tcode{5} 和 \tcode{1+1}。
\end{example}

\pnum
表达式 $E$ 的 \defnx{直接子表达式}{immediate subexpression} 是
\begin{itemize}
\item
$E$ 的操作数\iref{expr.prop} 的构成表达式，
\item
$E$ 隐式调用的任何函数调用，
\item
如果 $E$ 是 \grammarterm{lambda-expression}\iref{expr.prim.lambda}，
则复制捕获的实体的初始化和
\grammarterm{init-capture} 的 \grammarterm{initializer} 的构成表达式，
\item
如果 $E$ 是函数调用\iref{expr.call} 或隐式调用函数，
则调用中使用的每个默认实参\iref{dcl.fct.default}
的构成表达式，或
\item
如果 $E$ 创建一个聚合对象\iref{dcl.init.aggr}，
则初始化中使用的每个默认成员初始化器\iref{class.mem}
的构成表达式。
\end{itemize}

\pnum
表达式 $E$ 的 \defn{子表达式} 是
$E$ 的直接子表达式或
$E$ 的直接子表达式的子表达式。
\begin{note}
出现在 \grammarterm{lambda-expression} 的 \grammarterm{compound-statement} 中的表达式
不是 \grammarterm{lambda-expression} 的子表达式。
\end{note}
表达式、转换或 \grammarterm{initializer} $E$ 的 \defnadjx{潜在求值}{子表达式}{subexpression} 是
\begin{itemize}
\item
$E$ 的构成表达式和
\item
其不是嵌套的未求值操作数\iref{term.unevaluated.operand} 的子表达式的子表达式。
\end{itemize}

\pnum
\defn{完整表达式} 是
\begin{itemize}
\item
未求值操作数\iref{expr.context}，
\item
\grammarterm{constant-expression}\iref{expr.const}，
\item
立即调用\iref{expr.const}，
\item
\grammarterm{init-declarator}\iref{dcl.decl}
（包括由结构化绑定\iref{dcl.struct.bind} 引入的）或
\grammarterm{mem-initializer}\iref{class.base.init}，
包括初始化器的构成表达式，
\item
在生存期尚未延长的临时对象\iref{class.temporary}
的生存期结束时生成的析构函数调用，或
\item
不是另一个表达式的子表达式并且
不是完整表达式的其他部分的表达式。
\end{itemize}
如果将语言构造定义为产生函数的隐式调用，
则出于此定义的目的，将语言构造的使用视为表达式。
为了满足
表达式出现的语言构造的要求而应用于表达式结果的转换
也被视为完整表达式的一部分。
对于初始化器，执行实体的初始化
（包括评估聚合的默认成员初始化器）
也被认为是完整表达式的一部分。
\begin{example}
\begin{codeblock}
struct S {
  S(int i): I(i) { }            // full-expression is initialization of \tcode{I}
  int& v() { return I; }
  ~S() noexcept(false) { }
private:
  int I;
};

S s1(1);                        // full-expression comprises call of \tcode{S::S(int)}
void f() {
  S s2 = 2;                     // full-expression comprises call of \tcode{S::S(int)}
  if (S(3).v())                 // full-expression includes lvalue-to-rvalue and \tcode{int} to \tcode{bool} conversions,
                                // performed before temporary is deleted at end of full-expression
  { }
  bool b = noexcept(S(4));      // exception specification of destructor of \tcode{S} considered for \keyword{noexcept}

  // full-expression is destruction of \tcode{s2} at end of block
}
struct B {
  B(S = S(0));
};
B b[2] = { B(), B() };          // full-expression is the entire initialization
                                // including the destruction of temporaries
\end{codeblock}
\end{example}

\pnum
\begin{note}
完整表达式的求值可以包括
词法上不属于
完整表达式的子表达式的求值。例如，评估
默认实参\iref{dcl.fct.default} 所涉及的子表达式被认为是
在调用函数的表达式中创建的，而不是
定义默认实参的表达式。
\end{note}

\pnum
\indextext{value computation|(}%
读取由 \keyword{volatile}
泛左值\iref{basic.lval} 指定的对象、修改对象、调用库 I/O
函数或调用执行任何这些操作的函数都是
\defn{副作用}，它们是执行
环境状态的变化。表达式（或
子表达式）的 \defnx{求值}{evaluation} 通常包括值计算（包括
确定泛左值求值的对象的标识并获取
先前分配给对象的值以进行纯右值求值）和
副作用的引发。当库 I/O 函数
的调用返回或通过 volatile 泛左值进行的访问被求值时，副作用
被认为是完整的，即使调用隐含的一些外部操作（例如 I/O 本身）或 \keyword{volatile} 访问
可能尚未完成。

好的，我将保留 `indextext` 中的内容不翻译，只翻译纯文本部分，并保持 LaTeX 格式不变。以下是更新后的翻译：

\pnum
\defnx{先序于}{sequenced before} 是一种非对称、传递的、在由单个线程\iref{intro.multithread}执行的求值之间的成对关系，它在这些求值之间引入了偏序关系。给定任意两个求值 \placeholder{A} 和 \placeholder{B}，如果 \placeholder{A} 先序于 \placeholder{B}（或者等价地，\placeholder{B} \defn{后序于} \placeholder{A}），那么 \placeholder{A} 的执行应当先于 \placeholder{B} 的执行。如果 \placeholder{A} 并非先序于 \placeholder{B}，并且 \placeholder{B} 也并非先序于 \placeholder{A}，那么 \placeholder{A} 和 \placeholder{B} 是 \defn{无序的}。
\begin{note}
无序求值的执行可以重叠。
\end{note}
当 \placeholder{A} 先序于 \placeholder{B} 或者 \placeholder{B} 先序于 \placeholder{A}，但是未指明具体是哪一种情况时，求值 \placeholder{A} 和 \placeholder{B} 是\defn{不定序的}。
\begin{note}
不定序的求值不能重叠，但是两者中的任何一个都可以先执行。
\end{note}
如果与表达式 \placeholder{X} 相关联的每个值计算和每个副作用都先序于与表达式 \placeholder{Y} 相关联的每个值计算和每个副作用，则称表达式 \placeholder{X} 先序于表达式 \placeholder{Y}。

\pnum
每个与完整表达式相关联的
\indextext{value computation}%
值计算和
\indextext{side effects}%
副作用都先序于与下一个要求值的完整表达式相关联的每个值计算和副作用。
\begin{footnote}
如\ref{class.temporary}中所述，在一个完整表达式被求值之后，会进行一系列对临时对象的析构函数调用（零次或多次），通常以与每个临时对象构造相反的顺序进行。
\end{footnote}

\pnum
\indextext{evaluation!unspecified order of}%
除非特别注明，单个运算符的操作数的求值以及单个表达式的子表达式的求值是无序的。
\begin{note}
在一个程序执行期间被多次求值的表达式中，其子表达式的无序和不定序求值不必在不同的求值中保持一致。
\end{note}
运算符操作数的值计算先序于运算符结果的值计算。
如果出现以下情况，其行为是未定义的：
\begin{itemize}
\item
对某个内存位置\iref{intro.memory}的副作用，或者
\item
在某个内存位置开始或结束一个对象的生命周期
\end{itemize}
与下列情况无序：
\begin{itemize}
\item
对同一个内存位置的另一个副作用，
\item
开始或结束一个对象（该对象占用的存储空间与该内存位置重叠）的生命周期，或者
\item
使用同一内存位置中任何对象的值进行的值计算，
\end{itemize}
并且这两个求值不是潜在并发的\iref{intro.multithread}。
\begin{note}
在一个内存位置开始一个对象的生命周期可以结束其他内存位置中对象的生命周期\iref{basic.life}。
\end{note}
\begin{note}
下一个子条款对潜在并发计算施加了类似但更复杂的限制。
\end{note}

\begin{example}
\begin{codeblock}
void g(int i) {
  i = 7, i++, i++;              // \tcode{i} 变为 \tcode{9}

  i = i++ + 1;                  // \tcode{i} 的值被递增
  i = i++ + i;                  // 未定义行为
  i = i + 1;                    // \tcode{i} 的值被递增

  union U { int x, y; } u;
  (u.x = 1, 0) + (u.y = 2, 0);  // 未定义行为
}
\end{codeblock}
\end{example}

\pnum
当调用一个函数时（无论该函数是否为内联函数），每个参数表达式以及指明被调用函数的后缀表达式都先序于被调用函数体中的每个表达式或语句。
对于每一个
\begin{itemize}
\item 函数调用，
\item \grammarterm{await-expression}\iref{expr.await} 的求值，或者
\item \grammarterm{throw-expression}\iref{expr.throw} 的求值
\end{itemize}
\placeholder{F}，
每个不在 \placeholder{F} 内发生，但在同一线程上且作为同一信号处理程序（如果有）的一部分进行求值的求值，要么先序于所有在 \placeholder{F} 内发生的求值，要么后序于所有在 \placeholder{F} 内发生的求值；
\begin{footnote}
换句话说，
函数执行之间不会交错。
\end{footnote}
如果 \placeholder{F} 调用或恢复一个协程\iref{expr.await}，则只有在上一次挂起（如果有）之后和下一次挂起（如果有）之前的求值，才被认为发生在 \placeholder{F} 之内。

\Cpp{} 中的几个上下文会导致函数调用的求值，即使在翻译单元中没有出现相应的函数调用语法。
\begin{example}
\grammarterm{new-expression} 的求值会调用一个或多个分配函数和构造函数；参见\ref{expr.new}。另一个例子是，转换函数\iref{class.conv.fct}的调用可能出现在没有函数调用语法的上下文中。
\end{example}
对被调用函数执行的排序约束（如上所述）是函数调用求值的特性，与调用该函数的表达式的语法无关。%
\indextext{value computation|)}%

\indextext{behavior!on receipt of signal}%
\indextext{signal}%
\pnum
如果一个信号处理程序是由于调用 \tcode{std::raise} 函数而被执行的，那么该处理程序的执行后序于 \tcode{std::raise} 函数的调用，并先序于它的返回。
\begin{note}
当因为其他原因收到信号时，信号处理程序的执行通常与程序的其余部分是无序的。
\end{note}

\rSec2[intro.multithread]{多线程执行和数据竞争}

\rSec3[intro.multithread.general]{概述}

\pnum
\indextext{threads!multiple|(}%
\indextext{atomic!operation|(}%
\defn{执行线程}（也称为\defn{线程}）是程序中的单一控制流，包括对特定顶层函数的初始调用，并递归地包括随后由该线程执行的每个函数调用。
\begin{note}
当一个线程创建另一个线程时，新线程的顶层函数的初始调用由新线程执行，而不是由创建线程执行。
\end{note}
程序中的每个线程都可以潜在地访问程序中的每个对象和函数。
\begin{footnote}
具有自动或线程存储期\iref{basic.stc}的对象与一个特定线程相关联，并且只能通过指针或引用\iref{basic.compound}被不同线程间接访问。
\end{footnote}
在宿主实现下，一个 \Cpp{} 程序可以有多个线程并发运行。每个线程的执行按照本文档其余部分的定义进行。整个程序的执行由其所有线程的执行组成。
\begin{note}
通常，执行可以被视为其所有线程的交错。然而，某些类型的原子操作允许与简单交错不一致的执行，如下所述。
\end{note}
\indextext{implementation!freestanding}%
在独立式实现下，\impldef{在独立式实现下程序中的线程数}程序是否可以有多个执行线程。

\pnum
对于不是由于调用 \tcode{std::raise} 函数而执行的信号处理程序，未指定哪个执行线程包含信号处理程序调用。

\rSec3[intro.races]{数据竞争}

\pnum
根据以下规则，线程 $T$ 在特定点可见的对象的值是对象的初始值、由 $T$ 赋给对象的值，或由另一个线程赋给对象的值。
\begin{note}
在某些情况下，可能会出现未定义的行为。本子条款的大部分内容都是为了支持具有明确和详细可见性约束的原子操作。然而，它也隐含地支持对更受限制的程序的更简单视图。
\end{note}

\pnum
如果两个表达式求值中的一个
\begin{itemize}
\item
修改\iref{defns.access}一个内存位置\iref{intro.memory}，或者
\item
开始或结束某个内存位置中一个对象的生命周期
\end{itemize}
而另一个
\begin{itemize}
\item
读取或修改同一个内存位置，或者
\item
开始或结束一个对象（该对象占用的存储空间与该内存位置重叠）的生命周期。
\end{itemize}
则这两个表达式求值\defn{冲突}。

\begin{note}
即使修改没有改变任何位的值，仍然可能发生冲突。
\end{note}

\pnum
库定义了许多原子操作\iref{atomics}和互斥锁\iref{thread}上的操作，这些操作被特别标识为同步操作。这些操作在使一个线程中的赋值对另一个线程可见方面起着特殊的作用。一个或多个内存位置上的同步操作可以是消费操作、获取操作、释放操作，或者同时是获取和释放操作。没有关联内存位置的同步操作是栅栏，可以是获取栅栏、释放栅栏，或者同时是获取和释放栅栏。此外，还有宽松原子操作（不是同步操作）和原子读-修改-写操作（具有特殊特性）。
\begin{note}
例如，获取互斥锁的调用将对构成互斥锁的位置执行获取操作。相应地，释放同一互斥锁的调用将对这些相同的位置执行释放操作。非正式地说，对 $A$ 执行释放操作会强制先前对其他内存位置的
\indextext{side effects}%
副作用对稍后在 $A$ 上执行消费或获取操作的其他线程可见。“宽松”原子操作不是同步操作，即使它们像同步操作一样，不能导致数据竞争。
\end{note}

\pnum
对特定原子对象 $M$ 的所有修改都以某种特定的总顺序发生，称为 $M$ 的\defn{修改顺序}。
\begin{note}
每个原子对象都有一个单独的顺序。没有要求可以将这些顺序组合成所有对象的单一总顺序。通常这是不可能的，因为不同的线程可以观察到不同对象以不一致的顺序进行的修改。
\end{note}

\pnum
以原子对象 $M$ 上的释放操作 $A$ 为首的\defn{释放序列}是 $M$ 的修改顺序中
\indextext{side effects}%
副作用的最大连续子序列，其中第一个操作是 $A$，并且每个后续操作都是原子读-修改-写操作。

\pnum
某些库调用与另一个线程执行的其他库调用\defn{同步}。例如，原子存储-释放与从该存储中获取其值的加载-获取同步\iref{atomics.order}。
\begin{note}
除了在指定的情况下，读取后面的值不一定保证如下所述的可见性。这样的要求有时会干扰高效的实现。
\end{note}
\begin{note}
同步操作的规范定义了一个操作何时读取另一个操作写入的值。对于原子对象，定义是明确的。给定互斥锁上的所有操作都以单一的总顺序发生。每次互斥锁获取“读取由上次互斥锁释放写入的值”。
\end{note}

\pnum
如果求值$A$\defn{携带依赖}到求值$B$，则
\begin{itemize}
    \item $A$ 的值被用作 $B$ 的操作数，除非：
    \begin{itemize}
        \item $B$ 是对 \tcode{std::kill_dependency}\iref{atomics.order} 的任何特化的调用，或者
        \item $A$ 是内置逻辑 \logop{与} (\tcode{\&\&}, 参见\ref{expr.log.and}) 或逻辑 \logop{或} (\tcode{||}, 参见\ref{expr.log.or}) 运算符的左操作数，或者
        \item $A$ 是条件 (\tcode{?:}, 参见\ref{expr.cond}) 运算符的左操作数，或者
        \item $A$ 是内置逗号 (\tcode{,}) 运算符\iref{expr.comma}的左操作数；
    \end{itemize}
    或者
    \item $A$ 写入标量对象或位域 $M$，$B$ 从 $M$ 中读取 $A$ 写入的值，并且 $A$ 先序于 $B$，或者
    \item 对于某个求值 $X$，$A$ 携带依赖到 $X$，并且 $X$ 携带依赖到 $B$。
\end{itemize}
\begin{note}
“携带依赖到”是“先序于”的子集，并且类似地严格限于线程内。
\end{note}


\pnum
如果满足以下条件，则求值 $A$ \defn{依赖序先于} 求值 $B$：
\begin{itemize}
\item
$A$ 对原子对象 $M$ 执行释放操作，并且在另一个线程中，$B$ 对 $M$ 执行消费操作并读取由 $A$ 写入的值，或者

\item
对于某个求值 $X$，$A$ 依赖序先于 $X$ 并且 $X$ 携带依赖到 $B$。

\end{itemize}
\begin{note}
关系“依赖序先于”类似于“同步于”，但使用 释放/消费 代替 释放/获取。
\end{note}

\pnum
如果满足以下条件，则求值 $A$ \defn{线程间先发生于} 求值 $B$：
\begin{itemize}
\item
  $A$ 同步于 $B$，或者
\item
  $A$ 依赖序先于 $B$，或者
\item
  对于某个求值 $X$
  \begin{itemize}
  \item
    $A$ 同步于 $X$ 并且 $X$ 先序于 $B$，或者
  \item
    $A$ 先序于 $X$ 并且 $X$ 线程间先发生于 $B$，或者
  \item
    $A$ 线程间先发生于 $X$ 并且 $X$ 线程间先发生于 $B$。
  \end{itemize}
\end{itemize}
\begin{note}
“线程间先发生于”关系描述了“先序于”、“同步于”和“依赖序先于”关系的任意连接，但有两个例外。第一个例外是，连接永远不会以“依赖序先于”后跟“先序于”结束。这种限制的原因是，参与“依赖序先于”关系的消费操作仅对该消费操作实际携带依赖的操作提供排序。此限制仅适用于此类连接的末尾的原因是，任何后续的释放操作都将为先前的消费操作提供所需的排序。第二个例外是，连接永远不能完全由“先序于”组成。这种限制的原因是 (1) 允许“线程间先发生于”传递闭包，以及 (2) 下面定义的“先发生于”关系提供了完全由“先序于”组成的关系。
\end{note}

\pnum
如果满足以下条件，则求值 $A$ \defn{先发生于} 求值 $B$（或者，等价地，$B$ \defn{后发生于} $A$）：
\begin{itemize}
\item $A$ 先序于 $B$，或者
\item $A$ 线程间先发生于 $B$。
\end{itemize}
实现应确保没有程序执行在“先发生于”关系中表现出循环。
\begin{note}
否则，这种循环只能通过使用消费操作来实现。
\end{note}

\pnum
如果满足以下任一条件，则求值 $A$ \defn{简单先发生于} 求值 $B$：
\begin{itemize}
\item $A$ 先序于 $B$，或者
\item $A$ 同步于 $B$，或者
\item $A$ 简单先发生于 $X$ 并且 $X$ 简单先发生于 $B$。
\end{itemize}
\begin{note}
在没有消费操作的情况下，“先发生于”和“简单先发生于”关系是相同的。
\end{note}

\pnum
如果满足以下任一条件，则求值 $A$ \defn{强先发生于} 求值 $D$：
\begin{itemize}
\item $A$ 先序于 $D$，或者
\item $A$ 同步于 $D$，并且 $A$ 和 $D$ 都是顺序一致的原子操作\iref{atomics.order}，或者
\item 存在求值 $B$ 和 $C$，使得 $A$ 先序于 $B$，$B$ 简单先发生于 $C$，并且 $C$ 先序于 $D$，或者
\item 存在求值 $B$，使得 $A$ 强先发生于 $B$，并且 $B$ 强先发生于 $D$。
\end{itemize}
\begin{note}
非正式地说，如果 $A$ 强先发生于 $B$，则在所有上下文中，$A$ 看起来都在 $B$ 之前被求值。强先发生于不包括消费操作。
\end{note}

\pnum
对于标量对象或位域 $M$ 的\defnadjx{可见}{副作用}{side effects} $A$，相对于 $M$ 的值计算 $B$，满足以下条件：
\begin{itemize}
\item $A$ 先发生于 $B$，并且
\item 不存在其他对 $M$ 的
\indextext{side effects}%
副作用 $X$，使得 $A$ 先发生于 $X$ 并且 $X$ 先发生于 $B$。
\end{itemize}

由求值 $B$ 确定的非原子标量对象或位域 $M$ 的值是由
\indextext{side effects!visible}%
可见副作用 $A$ 存储的值。
\begin{note}
如果对于非原子对象或位域的哪个副作用是可见的存在歧义，则该行为要么是未指定的，要么是未定义的。
\end{note}
\begin{note}
这表明对普通对象的操作不会被可见地重新排序。如果没有数据竞争，这实际上是无法检测的，但需要确保数据竞争（如下定义）以及对原子使用的适当限制，对应于简单交错（顺序一致）执行中的数据竞争。
\end{note}

\pnum
由求值 $B$ 确定的原子对象 $M$ 的值是由修改 $M$ 的某个未指定的
副作用 $A$ 存储的值，其中 $B$ 不先发生于 $A$。
\begin{note}
此类副作用的集合也受到此处描述的其余规则的限制，特别是受到下面的连贯性要求的限制。
\end{note}

\pnum
\indextext{coherence!write-write}%
如果修改原子对象 $M$ 的操作 $A$ 先发生于修改 $M$ 的操作 $B$，则在 $M$ 的修改顺序中，$A$ 早于 $B$。
\begin{note}
此要求称为写-写连贯性。
\end{note}

\pnum
\indextext{coherence!read-read}%
如果原子对象 $M$ 的
\indextext{value computation}%
值计算 $A$ 先发生于 $M$ 的值计算 $B$，并且 $A$ 从 $M$ 上的副作用 $X$ 获取其值，则由 $B$ 计算的值要么是由 $X$ 存储的值，要么是由 $M$ 上的
\indextext{side effects}%
副作用 $Y$ 存储的值，其中 $Y$ 在 $M$ 的修改顺序中跟随 $X$。
\begin{note}
此要求称为读-读连贯性。
\end{note}

\pnum
\indextext{coherence!read-write}%
如果原子对象 $M$ 的
\indextext{value computation}%
值计算 $A$ 先发生于修改 $M$ 的操作 $B$，则 $A$ 从 $M$ 上的副作用 $X$ 获取其值，其中 $X$ 在 $M$ 的修改顺序中先于 $B$。
\begin{note}
此要求称为读-写连贯性。
\end{note}

\pnum
\indextext{coherence!write-read}%
如果原子对象 $M$ 上的
\indextext{side effects}%
副作用 $X$ 先发生于 $M$ 的值计算 $B$，则求值 $B$ 从 $X$ 或从 $M$ 的修改顺序中跟随 $X$ 的
\indextext{side effects}%
副作用 $Y$ 获取其值。
\begin{note}
此要求称为写-读连贯性。
\end{note}

\pnum
\begin{note}
前述四个连贯性要求有效地禁止了编译器对单个原子对象的操作进行重新排序，即使这两个操作都是宽松加载。这有效地使得大多数硬件提供的缓存连贯性保证可用于 \Cpp{} 原子操作。
\end{note}

\pnum
\begin{note}
原子加载观察到的值取决于“先发生于”关系，这取决于原子加载观察到的值。预期的解读是，必须存在原子加载与其观察到的修改的关联，连同适当选择的修改顺序和如上所述导出的“先发生于”关系，满足此处施加的结果约束。
\end{note}

\pnum
如果满足以下条件，则两个动作是\defn{潜在并发的}：
\begin{itemize}
\item 它们由不同的线程执行，或者
\item 它们是无序的，至少有一个由信号处理程序执行，并且它们并非都由相同的信号处理程序调用执行。
\end{itemize}
如果程序执行包含两个潜在并发的冲突动作，至少其中一个不是原子的，并且两者之间没有先发生于关系，则程序执行包含\defn{数据竞争}，但下面描述的信号处理程序的特殊情况除外。任何此类数据竞争都会导致未定义的行为。
\begin{note}
可以证明，正确使用互斥锁和 \tcode{memory_order::seq_cst} 操作来防止所有数据竞争并且不使用其他同步操作的程序，其行为就像其组成线程执行的操作被简单地交错一样，其中对象的每个
\indextext{value computation}%
值计算都取自该对象在该交错中的最后一个
\indextext{side effects}%
副作用。这通常被称为“顺序一致性”。然而，这仅适用于无数据竞争的程序，并且无数据竞争的程序无法观察到大多数不改变单线程程序语义的程序转换。实际上，大多数单线程程序转换仍然是可能的，因为任何因此行为不同的程序都具有未定义的行为。
\end{note}

\pnum
如果对类型为 \tcode{\keyword{volatile} std::sig_atomic_t} 的同一对象的两次访问都发生在同一线程中，即使一个或多个访问发生在信号处理程序中，也不会导致数据竞争。对于每个信号处理程序调用，由调用信号处理程序的线程执行的求值可以分为两组 $A$ 和 $B$，使得 $B$ 中没有求值先发生于 $A$ 中的求值，并且此类 \tcode{\keyword{volatile} std::sig_atomic_t} 对象的求值就像 $A$ 中的所有求值都先发生于信号处理程序的执行，并且信号处理程序的执行先发生于 $B$ 中的所有求值。

\pnum
\begin{note}
通常，本文档禁止编译器转换引入对潜在共享内存位置的赋值，而这些赋值不会被抽象机器修改，因为在抽象机器执行不会遇到数据竞争的情况下，此类赋值可能会覆盖不同线程的另一个赋值。这包括在单独的内存位置中覆盖相邻成员的数据成员赋值的实现。在相关原子可能别名的情况下，对原子加载的重新排序通常也被排除在外，因为这可能违反连贯性规则。
\end{note}

\pnum
\begin{note}
引入对潜在共享内存位置的推测性读取的转换可能无法保留本文档中定义的 \Cpp{} 程序的语义，因为它们可能会引入数据竞争。但是，它们通常在针对具有明确定义的数据竞争语义的特定机器的优化编译器的上下文中有效。对于不容忍竞争或提供硬件竞争检测的假设机器，它们将是无效的。
\end{note}

\rSec3[intro.progress]{向前推进}

\pnum
实现可以假定任何线程最终将执行以下操作之一：
\begin{itemize}
\item 终止，
\item 调用函数 \tcode{std::this_thread::yield}\iref{thread.thread.this}，
\item 调用库 I/O 函数，
\item 通过 volatile glvalue 执行访问，
\item 执行同步操作或原子操作，或者
\item 继续执行一个平凡的无限循环\iref{stmt.iter.general}。
\end{itemize}
\begin{note}
这旨在允许编译器转换，例如删除、合并和重新排序空循环，即使无法证明终止。对无法删除或重新排序的平凡无限循环提供了支持。
\end{note}

\pnum
被定义为无锁\iref{atomics.flag}或指示为无锁\iref{atomics.lockfree}的原子函数的执行是\defnx{无锁执行}{lock-free execution}。
\begin{itemize}
\item
  如果只有一个线程没有在标准库函数中被阻塞\iref{defns.block}，则该线程中的无锁执行应该完成。
  \begin{note}
    并发执行的线程可能会阻止无锁执行的推进。例如，这种情况可能发生在带锁加载/条件存储的实现中。此属性有时被称为无阻碍。
  \end{note}
\item
  当一个或多个无锁执行并发运行时，至少应该有一个完成。
  \begin{note}
    对于某些实现来说，很难提供绝对的保证，因为来自其他线程的重复且特别不适时的干扰可能会阻止向前推进，例如，通过在带锁加载和条件存储指令之间重复窃取用于不相关目的的缓存行。对于遵循此建议并确保在预期操作条件下此类影响不会无限期延迟推进的实现，程序员可以安全地忽略此类异常。在本文档之外，此属性有时被称为无锁。
  \end{note}
\end{itemize}

\pnum
在执行线程的执行期间，以下各项中的每一项都被称为\defn{执行步骤}：
\begin{itemize}
\item 执行线程的终止，
\item 通过 volatile glvalue 执行访问，或者
\item 完成对库 I/O 函数、同步操作或原子操作的调用。
\end{itemize}

\pnum
阻塞\iref{defns.block}的标准库函数的调用被认为在等待其阻塞的条件得到满足时持续执行执行步骤。
\begin{example}
阻塞直到 I/O 操作完成的库 I/O 函数可以被认为持续检查操作是否完成。每次此类检查都包含一个或多个执行步骤，例如使用抽象机器的可观察行为。
\end{example}

\pnum
\begin{note}
由于这一点以及前面关于执行线程必须最终执行的操作的要求，因此任何执行线程都不能在没有执行步骤发生的情况下永远执行。
\end{note}

\pnum
当执行步骤发生或无锁执行由于存在其他未在标准库函数中阻塞的并发线程（见上文）而未完成时，执行线程\defnx{取得进展}{make progress!thread}。

\pnum
\indextext{forward progress guarantees!concurrent}%
对于提供\defn{并发向前推进保证}的执行线程，实现确保只要线程尚未终止，该线程最终将取得进展。
\begin{note}
无论其他执行线程（如果有）是否已经或正在取得进展，这都适用。最终满足此要求意味着这将在未指定但有限的时间内发生。
\end{note}

\pnum
\impldef{执行 \tcode{main} 的线程以及由 \tcode{std::thread} 或 \tcode{std::jthread} 创建的线程是否提供并发向前推进保证}执行 \tcode{main}\iref{basic.start.main} 的实现创建的执行线程以及由 \tcode{std::thread}\iref{thread.thread.class} 或 \tcode{std::jthread}\iref{thread.jthread.class} 创建的执行线程是否提供并发向前推进保证。通用实现应提供这些保证。


\pnum
\indextext{forward progress guarantees!parallel}%
对于提供\defn{并行向前推进保证}的执行线程，如果该线程尚未执行任何执行步骤，则实现不需要确保该线程最终将取得进展；一旦该线程执行了一个步骤，它将提供并发向前推进保证。

\pnum
\begin{note}
这并没有指定何时启动此执行线程的要求，这通常由创建此执行线程的实体指定。例如，一个提供并发向前推进保证并以任意顺序依次执行一组任务中的任务的执行线程，满足这些任务的并行向前推进的要求。
\end{note}

\pnum
\indextext{forward progress guarantees!weakly parallel}%
对于提供\defn{弱并行向前推进保证}的执行线程，实现不确保该线程最终将取得进展。

\pnum
\begin{note}
不能期望提供弱并行向前推进保证的执行线程无论其他线程是否取得进展都能取得进展；但是，可以使用具有向前推进保证委托的阻塞（如下定义）来确保此类执行线程最终取得进展。
\end{note}

\pnum
并发向前推进保证强于并行向前推进保证，而并行向前推进保证又强于弱并行向前推进保证。
\begin{note}
例如，执行线程之间的某些类型的同步可能只有在相应的执行线程提供并行向前推进保证时才能取得进展，但在弱并行保证下将无法取得进展。
\end{note}

\pnum
\indextext{forward progress guarantees!delegation of}%
当指定执行线程 $P$ \defnx{在完成一组执行线程 $S$ 时阻塞并进行向前推进保证委托}{block (execution)!with forward progress guarantee delegation}时，则在 $P$ 在 $S$ 上阻塞的整个时间内，实现应确保 $S$ 中至少一个执行线程提供的向前推进保证至少与 $P$ 的向前推进保证一样强。
\begin{note}
未指定选择 $S$ 中的哪个或哪些执行线程以及选择多少个执行步骤。加强不是永久性的，也不一定在受影响的执行线程的剩余生命周期内有效。只要 $P$ 被阻塞，实现最终必须选择并可能加强 $S$ 中的一个执行线程。
\end{note}
一旦 $S$ 中的一个执行线程终止，它将从 $S$ 中移除。一旦 $S$ 为空，$P$ 将被解除阻塞。

\pnum
\begin{note}
因此，由于第二个执行线程 $A$ 在其上阻塞并进行向前推进保证委托，执行线程 $B$ 可以在一定时间内临时提供有效更强的向前推进保证。反过来，如果 $B$ 随后在 $C$ 上阻塞并进行向前推进保证委托，这也可以临时向 $C$ 提供更强的向前推进保证。
\end{note}

\pnum
\begin{note}
如果 $S$ 中的所有执行线程都完成了执行（例如，它们终止并且没有不正确地使用阻塞同步），则 $P$ 执行的带有向前推进保证委托的阻塞操作不会导致 $P$ 的推进保证被有效削弱。
\end{note}

\pnum
\begin{note}
这不会移除任何关于为提供并行或弱并行向前推进保证的执行线程进行阻塞同步的约束，因为实现不需要加强某个特定执行线程（其过弱的推进保证阻碍了整体进展）。
\end{note}

\pnum
实现应确保原子或同步操作分配的最后一个值（按修改顺序）将在有限的时间内对所有其他线程可见。%
\indextext{atomic!operation|)}%
\indextext{threads!multiple|)}

\rSec2[basic.start]{启动和终止}

\rSec3[basic.start.main]{\tcode{main} 函数}
\indextext{\idxcode{main} function|(}

\pnum
\indextext{program!startup|(}%
程序应恰好包含一个属于全局作用域的名为 \tcode{main} 的函数。执行程序会启动一个主执行线程\iref{intro.multithread,thread.threads}，在该线程中调用 \tcode{main} 函数。
\indextext{implementation!freestanding}%
\impldef{在独立环境中定义 \tcode{main}}在独立环境中是否需要程序定义 \tcode{main} 函数。
\begin{note}
在独立环境中，启动和终止是\impldef{独立环境中的启动和终止}；启动包含具有静态存储期的非局部对象的构造函数的执行；终止包含具有静态存储期的对象的析构函数的执行。
\end{note}

\pnum
实现不应预定义 \tcode{main} 函数。它的类型应具有 \Cpp{} 语言链接，并且应具有声明的返回类型 \keyword{int}，但除此之外，它的类型是\impldef{\tcode{main} 的参数}。
\indextext{\idxcode{main} function!implementation-defined parameters to}%
实现应允许以下两种情况：
\begin{itemize}
\item 返回 \keyword{int} 的 \tcode{()} 函数，以及
\item 返回 \keyword{int} 的 \tcode{(\keyword{int}}, 指向指向 \tcode{\keyword{char}} 的指针) 函数
\end{itemize}
\indextext{\idxcode{argc}}%
\indextext{\idxcode{argv}}%
作为 \tcode{main}\iref{dcl.fct} 的类型。
\indextext{\idxcode{main} function!parameters to}%
\indextext{environment!program}%
在后一种形式中，为了便于说明，第一个函数参数称为 \tcode{argc}，第二个函数参数称为 \tcode{argv}，其中 \tcode{argc} 应是从运行程序的环境传递给程序的参数数量。如果 \tcode{argc} 非零，则这些参数应以 \tcode{argv[0]} 到 \tcode{argv[argc-1]} 的形式提供，作为指向以空字符结尾的多字节字符串 (\ntmbs{}s)\iref{multibyte.strings} 的初始字符的指针，并且 \tcode{argv[0]} 应是指向表示用于调用程序的名称或 \tcode{""} 的 \ntmbs{} 的初始字符的指针。\tcode{argc} 的值应为非负数。\tcode{argv[argc]} 的值应为 0。

\recommended
任何进一步的（可选）参数都应添加到 \tcode{argv} 之后。

\pnum
\tcode{main} 函数不应被表达式命名。
\indextext{\idxcode{main} function!implementation-defined linkage of}%
\tcode{main} 的链接\iref{basic.link}是 \impldef{\tcode{main} 的链接}。将 \tcode{main} 定义为已删除或声明 \tcode{main} 为 \keyword{inline}、\keyword{static}、\keyword{constexpr} 或 \keyword{consteval} 的程序是非良构的。\tcode{main} 函数不应是协程\iref{dcl.fct.def.coroutine}。\tcode{main} 函数不应使用 \grammarterm{linkage-specification}\iref{dcl.link} 声明。声明以下内容的程序
\begin{itemize}
\item
属于全局作用域的变量 \tcode{main}，或
\item
属于全局作用域并附加到命名模块的函数 \tcode{main}，或
\item
属于全局作用域的函数模板 \tcode{main}，或
\item
具有 C 语言链接（在任何命名空间中）的名为 \tcode{main} 的实体
\end{itemize}
是非良构的。名称 \tcode{main} 没有其他保留用途。
\begin{example}
成员函数、类和枚举可以被称为 \tcode{main}，其他命名空间中的实体也可以。
\end{example}

\pnum
\indextext{\idxcode{exit}}%
\indexlibraryglobal{exit}%
\indextext{termination!program}%
在不离开当前块的情况下终止程序（例如，通过调用函数 \tcode{std::exit(int)}\iref{support.start.term}）不会销毁任何具有自动存储期的对象\iref{class.dtor}。如果在具有静态或线程存储期的对象的析构期间调用 \tcode{std::exit}，则程序的行为是未定义的。

\pnum
\indextext{termination!program}%
\indextext{\idxcode{main} function!return from}%
\tcode{main} 中的 \keyword{return} 语句\iref{stmt.return} 具有离开主函数（销毁任何具有自动存储期的对象）并以返回值作为参数调用 \tcode{std::exit} 的效果。如果控制流出 \tcode{main} 的 \grammarterm{compound-statement} 的末尾，则效果等同于带有操作数 \tcode{0} 的 \keyword{return}（另请参见 \ref{except.handle}）。
\indextext{\idxcode{main} function|)}

\rSec3[basic.start.static]{静态初始化}

\pnum
\indextext{initialization}%
\indextext{initialization!static and thread}%
具有静态存储期的变量作为程序启动的结果进行初始化。具有线程存储期的变量作为线程执行的结果进行初始化。在这些初始化的每个阶段中，初始化按以下方式进行。

\pnum
\indextext{initialization!constant}%
如果具有静态或线程存储期的变量是常量初始化的\iref{expr.const}，则执行\defnx{常量初始化}{constant initialization}。
\indextext{initialization!zero-initialization}%
如果未执行常量初始化，则具有静态存储期\iref{basic.stc.static}或线程存储期\iref{basic.stc.thread}的变量被零初始化\iref{dcl.init}。零初始化和常量初始化一起被称为\defnadj{静态}{初始化}；所有其他初始化都是\defnadj{动态}{初始化}。所有静态初始化都强先发生于\iref{intro.races}任何动态初始化。
\begin{note}
非块变量的动态初始化在\ref{basic.start.dynamic}中描述；静态块变量的动态初始化在\ref{stmt.dcl}中描述。
\end{note}

\pnum
即使不需要静态地进行初始化，也允许实现将具有静态或线程存储期的变量的初始化作为静态初始化执行，前提是
\begin{itemize}
\item
初始化的动态版本在初始化之前不会更改任何其他具有静态或线程存储期的对象的值，并且

\item
初始化的静态版本在初始化的变量中产生与动态初始化相同的值，如果所有不需要静态初始化的变量都被动态初始化。
\end{itemize}
\begin{note}
因此，如果对象 \tcode{obj1} 的初始化引用了可能需要动态初始化并在同一翻译单元中稍后定义的对象 \tcode{obj2}，则未指定使用的 \tcode{obj2} 的值将是完全初始化的 \tcode{obj2} 的值（因为 \tcode{obj2} 已被静态初始化）还是仅仅是零初始化的 \tcode{obj2} 的值。例如，
\begin{codeblock}
inline double fd() { return 1.0; }
extern double d1;
double d2 = d1;     // 未指定：
                    // 如果 \tcode{d1} 是动态初始化的，则静态初始化为 \tcode{0.0} 或动态初始化为 \tcode{0.0}，
                    // 否则为 \tcode{1.0}
double d1 = fd();   // 静态或动态初始化为 \tcode{1.0}
\end{codeblock}
\end{note}

\rSec3[basic.start.dynamic]{非块变量的动态初始化}

\pnum
\indextext{initialization!dynamic non-block}%
\indextext{start!program}%
\indextext{initialization!order of}%
如果具有静态存储期的非块变量是隐式或显式实例化的特化，则其动态初始化是无序的；如果变量是不是隐式或显式实例化特化的内联变量，则其动态初始化是部分有序的；否则是有序的。
\begin{note}
模板化变量的非内联显式特化具有有序初始化。
\end{note}

\pnum
如果出现以下情况，则声明 \tcode{D} \defn{外观有序先于} 声明 \tcode{E}：
\begin{itemize}
\item \tcode{D} 与 \tcode{E} 出现在同一个翻译单元中，或者
\item 包含 \tcode{E} 的翻译单元对包含 \tcode{D} 的翻译单元具有接口依赖性，
\end{itemize}
在任一情况下，都在 \tcode{E} 之前。

\pnum
具有静态存储期的非块变量 \tcode{V} 和 \tcode{W} 的动态初始化按以下方式排序：
\begin{itemize}
\item
如果 \tcode{V} 和 \tcode{W} 具有有序初始化并且 \tcode{V} 的定义外观有序先于 \tcode{W} 的定义，或者如果 \tcode{V} 具有部分有序初始化，\tcode{W} 不具有无序初始化，并且对于 \tcode{W} 的每个定义 \tcode{E}，存在 \tcode{V} 的定义 \tcode{D} 使得 \tcode{D} 外观有序先于 \tcode{E}，则
\begin{itemize}
\item
如果程序没有启动除主线程\iref{basic.start.main}之外的线程\iref{intro.multithread}，或者 \tcode{V} 和 \tcode{W} 具有有序初始化并且它们在同一个翻译单元中定义，则 \tcode{V} 的初始化先序于 \tcode{W} 的初始化；
\item
否则，\tcode{V} 的初始化强先发生于 \tcode{W} 的初始化。
\end{itemize}

\item
否则，如果程序在 \tcode{V} 或 \tcode{W} 初始化之前启动了除主线程之外的线程，则未指定 \tcode{V} 和 \tcode{W} 的初始化发生在哪个线程中；如果它们发生在同一个线程中，则初始化是无序的。

\item
否则，\tcode{V} 和 \tcode{W} 的初始化是不定序的。
\end{itemize}
\begin{note}
此定义允许一系列有序变量的初始化与另一个序列并发进行。
\end{note}

\pnum
\indextext{non-initialization odr-use|see{odr-use, non-initialization}}%
\defnx{非初始化 odr 使用}{odr-use!non-initialization} 是指并非直接或间接由非块静态或线程存储期变量的初始化引起的 odr 使用\iref{term.odr.use}。


\pnum
\indextext{evaluation!unspecified order of}%
\impldef{在 \tcode{main} 之前静态变量的动态初始化}具有静态存储期的非块非内联变量的动态初始化是在 \tcode{main} 的第一条语句之前按顺序进行还是被推迟，这是未定义的。如果它被推迟，它将强先发生于在与要初始化的变量相同的翻译单元中定义的任何非内联函数或非内联变量的任何非初始化 odr 使用。
\begin{footnote}
在这种情况下，具有带有副作用的初始化的具有静态存储期的非块变量将被初始化，即使它本身没有被 odr 使用\iref{term.odr.use,basic.stc.static}。
\end{footnote}
\impldef{延迟动态初始化的线程和程序点}此类延迟动态初始化发生在哪些线程中以及在程序的哪些点发生。

\recommended
实现应该以允许程序员避免死锁的方式选择这些点。
\begin{example}
\begin{codeblock}
// - File 1 -
#include "a.h"
#include "b.h"
B b;
A::A() {
  b.Use();
}

// - File 2 -
#include "a.h"
A a;

// - File 3 -
#include "a.h"
#include "b.h"
extern A a;
extern B b;

int main() {
  a.Use();
  b.Use();
}
\end{codeblock}

\impldef{在 \tcode{main} 之前静态变量的动态初始化}\tcode{a} 或 \tcode{b} 中的任何一个是在进入 \tcode{main} 之前初始化，还是初始化被延迟到 \tcode{a} 在 \tcode{main} 中首次被 odr 使用时，这是未定义的。特别是，如果 \tcode{a} 在进入 \tcode{main} 之前被初始化，则不能保证 \tcode{b} 将在它被 \tcode{a} 的初始化 odr 使用之前被初始化，即在 \tcode{A::A} 被调用之前。然而，如果 \tcode{a} 在 \tcode{main} 的第一条语句之后的某个时刻被初始化，\tcode{b} 将在 \tcode{A::A} 中使用它之前被初始化。
\end{example}

\pnum
\impldef{在 \tcode{main} 之前静态内联变量的动态初始化}具有静态存储期的非块内联变量的动态初始化是在 \tcode{main} 的第一条语句之前按顺序进行还是被推迟，这是未定义的。如果它被推迟，它将强先发生于该变量的任何非初始化 odr 使用。
\impldef{延迟动态初始化的线程和程序点}此类延迟动态初始化发生在哪些线程中以及在程序的哪些点发生。

\pnum
\impldef{进入之前线程局部变量的动态初始化}具有线程存储期的非块非内联变量的动态初始化是在线程初始函数的第一条语句之前按顺序进行还是被推迟，这是未定义的。如果它被推迟，则与线程 \placeholder{t} 的实体相关联的初始化先序于 \placeholder{t} 对与要初始化的变量在同一翻译单元中定义的任何具有线程存储期的非内联变量的首次非初始化 odr 使用。
\impldef{延迟动态初始化的线程和程序点}此类延迟动态初始化发生在哪些线程中以及在程序的哪些点发生。

\pnum
如果具有静态或线程存储期的非块变量的初始化通过异常退出，则调用函数 \tcode{std::terminate}\iref{except.terminate}。%
\indextext{program!startup|)}

\rSec3[basic.start.term]{终止}

\pnum
\indextext{program!termination|(}%
\indextext{object!destructor static}%
\indextext{\idxcode{main} function!return from}%
已构造的\iref{dcl.init}具有静态存储期的对象被销毁，并且已注册到 \tcode{std::atexit} 的函数作为调用的一部分被调用
\indextext{\idxcode{exit}}%
\indexlibraryglobal{exit}%
\tcode{std::exit}\iref{support.start.term}。对 \tcode{std::exit} 的调用先序于析构和已注册的函数。
\begin{note}
从 \tcode{main} 返回会调用 \tcode{std::exit}\iref{basic.start.main}。
\end{note}

\pnum
给定线程内具有线程存储期的已构造对象，作为从该线程的初始函数返回的结果以及该线程调用 \tcode{std::exit} 的结果而被销毁。该线程内所有具有线程存储期的已构造对象的销毁强先发生于销毁任何具有静态存储期的对象。

\pnum
如果具有静态存储期的对象的构造函数或动态初始化的完成强先发生于另一个对象的构造函数或动态初始化的完成，则第二个对象的析构函数的完成先序于第一个对象的析构函数的开始。如果具有线程存储期的对象的构造函数或动态初始化的完成先序于另一个对象的构造函数或动态初始化的完成，则第二个对象的析构函数的完成先序于第一个对象的析构函数的开始。如果对象是静态初始化的，则该对象将按照与对象是动态初始化的相同的顺序被销毁。对于数组或类类型的对象，该对象的所有子对象在任何在子对象构造期间初始化的具有静态存储期的块变量被销毁之前被销毁。如果具有静态或线程存储期的对象的销毁通过异常退出，则调用函数 \tcode{std::terminate}\iref{except.terminate}。

\pnum
如果一个函数包含一个已经被销毁的具有静态或线程存储期的块变量，并且该函数在具有静态或线程存储期的对象的销毁期间被调用，则如果控制流通过先前销毁的块变量的定义，则程序的行为是未定义的。
\begin{note}
同样，如果块变量在其销毁后被间接使用（例如，通过指针），则行为是未定义的。
\end{note}

\pnum
\indextext{\idxcode{atexit}}%
\indexlibraryglobal{atexit}%
如果具有静态存储期的对象的初始化的完成强先发生于对 \tcode{std::atexit} 的调用（参见 \libheader{cstdlib}，\ref{support.start.term}），则对传递给 \tcode{std::atexit} 的函数的调用先序于对该对象的析构函数的调用。如果对 \tcode{std::atexit} 的调用强先发生于具有静态存储期的对象的初始化的完成，则对该对象的析构函数的调用先序于对传递给 \tcode{std::atexit} 的函数的调用。如果对 \tcode{std::atexit} 的调用强先发生于对 \tcode{std::atexit} 的另一次调用，则对传递给第二个 \tcode{std::atexit} 调用的函数的调用先序于对传递给第一个 \tcode{std::atexit} 调用的函数的调用。

\pnum
如果在信号处理程序\iref{support.runtime}中不允许使用的标准库对象或函数的使用没有先发生于\iref{intro.multithread}具有静态存储期的对象的销毁以及已注册的 \tcode{std::atexit} 函数\iref{support.start.term}的执行的完成，则程序的行为是未定义的。
\begin{note}
如果存在对具有静态存储期的对象的使用，而该使用没有先发生于对象的销毁，则程序的行为是未定义的。在调用 \tcode{std::exit} 或从 \tcode{main} 退出之前终止每个线程足以满足这些要求，但不是必需的。这些要求允许线程管理器作为静态存储期对象。
\end{note}

\pnum
\indextext{\idxcode{abort}}%
\indexlibraryglobal{abort}%
\indextext{termination!program}%
调用在 \libheaderref{cstdlib} 中声明的函数 \tcode{std::abort()} 会终止程序，而不会执行任何析构函数，也不会调用传递给 \tcode{std::atexit()} 或 \tcode{std::at_quick_exit()} 的函数。%
\indextext{program!termination|)}%
\indextext{program execution|)}
