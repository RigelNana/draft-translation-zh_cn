%!TEX root = std.tex
\rSec0[lex]{词法约定}

\gramSec[gram.lex]{词法约定}

\indextext{lexical conventions|see{conventions, lexical}}
\indextext{translation!separate|see{compilation, separate}}
\indextext{separate translation|see{compilation, separate}}
\indextext{separate compilation|see{compilation, separate}}
\indextext{phases of translation|see{translation, phases}}
\indextext{source file character|see{character, source file}}
\indextext{alternative token|see{token, alternative}}
\indextext{digraph|see{token, alternative}}
\indextext{integer literal|see{literal, integer}}
\indextext{character literal|see{literal, character}}
\indextext{floating-point literal|see{literal, floating-point}}
\indextext{string literal|see{literal, string}}
\indextext{boolean literal|see{literal, boolean}}
\indextext{pointer literal|see{literal, pointer}}
\indextext{user-defined literal|see{literal, user-defined}}
\indextext{file, source|see{source file}}
\indextext{null character|see{character, null}}
\indextext{null wide character|see{wide-character, null}}

\rSec1[lex.separate]{独立翻译}

\pnum
\indextext{conventions!lexical|(}%
\indextext{compilation!separate|(}%
程序的文本保存在本文档中称为
\defnx{源文件}{source file} 的单元中。
一个源文件连同所有通过预处理
指令 \tcode{\#include} 包含的头文件\iref{headers}
和源文件，减去任何被条件包含\iref{cpp.cond} 预处理指令跳过的任何源行,
并由任何条件支持指令\iref{cpp.pre} 和编译指示\iref{cpp.pragma} 的实现定义行为（如果有）所修改,
被称为 \defnadj{预处理}{翻译单元}。
\begin{note}
\Cpp{} 程序不需要全部同时翻译。
\end{note}

\pnum
\begin{note}
先前翻译的翻译单元和实例化
单元可以单独保存或保存在库中。程序的各个
翻译单元通过（例如）
调用其标识符具有外部或模块链接的函数、
操作其标识符具有外部或模块链接的对象，或
操作数据文件来进行通信\iref{basic.link}。翻译单元可以被单独
翻译，然后链接以生成可执行
程序\iref{basic.link}。
\end{note}
\indextext{compilation!separate|)}

\rSec1[lex.phases]{翻译阶段}%

\pnum
\indextext{translation!phases|(}%
翻译的语法规则之间的优先级由
以下阶段指定。
\begin{footnote}
实现的行为就像这些独立的阶段
发生一样，尽管在实践中不同的阶段可以折叠在一起。
\end{footnote}

\begin{enumerate}
\item
\indextext{character!source file}%
实现应支持作为 UTF-8 代码单元序列的输入文件
（UTF-8 文件）。
它还可以支持
\impldef{支持的输入文件} 其他类型的输入文件集，
如果是，则输入文件的类型以
\impldef{确定输入文件类型的方式}
确定，包括一种将输入文件指定为 UTF-8 文件的方法，
而与其内容无关。
\begin{note}
换句话说，
识别 \unicode{feff}{字节顺序标记} 是不够的。
\end{note}
如果输入文件被确定为 UTF-8 文件，
则它应是良构的 UTF-8 代码单元序列，并且
它被解码以产生 Unicode
\begin{footnote}
Unicode\textregistered\ 是 Unicode, Inc. 的注册商标。
提供此信息是为了方便本文档的用户，
并不构成 ISO 或 IEC 对此产品的认可。
\end{footnote}
标量值序列。
然后通过将每个 Unicode 标量值
映射到相应的翻译字符集元素来形成翻译字符集元素\iref{lex.charset}序列。
在生成的序列中，
输入序列中由
\unicode{000d}{回车符} 后跟 \unicode{000a}{换行符} 组成的每对字符，
以及每个
未紧跟 \unicode{000a}{换行符} 的 \unicode{000d}{回车符}，
都将被单个换行符替换。

对于实现支持的任何其他类型的输入文件，
字符将以
\impldef{将输入文件字符映射到翻译字符集的方式}
映射到翻译字符集元素序列，
将行尾指示符表示为换行符。

\item
\indextext{line splicing}%
如果第一个翻译字符是 \unicode{feff}{字节顺序标记}，
则将其删除。
反斜杠字符 (\textbackslash)
紧跟零个或多个
除换行符之外的空白字符再紧跟换行符的每个序列都将被删除，从而拼接
物理源行以形成 \defnx{逻辑源行}{source line!logical}。只有任何物理源行上的最后一个
反斜杠才有资格成为此类拼接的一部分。
\begin{note}
行拼接可以形成
\grammarterm{universal-character-name}\iref{lex.charset}。
\end{note}
一个非空且（拼接后）
不以换行符结尾的源文件
将被视为附加了一个额外的换行符
到文件。

\item 源文件被分解为预处理
记号\iref{lex.pptoken} 和空白字符序列
（包括注释）。源文件不应以部分
预处理记号或部分注释结尾。
\begin{footnote}
部分预处理
记号将来自源文件
以需要终止字符序列的多字符记号的第一部分结尾，例如缺少
右边的 \tcode{"}
或 \tcode{>} 的 \grammarterm{header-name}。部分注释
将来自以未闭合的 \tcode{/*}
注释结尾的源文件。
\end{footnote}
每个注释\iref{lex.comment} 都被替换为一个空格字符。换行符被
保留。每个非空的除换行符之外的空白字符序列
是保留还是替换为一个空格字符是
未指明的。
当来自源文件的字符被消耗
以形成下一个预处理记号时
（即，不作为注释或其他形式的空白的一部分被消耗），
除非匹配
\grammarterm{c-char-sequence}、
\grammarterm{s-char-sequence}、
\grammarterm{r-char-sequence}、
\grammarterm{h-char-sequence} 或
\grammarterm{q-char-sequence}，
\grammarterm{universal-character-name} 被识别\iref{lex.universal.char} 并
替换为翻译字符集\iref{lex.charset} 的指定元素。
将源文件的字符
划分为预处理记号的过程是上下文相关的。
\begin{example}
请参阅 \tcode{\#include} 预处理
指令\iref{cpp.include} 中 \tcode{<} 的处理。
\end{example}

\item 源文件被分析为 \grammarterm{preprocessing-file}\iref{cpp.pre}。
预处理指令\iref{cpp} 被执行，宏调用被
展开\iref{cpp.replace}，并且 \tcode{_Pragma} 一元运算符表达式被执行\iref{cpp.pragma.op}。
\tcode{\#include} 预处理指令\iref{cpp.include} 导致命名的头文件或
源文件从阶段 1 到阶段 4 递归处理。
然后删除所有预处理指令。

\item
对于两个或多个相邻的 \grammarterm{string-literal} 记号序列，
将按照 \ref{lex.string} 中指定的方式确定一个公共的 \grammarterm{encoding-prefix}。
然后，每个这样的 \grammarterm{string-literal} 记号都被认为具有
该公共的 \grammarterm{encoding-prefix}。

\item
相邻的 \grammarterm{string-literal} 记号被连接起来\iref{lex.string}。

\item
每个预处理记号都被转换为一个记号\iref{lex.token}。
分隔记号的空白字符不再重要。
生成的记号构成一个 \defn{翻译单元}，并且
作为 \grammarterm{translation-unit}\iref{basic.link} 进行语法和
语义分析并翻译。
\begin{note}
分析和翻译记号的过程有时
会导致一个记号被
其他记号序列替换\iref{temp.names}。
\end{note}
\impldef{是否需要
当前翻译单元具有接口
依赖关系的模块单元和头单元的源
在翻译期间可用}
当前翻译单元具有接口
依赖关系\iref{module.unit,module.import}
的模块单元和头单元的源
是否需要在翻译期间可用.
\begin{note}
源文件、翻译
单元和已翻译的翻译单元不一定必须存储为
文件，也不需要在这些实体和任何外部表示之间存在任何一一对应的关系。该描述仅是概念性的
，并没有指定任何特定的实现。
\end{note}

\item 翻译后的翻译单元和实例化单元组合
如下：
\begin{note}
其中一些或全部可以由
库提供。
\end{note}
检查每个翻译后的翻译单元以
生成所需实例化的列表。
\begin{note}
这可以包括
已显式请求的实例化\iref{temp.explicit}。
\end{note}
定位所需模板的定义。\impldef{是否需要翻译单元的源
可用于定位模板定义}
包含这些定义的翻译单元的源
是否需要可用。
\begin{note}
实现可以选择将足够
的信息编码到已翻译的翻译单元中，以确保
此处不需要源。
\end{note}
执行所有必需的实例化
以生成 \defn{实例化单元}。
\begin{note}
这些类似于
已翻译的翻译单元，但不包含对
未实例化模板的引用，也不包含模板定义。
\end{note}
如果任何实例化失败，则程序是病构的。

\item 解析所有外部实体引用。库
组件被链接以满足对
当前翻译中未定义的实体的外部引用。所有这些翻译器
输出都被收集到一个程序映像中，该映像包含
在其执行环境中执行所需的信息。%
\indextext{translation!phases|)}
\end{enumerate}

\rSec1[lex.char]{字符}%

\rSec2[lex.charset]{字符集}

\pnum
\indextext{character set|(}%
\defnadj{翻译}{字符集} 由以下元素组成：
\begin{itemize}
\item
Unicode 标准中指定的 Unicode 代码空间中分配了代码点的每个抽象字符，以及
\item
未分配给抽象字符的每个 Unicode 标量值的不同字符。
\end{itemize}
\begin{note}
Unicode 代码点是
范围 $[0, \mathrm{10FFFF}]$（十六进制）中的整数。
代理代码点是
范围 $[\mathrm{D800}, \mathrm{DFFF}]$（十六进制）中的值。
Unicode 标量值是任何不是代理代码点的代码点。
\end{note}

\pnum
\defnadj{基本}{字符集} 是翻译字符集的子集，
由 \tref{lex.charset.basic} 中指定的 99 个字符组成。
\begin{note}
Unicode 短名称仅作为识别字符的一种手段给出；
数值在此上下文中没有其他含义。
\end{note}

\begin{floattable}{基本字符集}{lex.charset.basic}{lll}
\topline
\lhdrx{2}{字符} & \rhdr{字形} \\ \capsep
\ucode{0009} & \uname{character tabulation} & \\
\ucode{000b} & \uname{line tabulation} & \\
\ucode{000c} & \uname{form feed} & \\
\ucode{0020} & \uname{space} & \\
\ucode{000a} & \uname{line feed} & new-line \\
\ucode{0021} & \uname{exclamation mark} & \tcode{!} \\
\ucode{0022} & \uname{quotation mark} & \tcode{"} \\
\ucode{0023} & \uname{number sign} & \tcode{\#} \\
\ucode{0024} & \uname{dollar sign} & \tcode{\$} \\
\ucode{0025} & \uname{percent sign} & \tcode{\%} \\
\ucode{0026} & \uname{ampersand}  & \tcode{\&} \\
\ucode{0027} & \uname{apostrophe} & \tcode{'} \\
\ucode{0028} & \uname{left parenthesis} & \tcode{(} \\
\ucode{0029} & \uname{right parenthesis} & \tcode{)} \\
\ucode{002a} & \uname{asterisk} & \tcode{*} \\
\ucode{002b} & \uname{plus sign} & \tcode{+} \\
\ucode{002c} & \uname{comma} & \tcode{,} \\
\ucode{002d} & \uname{hyphen-minus} & \tcode{-} \\
\ucode{002e} & \uname{full stop} & \tcode{.} \\
\ucode{002f} & \uname{solidus} & \tcode{/} \\
\ucode{0030} .. \ucode{0039} & \uname{digit zero .. nine} & \tcode{0 1 2 3 4 5 6 7 8 9} \\
\ucode{003a} & \uname{colon} & \tcode{:} \\
\ucode{003b} & \uname{semicolon} & \tcode{;} \\
\ucode{003c} & \uname{less-than sign} & \tcode{<} \\
\ucode{003d} & \uname{equals sign} & \tcode{=} \\
\ucode{003e} & \uname{greater-than sign} & \tcode{>} \\
\ucode{003f} & \uname{question mark} & \tcode{?} \\
\ucode{0040} & \uname{commercial at} & \tcode{@} \\
\ucode{0041} .. \ucode{005a} & \uname{latin capital letter a .. z} & \tcode{A B C D E F G H I J K L M} \\
 & & \tcode{N O P Q R S T U V W X Y Z} \\
\ucode{005b} & \uname{left square bracket} & \tcode{[} \\
\ucode{005c} & \uname{reverse solidus} & \tcode{\textbackslash} \\
\ucode{005d} & \uname{right square bracket} & \tcode{]} \\
\ucode{005e} & \uname{circumflex accent} & \tcode{\caret} \\
\ucode{005f} & \uname{low line} & \tcode{_} \\
\ucode{0060} & \uname{grave accent} & \tcode{\`} \\
\ucode{0061} .. \ucode{007a} & \uname{latin small letter a .. z} & \tcode{a b c d e f g h i j k l m} \\
 & & \tcode{n o p q r s t u v w x y z} \\
\ucode{007b} & \uname{left curly bracket} & \tcode{\{} \\
\ucode{007c} & \uname{vertical line} & \tcode{|} \\
\ucode{007d} & \uname{right curly bracket} & \tcode{\}} \\
\ucode{007e} & \uname{tilde} & \tcode{\textasciitilde} \\
\end{floattable}

\pnum
\defnadj{基本字面}{字符集} 由
基本字符集的所有字符，
加上 \tref{lex.charset.literal} 中指定的控制字符组成。

\begin{floattable}{基本字面字符集中的附加控制字符}{lex.charset.literal}{ll}
\topline
\ohdrx{2}{字符} \\ \capsep
\ucode{0000} & \uname{null} \\
\ucode{0007} & \uname{alert} \\
\ucode{0008} & \uname{backspace} \\
\ucode{000d} & \uname{carriage return} \\
\end{floattable}

\pnum
\defn{码位单元} 是
字符类型\iref{basic.fundamental}的整数值。
\grammarterm{character-literal}（多字符字面量或不可编码字符字面量除外）
或 \grammarterm{string-literal} 中的字符被编码为
一个或多个码位单元的序列，由
\grammarterm{encoding-prefix}\iref{lex.ccon,lex.string} 确定；
这被称为相应的 \defnadj{字面量}{编码}。
\defnadj{普通字面量}{编码} 是
应用于普通字符或字符串字面量的编码。
\defnadj{宽字面量}{编码} 是应用于
宽字符或字符串字面量的编码。

\pnum
基本字面字符集的每个元素
在字面量编码或执行字符集\iref{character.seq}之一的区域特定编码中，均被编码为具有非负值的
单个码位单元，
且与任何其他此类元素的码位单元不同。
\begin{note}
不在基本字面字符集中的字符
可以用多个码位单元编码；
此类码位单元的值可以与
基本字面字符集元素的码位单元的值相同。
\end{note}
\indextext{character!null}%
\indextext{wide-character!null}%
\unicode{0000}{null} 字符被编码为值 \tcode{0}。
翻译字符集的任何其他元素
都不会被编码为值为 \tcode{0} 的码位单元。
数字 \tcode{0} (\ucode{0030}) 之后的每个十进制数字字符的码位单元值
应比前一个数字大 1。
普通和宽字面量编码在其他方面是
\impldef{普通和宽字面量编码}。
\indextext{UTF-8}%
\indextext{UTF-16}%
\indextext{UTF-32}%
对于 UTF-8、UTF-16 或 UTF-32 字面量，
实现应按照 Unicode 标准
中对相应 Unicode 编码形式的规定，对
与翻译字符集的每个字符相对应的 Unicode 标量值进行编码。
\indextext{character set|)}

\rSec2[lex.universal.char]{通用字符名}

\begin{bnf}
\nontermdef{n-char}\br
     \textnormal{翻译字符集中除 \unicode{007d}{右大括号} 或换行符之外的任何成员}
\end{bnf}

\begin{bnf}
\nontermdef{n-char-sequence}\br
    n-char \opt{n-char-sequence}
\end{bnf}

\begin{bnf}
\nontermdef{named-universal-character}\br
    \terminal{\textbackslash N\{} n-char-sequence \terminal{\}}
\end{bnf}

\begin{bnf}
\nontermdef{hex-quad}\br
    hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
\end{bnf}

\begin{bnf}
\nontermdef{simple-hexadecimal-digit-sequence}\br
    hexadecimal-digit \opt{simple-hexadecimal-digit-sequence}
\end{bnf}

\begin{bnf}
\nontermdef{universal-character-name}\br
    \terminal{\textbackslash u} hex-quad\br
    \terminal{\textbackslash U} hex-quad hex-quad\br
    \terminal{\textbackslash u\{} simple-hexadecimal-digit-sequence \terminal{\}}\br
    named-universal-character
\end{bnf}

\pnum
\grammarterm{universal-character-name} 结构提供了一种仅使用基本字符集来命名翻译字符集中任何元素的方法。
如果 \grammarterm{character-literal} 或
\grammarterm{string-literal} 的 \grammarterm{c-char-sequence}、\grammarterm{s-char-sequence} 或
\grammarterm{r-char-sequence} 之外的（在任一情况下，包括在 \grammarterm{user-defined-literal} 中）
\grammarterm{universal-character-name}
对应于控制字符或基本字符集中的字符，
则程序是病构的。
\begin{note}
\grammarterm{r-char-sequence}\iref{lex.string} 中类似于 \grammarterm{universal-character-name} 的字符序列
不构成 \grammarterm{universal-character-name}。
\end{note}

\pnum
形式为 \tcode{\textbackslash u} \grammarterm{hex-quad}、
\tcode{\textbackslash U} \grammarterm{hex-quad} \grammarterm{hex-quad} 或
\tcode{\textbackslash u\{\grammarterm{simple-hexadecimal-digit-sequence}\}} 的 \grammarterm{universal-character-name}
指定翻译字符集中
Unicode 标量值为
\grammarterm{universal-character-name} 中
\grammarterm{hexadecimal-digit} 序列表示的十六进制数的字符。
如果该数字不是 Unicode 标量值，则程序是病构的。

\pnum
作为 \grammarterm{named-universal-character} 的 \grammarterm{universal-character-name}
如果 \grammarterm{n-char-sequence} 等于
其字符名称或
其类型为“control”、“correction”或“alternate”的字符名称别名之一，
则指定 Unicode 标准（第 4.8 章名称）中的相应字符；
否则，程序是病构的。
\begin{note}
这些别名列在
Unicode 字符数据库的 \tcode{NameAliases.txt} 中。
这些名称或别名均不包含前导或尾随空格。
\end{note}

\rSec1[lex.comment]{注释}

\pnum
\indextext{comment|(}%
\indextext{comment!\tcode{/*} \tcode{*/}}%
\indextext{comment!\tcode{//}}%
字符 \tcode{/*} 开始一个注释，该注释以
字符 \tcode{*/} 终止。这些注释不嵌套。
\indextext{comment!\tcode{//}}%
字符 \tcode{//} 开始一个注释，该注释在
下一个换行符之前立即终止。如果此类注释中存在换页符或垂直制表符
字符，则在该字符和终止注释的换行符之间只能出现空白字符；
不需要诊断。
\begin{note}
注释字符 \tcode{//}、\tcode{/*}
和 \tcode{*/} 在 \tcode{//} 注释中没有特殊含义，
并且像其他字符一样对待。类似地，注释
字符 \tcode{//} 和 \tcode{/*} 在
\tcode{/*} 注释中没有特殊含义。
\end{note}
\indextext{comment|)}

\rSec1[lex.pptoken]{预处理记号}

\indextext{token!preprocessing|(}%
\begin{bnf}
\nontermdef{preprocessing-token}\br
    header-name\br
    import-keyword\br
    module-keyword\br
    export-keyword\br
    identifier\br
    pp-number\br
    character-literal\br
    user-defined-character-literal\br
    string-literal\br
    user-defined-string-literal\br
    preprocessing-op-or-punc\br
    \textnormal{每个不能是上述之一的非空白字符}
\end{bnf}

\pnum
预处理记号是翻译阶段 3 到 6 中语言的最小词法元素。
在本文档中，
字形用于标识
基本字符集\iref{lex.charset} 的元素。
预处理记号的类别有：头文件名、
由预处理 \tcode{import} 和 \tcode{module} 指令产生的占位符记号
（\grammarterm{import-keyword}、\grammarterm{module-keyword} 和 \grammarterm{export-keyword}）、
标识符、预处理数、字符字面量（包括用户定义的字符
字面量）、字符串字面量（包括用户定义的字符串字面量）、预处理
运算符和标点符号，以及不能在词法上
与其他预处理记号类别匹配的单个非空白字符。
如果 \unicode{0027}{撇号} 或 \unicode{0022}{引号} 字符
与最后一个类别匹配，则程序是病构的。
如果任何不在基本字符集中的字符与最后一个类别匹配，则该程序是病构的.
预处理记号可以由
\indextext{whitespace}%
空白分隔；
\indextext{comment}%
这包括注释\iref{lex.comment}，或空白字符
（\unicode{0020}{空格}、
\unicode{0009}{水平制表}、
换行符、
\unicode{000b}{垂直制表} 和
\unicode{000c}{换页符}），或两者兼有。
如 \ref{cpp} 中所述，在某些
情况下，在翻译阶段 4 期间，空白（或其缺失）
不仅仅用作预处理记号分隔。空白
只能作为头文件名的一部分或
字符字面量或字符串字面量中的引号之间出现在预处理记号中。

\pnum
每个转换为记号\iref{lex.token} 的预处理记号
都应具有关键字、标识符、字面量
或运算符或标点符号的词法形式。

\pnum
\grammarterm{import-keyword} 由
处理 \keyword{import} 指令\iref{cpp.import} 产生，
\grammarterm{module-keyword} 由预处理 \keyword{module} 指令\iref{cpp.module} 产生，
\grammarterm{export-keyword} 由
预处理前两个指令中的任何一个产生。
\begin{note}
它们都没有任何可观察的拼写。
\end{note}

\pnum
如果输入流已被解析为预处理记号直到
给定字符：
\begin{itemize}
\item
\indextext{literal!string!raw}%
如果下一个字符开始一个字符序列，该序列可能是原始字符串字面量的前缀
和初始双引号，例如 \tcode{R"}，则下一个预处理
记号应是原始字符串字面量。在原始字符串的初始和最终
双引号字符之间，在阶段 2 中执行的任何转换（行拼接）
都会被还原；此还原
应在任何 \grammarterm{d-char}、\grammarterm{r-char} 或定界
括号被识别之前应用。原始字符串字面量被定义为与 raw-string 模式匹配的最短字符序列
\begin{ncbnf}
\opt{encoding-prefix} \terminal{R} raw-string
\end{ncbnf}

\item 否则，如果接下来的三个字符是 \tcode{<::} 并且后续字符
既不是 \tcode{:} 也不是 \tcode{>}，则 \tcode{<} 被视为一个预处理记号，
而不是替代记号 \tcode{<:} 的第一个字符。

\item 否则，
下一个预处理记号是
可以构成预处理记号的最长字符序列，即使这
会导致进一步的词法分析失败，
但 \grammarterm{header-name}\iref{lex.header} 仅在以下情况下形成
\begin{itemize}
\item
在 \tcode{\#include}\iref{cpp.include} 或
\tcode{import}\iref{cpp.import} 指令中的 \tcode{include} 或 \tcode{import} 预处理记号之后，或

\item
在 \grammarterm{has-include-expression} 中。

\end{itemize}
\end{itemize}

\pnum
\begin{example}
\begin{codeblock}
#define R "x"
const char* s = R"y";           // 病构的原始字符串，不是 \tcode{"x" "y"}
\end{codeblock}
\end{example}

\pnum
\begin{example}
程序片段 \tcode{0xe+foo} 被解析为
预处理数记号（一个不是有效的
\grammarterm{integer-literal} 或 \grammarterm{floating-point-literal} 记号的记号），
即使解析为三个预处理记号
\tcode{0xe}、\tcode{+} 和 \tcode{foo} 可以产生有效的表达式（例如，
如果 \tcode{foo} 是定义为 \tcode{1} 的宏）。类似地，
程序片段 \tcode{1E1} 被解析为预处理数（一个
是有效的 \grammarterm{floating-point-literal} 记号），
无论 \tcode{E} 是否是宏名称。
\end{example}

\pnum
\begin{example}
程序片段 \tcode{x+++++y} 被解析为 \tcode{x
++ ++ + y}，如果 \tcode{x} 和 \tcode{y} 具有整型，
则违反了对增量运算符的约束，即使解析
\tcode{x ++ + ++ y} 可以产生正确的表达式。
\end{example}
\indextext{token!preprocessing|)}

\rSec1[lex.header]{头文件名}

\indextext{header!name|(}%
\begin{bnf}
\microtypesetup{protrusion=false}\obeyspaces
\nontermdef{header-name}\br
    \terminal{<} h-char-sequence \terminal{>}\br
    \terminal{"} q-char-sequence \terminal{"}
\end{bnf}

\begin{bnf}
\nontermdef{h-char-sequence}\br
    h-char \opt{h-char-sequence}
\end{bnf}

\begin{bnf}
\nontermdef{h-char}\br
    \textnormal{翻译字符集中除换行符和 \unicode{003e}{右尖括号}} 之外的任何成员
\end{bnf}

\begin{bnf}
\nontermdef{q-char-sequence}\br
    q-char \opt{q-char-sequence}
\end{bnf}

\begin{bnf}
\nontermdef{q-char}\br
    \textnormal{翻译字符集中除换行符和 \unicode{0022}{引号}} 之外的任何成员
\end{bnf}

\pnum
两种形式的 \grammarterm{header-name} 中的序列都以
\impldef{将头文件名映射到头文件或外部源文件} 方式映射到头文件或
外部源文件名，如 \ref{cpp.include} 中所述。
\begin{note}
头文件名预处理记号仅出现在
\tcode{\#include} 预处理指令、
\tcode{__has_include} 预处理表达式中，或
在 \tcode{import} 记号的某些出现之后
（参见 \ref{lex.pptoken}）。
\end{note}

\pnum
字符 \tcode{'} 或 \tcode{\textbackslash} 或
字符序列 \tcode{/*} 或 \tcode{//} 中的任何一个出现在
\grammarterm{q-char-sequence} 或 \grammarterm{h-char-sequence} 中
是条件支持的，具有 \impldef{\tcode{'}、\tcode{\textbackslash}、
\tcode{/*} 或 \tcode{//} 在 \grammarterm{q-char-sequence} 或
\grammarterm{h-char-sequence} 中的含义} 语义，字符
\tcode{"} 出现在 \grammarterm{h-char-sequence} 中也是如此。
\begin{note}
因此，字符序列
类似于转义序列可能会导致错误，被解释为
与转义序列相对应的字符，或具有完全不同的含义，
具体取决于实现。
\end{note}
\indextext{header!name|)}

\rSec1[lex.ppnumber]{预处理数}

\indextext{number!preprocessing|(}%
\begin{bnf}
\nontermdef{pp-number}\br
    digit\br
    \terminal{.} digit\br
    pp-number identifier-continue\br
    pp-number \terminal{'} digit\br
    pp-number \terminal{'} nondigit\br
    pp-number \terminal{e} sign\br
    pp-number \terminal{E} sign\br
    pp-number \terminal{p} sign\br
    pp-number \terminal{P} sign\br
    pp-number \terminal{.}
\end{bnf}

\pnum
预处理数记号在词法上包括
所有 \grammarterm{integer-literal} 记号\iref{lex.icon} 和
所有 \grammarterm{floating-point-literal} 记号\iref{lex.fcon}。

\pnum
预处理数没有类型或值；它在成功转换为
\grammarterm{integer-literal} 记号或
\grammarterm{floating-point-literal} 记号后获得两者。%
\indextext{number!preprocessing|)}

\rSec1[lex.operators]{运算符和标点符号}

\pnum
\indextext{operator|(}%
\indextext{punctuator|(}%
\Cpp{} 程序的词法表示包括许多
在预处理器的语法中使用的预处理记号，或
被转换为运算符和标点符号的记号：

\begin{bnf}
\nontermdef{preprocessing-op-or-punc}\br
    preprocessing-operator\br
    operator-or-punctuator
\end{bnf}

\begin{bnf}
%% Ed. note: character protrusion would misalign various operators.
\microtypesetup{protrusion=false}\obeyspaces
\nontermdef{preprocessing-operator} \textnormal{one of}\br
    \terminal{\#        \#\#       \%:       \%:\%:}
\end{bnf}

\begin{bnf}
\microtypesetup{protrusion=false}\obeyspaces
\nontermdef{operator-or-punctuator} \textnormal{one of}\br
    \terminal{\{        \}        [        ]        (        )}\br
    \terminal{<:       :>       <\%       \%>       ;        :        ...}\br
    \terminal{?        ::       .        .*       ->       ->*      \~}\br
    \terminal{!        +        -        *        /        \%        \caret{}        \&        |}\br
    \terminal{=        +=       -=       *=       /=       \%=       \caret{}=       \&=       |=}\br
    \terminal{==       !=       <        >        <=       >=       <=>      \&\&       ||}\br
    \terminal{<<       >>       <<=      >>=      ++       --       ,}\br
    \terminal{\keyword{and}      \keyword{or}       \keyword{xor}      \keyword{not}      \keyword{bitand}   \keyword{bitor}    \keyword{compl}}\br
    \terminal{\keyword{and_eq}   \keyword{or_eq}    \keyword{xor_eq}   \keyword{not_eq}}
\end{bnf}

每个 \grammarterm{operator-or-punctuator} 在翻译阶段 7\iref{lex.phases} 中都被转换为单个记号。%
\indextext{punctuator|)}%
\indextext{operator|)}

\rSec1[lex.digraph]{替代记号}

\pnum
\indextext{token!alternative|(}%
为某些运算符和
标点符号提供了替代的记号表示。
\begin{footnote}
\indextext{digraph}%
这些包括“双字符组”和附加的保留字。术语
“双字符组”（由两个字符组成的记号）并不是完全
描述性的，因为其中一个替代的 \grammarterm{preprocessing-token} 是
\tcode{\%:\%:}，当然还有几个主要的记号包含两个
字符。尽管如此，那些不是词法关键字的替代记号通常被称为“双字符组”。
\end{footnote}

\pnum
在语言的所有方面，每个替代记号的行为分别与其主要记号相同，
除了其拼写。
\begin{footnote}
因此，\tcode{[} 和 \tcode{<:} 的“字符串化”值\iref{cpp.stringize}
将不同，保持源拼写，但记号在其他方面可以自由互换。
\end{footnote}
替代记号集在
\tref{lex.digraph} 中定义。

\begin{tokentable}{替代记号}{lex.digraph}{替代}{主要}
\tcode{<\%}             &   \tcode{\{}         &
\keyword{and}           &   \tcode{\&\&}       &
\keyword{and_eq}        &   \tcode{\&=}        \\ \rowsep
\tcode{\%>}             &   \tcode{\}}         &
\keyword{bitor}         &   \tcode{|}          &
\keyword{or_eq}         &   \tcode{|=}         \\ \rowsep
\tcode{<:}              &   \tcode{[}          &
\keyword{or}            &   \tcode{||}         &
\keyword{xor_eq}        &   \tcode{\caret=}    \\ \rowsep
\tcode{:>}              &   \tcode{]}          &
\keyword{xor}           &   \tcode{\caret}     &
\keyword{not}           &   \tcode{!}          \\ \rowsep
\tcode{\%:}             &   \tcode{\#}         &
\keyword{compl}         &   \tcode{\~}         &
\keyword{not_eq}        &   \tcode{!=}         \\ \rowsep
\tcode{\%:\%:}          &   \tcode{\#\#}       &
\keyword{bitand}        &   \tcode{\&}         &
                        &                      \\
\end{tokentable}%
\indextext{token!alternative|)}

\rSec1[lex.token]{记号}

\indextext{token|(}%
\begin{bnf}
\nontermdef{token}\br
    identifier\br
    keyword\br
    literal\br
    operator-or-punctuator
\end{bnf}

\pnum
\indextext{\idxgram{token}}%
有五种记号：标识符、关键字、字面量、%
\begin{footnote}
字面量包括字符串、字符和数字字面量。
\end{footnote}
运算符和其他分隔符。
\indextext{whitespace}%
空格、水平和垂直制表符、换行符、换页符和注释
（统称为“空白”），如下所述，除了
用于分隔记号外，将被忽略。
\begin{note}
空白可以分隔原本相邻的标识符、关键字、数字
字面量和包含字母字符的替代记号。
\end{note}
\indextext{token|)}

\rSec1[lex.name]{标识符}

\indextext{identifier|(}%
\begin{bnf}
\nontermdef{identifier}\br
    identifier-start\br
    identifier identifier-continue
\end{bnf}

\begin{bnf}
\nontermdef{identifier-start}\br
    nondigit\br
    \textnormal{具有 Unicode 属性 XID_Start 的翻译字符集的元素}
\end{bnf}

\begin{bnf}
\nontermdef{identifier-continue}\br
    digit\br
    nondigit\br
    \textnormal{具有 Unicode 属性 XID_Continue 的翻译字符集的元素}
\end{bnf}

\begin{bnf}
\nontermdef{nondigit} \textnormal{one of}\br
    \terminal{a b c d e f g h i j k l m}\br
    \terminal{n o p q r s t u v w x y z}\br
    \terminal{A B C D E F G H I J K L M}\br
    \terminal{N O P Q R S T U V W X Y Z _}
\end{bnf}

\begin{bnf}
\nontermdef{digit} \textnormal{one of}\br
    \terminal{0 1 2 3 4 5 6 7 8 9}
\end{bnf}

\pnum
\indextext{name!length of}%
\indextext{name}%
\begin{note}
字符属性 XID_Start 和 XID_Continue 由 Unicode 标准的 \UAX{44} 描述。
\begin{footnote}
在链接器无法接受扩展
字符的系统上，可以在
形成有效的外部标识符时使用 \grammarterm{universal-character-name} 的编码。例如，可以使用一些原本未使用的
字符或字符序列来编码
\grammarterm{universal-character-name} 中的 \tcode{\textbackslash u}。扩展
字符可能会产生较长的外部标识符，但 \Cpp{} 并未
对外部标识符的有效字符设置翻译限制。
\end{footnote}
\end{note}
如果 \grammarterm{identifier} 不符合 Unicode 标准中指定的
规范化形式 C，则程序是病构的。
\begin{note}
标识符区分大小写。
\end{note}
\begin{note}
\ref{uaxid} 将 Unicode 标准的 \UAX{31} 的要求
与 \Cpp{} 的标识符规则进行了比较。
\end{note}
\begin{note}
在翻译阶段 4 中，
\grammarterm{identifier} 还包括
那些在稍后的翻译阶段 7\iref{lex.token} 中
区分为关键字\iref{lex.key} 的 \grammarterm{preprocessing-token}。
\end{note}

\pnum
\indextext{\idxcode{import}}%
\indextext{\idxcode{final}}%
\indextext{\idxcode{module}}%
\indextext{\idxcode{override}}%
\tref{lex.name.special} 中的标识符在
出现在特定上下文中时具有特殊含义。当在语法中引用时，这些标识符
被显式使用，而不是使用 \grammarterm{identifier} 语法产生式。
除非另有说明，否则对于给定的
\grammarterm{identifier} 是否具有特殊含义的任何歧义都将解析为将该
记号解释为常规的 \grammarterm{identifier}。

\begin{multicolfloattable}{具有特殊含义的标识符}{lex.name.special}
{llll}
\keyword{final}           \\
\columnbreak
\keyword{import}          \\
\columnbreak
\keyword{module}          \\
\columnbreak
\keyword{override}        \\
\end{multicolfloattable}

\pnum
\indextext{\idxcode{_}|see{character, underscore}}%
\indextext{character!underscore!in identifier}%
\indextext{reserved identifier}%
此外，一些作为 \grammarterm{token} 或 \grammarterm{preprocessing-token} 出现的标识符
保留供 \Cpp{}
实现使用，不得
以其他方式使用；不需要诊断。
\begin{itemize}
\item
每个包含双下划线
\tcode{\unun}
\indextext{character!underscore}%
或以下划线后跟
大写字母开头的标识符，
本文档中指定的除外
（例如，\xname{cplusplus}\iref{cpp.predefined}），
\indextext{uppercase}%
都保留给实现以供任何使用。
\item
每个以下划线开头的标识符
\indextext{character!underscore}%
都保留给实现，用作全局命名空间中的名称。%
\indextext{namespace!global}
\end{itemize}%
\indextext{identifier|)}

\rSec1[lex.key]{关键字}

\begin{bnf}
\nontermdef{keyword}\br
    \textnormal{any identifier listed in \tref{lex.key}}\br
    \grammarterm{import-keyword}\br
    \grammarterm{module-keyword}\br
    \grammarterm{export-keyword}
\end{bnf}

\pnum
\indextext{keyword|(}%
\tref{lex.key} 中显示的标识符保留用作
关键字（即，它们在阶段 7 中无条件地被视为关键字），
除非在 \grammarterm{attribute-token}\iref{dcl.attr.grammar} 中。
\begin{note}
\keyword{register} 关键字未使用，但
保留以供将来使用。
\end{note}

\begin{multicolfloattable}{关键字}{lex.key}
{lllll}
\keyword{alignas} \\
\keyword{alignof} \\
\keyword{asm} \\
\keyword{auto} \\
\keyword{bool} \\
\keyword{break} \\
\keyword{case} \\
\keyword{catch} \\
\keyword{char} \\
\keyword{char8_t} \\
\keyword{char16_t} \\
\keyword{char32_t} \\
\keyword{class} \\
\keyword{concept} \\
\keyword{const} \\
\keyword{consteval} \\
\keyword{constexpr} \\
\columnbreak
\keyword{constinit} \\
\keyword{const_cast} \\
\keyword{continue} \\
\keyword{co_await} \\
\keyword{co_return} \\
\keyword{co_yield} \\
\keyword{decltype} \\
\keyword{default} \\
\keyword{delete} \\
\keyword{do} \\
\keyword{double} \\
\keyword{dynamic_cast} \\
\keyword{else} \\
\keyword{enum} \\
\keyword{explicit} \\
\keyword{export} \\
\keyword{extern} \\
\columnbreak
\keyword{false} \\
\keyword{float} \\
\keyword{for} \\
\keyword{friend} \\
\keyword{goto} \\
\keyword{if} \\
\keyword{inline} \\
\keyword{int} \\
\keyword{long} \\
\keyword{mutable} \\
\keyword{namespace} \\
\keyword{new} \\
\keyword{noexcept} \\
\keyword{nullptr} \\
\keyword{operator} \\
\keyword{private} \\
\keyword{protected} \\
\columnbreak
\keyword{public} \\
\keyword{register} \\
\keyword{reinterpret_cast} \\
\keyword{requires} \\
\keyword{return} \\
\keyword{short} \\
\keyword{signed} \\
\keyword{sizeof} \\
\keyword{static} \\
\keyword{static_assert} \\
\keyword{static_cast} \\
\keyword{struct} \\
\keyword{switch} \\
\keyword{template} \\
\keyword{this} \\
\keyword{thread_local} \\
\keyword{throw} \\
\columnbreak
\keyword{true} \\
\keyword{try} \\
\keyword{typedef} \\
\keyword{typeid} \\
\keyword{typename} \\
\keyword{union} \\
\keyword{unsigned} \\
\keyword{using} \\
\keyword{virtual} \\
\keyword{void} \\
\keyword{volatile} \\
\keyword{wchar_t} \\
\keyword{while} \\
\end{multicolfloattable}

\pnum
此外，
\tref{lex.key.digraph} 中显示的某些运算符和
标点符号\iref{lex.digraph} 的替代表示是保留的，不得
以其他方式使用。

\begin{floattable}{替代表示}{lex.key.digraph}
{llllll}
\topline
\keyword{and}     &   \keyword{and_eq}  &   \keyword{bitand}  &   \keyword{bitor}   &   \keyword{compl}   &   \keyword{not} \\
\keyword{not_eq}  &   \keyword{or}      &   \keyword{or_eq}   &   \keyword{xor}     &   \keyword{xor_eq}  &       \\
\end{floattable}%
\indextext{keyword|)}%


\rSec1[lex.literal]{字面量}%
\indextext{literal|(}

\rSec2[lex.literal.kinds]{字面量的种类}

\pnum
\indextext{constant}%
\indextext{literal!constant}%
有几种字面量。
\begin{footnote}
术语“字面量”通常指
本文档中在 C 中被称为“常量”的那些记号。
\end{footnote}

\begin{bnf}
\nontermdef{literal}\br
    integer-literal\br
    character-literal\br
    floating-point-literal\br
    string-literal\br
    boolean-literal\br
    pointer-literal\br
    user-defined-literal
\end{bnf}
\begin{note}
当作为 \grammarterm{expression} 出现时，
字面量具有类型和值类别\iref{expr.prim.literal}。
\end{note}

\rSec2[lex.icon]{整数字面量}

\indextext{literal!integer}%
\begin{bnf}
\nontermdef{integer-literal}\br
    binary-literal \opt{integer-suffix}\br
    octal-literal \opt{integer-suffix}\br
    decimal-literal \opt{integer-suffix}\br
    hexadecimal-literal \opt{integer-suffix}
\end{bnf}

\begin{bnf}
\nontermdef{binary-literal}\br
    \terminal{0b} binary-digit\br
    \terminal{0B} binary-digit\br
    binary-literal \opt{\terminal{'}} binary-digit
\end{bnf}

\begin{bnf}
\nontermdef{octal-literal}\br
    \terminal{0}\br
    octal-literal \opt{\terminal{'}} octal-digit
\end{bnf}

\begin{bnf}
\nontermdef{decimal-literal}\br
    nonzero-digit\br
    decimal-literal \opt{\terminal{'}} digit
\end{bnf}

\begin{bnf}
\nontermdef{hexadecimal-literal}\br
    hexadecimal-prefix hexadecimal-digit-sequence
\end{bnf}

\begin{bnf}
\nontermdef{binary-digit} \textnormal{one of}\br
    \terminal{0  1}
\end{bnf}

\begin{bnf}
\nontermdef{octal-digit} \textnormal{one of}\br
    \terminal{0  1  2  3  4  5  6  7}
\end{bnf}

\begin{bnf}
\nontermdef{nonzero-digit} \textnormal{one of}\br
    \terminal{1  2  3  4  5  6  7  8  9}
\end{bnf}

\begin{bnf}
\nontermdef{hexadecimal-prefix} \textnormal{one of}\br
    \terminal{0x  0X}
\end{bnf}

\begin{bnf}
\nontermdef{hexadecimal-digit-sequence}\br
    hexadecimal-digit\br
    hexadecimal-digit-sequence \opt{\terminal{'}} hexadecimal-digit
\end{bnf}

\begin{bnf}
\nontermdef{hexadecimal-digit} \textnormal{one of}\br
    \terminal{0  1  2  3  4  5  6  7  8  9}\br
    \terminal{a  b  c  d  e  f}\br
    \terminal{A  B  C  D  E  F}
\end{bnf}

\begin{bnf}
\nontermdef{integer-suffix}\br
    unsigned-suffix \opt{long-suffix} \br
    unsigned-suffix \opt{long-long-suffix} \br
    unsigned-suffix \opt{size-suffix} \br
    long-suffix \opt{unsigned-suffix} \br
    long-long-suffix \opt{unsigned-suffix} \br
    size-suffix \opt{unsigned-suffix}
\end{bnf}

\begin{bnf}
\nontermdef{unsigned-suffix} \textnormal{one of}\br
    \terminal{u  U}
\end{bnf}

\begin{bnf}
\nontermdef{long-suffix} \textnormal{one of}\br
    \terminal{l  L}
\end{bnf}

\begin{bnf}
\nontermdef{long-long-suffix} \textnormal{one of}\br
    \terminal{ll  LL}
\end{bnf}

\begin{bnf}
\nontermdef{size-suffix} \textnormal{one of}\br
   \terminal{z  Z}
\end{bnf}

\pnum
\indextext{literal!\idxcode{unsigned}}%
\indextext{literal!\idxcode{long}}%
\indextext{literal!base of integer}%
在 \grammarterm{integer-literal} 中，
\grammarterm{binary-digit}s、
\grammarterm{octal-digit}s、
\grammarterm{digit}s 或
\grammarterm{hexadecimal-digit}s 的序列
被解释为 \tref{lex.icon.base} 中所示的以 $N$ 为基数的整数；
数字序列中词法上的第一个数字是最高有效位。
\begin{note}
在确定值时，前缀和任何可选的单引号分隔符都将被忽略。
\end{note}

\begin{simpletypetable}
{\grammarterm{integer-literal} 的基数}
{lex.icon.base}
{lr}
\topline
\lhdr{\grammarterm{integer-literal} 的种类} & \rhdr{基数 $N$} \\ \capsep
\grammarterm{binary-literal} & 2 \\
\grammarterm{octal-literal} & 8 \\
\grammarterm{decimal-literal} & 10 \\
\grammarterm{hexadecimal-literal} & 16 \\
\end{simpletypetable}

\pnum
\grammarterm{hexadecimal-digit}
\tcode{a} 到 \tcode{f} 和 \tcode{A} 到 \tcode{F}
的十进制值分别为 10 到 15。
\begin{example}
数字 12 可以写成 \tcode{12}、\tcode{014}、
\tcode{0XC} 或 \tcode{0b1100}。\grammarterm{integer-literal} \tcode{1048576}、
\tcode{1'048'576}、\tcode{0X100000}、\tcode{0x10'0000} 和
\tcode{0'004'000'000} 都具有相同的值。
\end{example}

\pnum
\indextext{literal!\idxcode{long}}%
\indextext{literal!\idxcode{unsigned}}%
\indextext{literal!integer}%
\indextext{literal!type of integer}%
\indextext{suffix!\idxcode{L}}%
\indextext{suffix!\idxcode{U}}%
\indextext{suffix!\idxcode{l}}%
\indextext{suffix!\idxcode{u}}%
\grammarterm{integer-literal} 的类型是
\tref{lex.icon.type} 中与其可选的 \grammarterm{integer-suffix}
相对应的列表中
可以表示其值的第一个类型。

\begin{floattable}{\grammarterm{integer-literal} 的类型}{lex.icon.type}{l|l|l}
\topline
\lhdr{\grammarterm{integer-suffix}} & \chdr{\grammarterm{decimal-literal}}  & \rhdr{非 \grammarterm{decimal-literal} 的 \grammarterm{integer-literal}}   \\  \capsep
none    &
  \tcode{int} &
  \tcode{int}\\
        &
  \tcode{long int} &
  \tcode{unsigned int}\\
        &
  \tcode{long long int} &
  \tcode{long int}\\
        &
        &
  \tcode{unsigned long int}\\
        &
        &
  \tcode{long long int}\\
        &
        &
  \tcode{unsigned long long int}\\\hline
\tcode{u} or \tcode{U}  &
  \tcode{unsigned int}  &
  \tcode{unsigned int}\\
                              &
  \tcode{unsigned long int}   &
  \tcode{unsigned long int}\\
                              &
  \tcode{unsigned long long int}   &
  \tcode{unsigned long long int}\\\hline
\tcode{l} or \tcode{L}  &
  \tcode{long int}  &
  \tcode{long int}\\
                              &
  \tcode{long long int}       &
  \tcode{unsigned long int}\\
                              &
                              &
  \tcode{long long int}\\
                              &
                              &
  \tcode{unsigned long long int}\\\hline
Both \tcode{u} or \tcode{U}   &
  \tcode{unsigned long int}  &
  \tcode{unsigned long int}\\
and \tcode{l} or \tcode{L}  &
  \tcode{unsigned long long int}  &
  \tcode{unsigned long long int}\\\hline
\tcode{ll} or \tcode{LL}  &
  \tcode{long long int}       &
  \tcode{long long int}\\
                              &
                              &
  \tcode{unsigned long long int}\\\hline
Both \tcode{u} or \tcode{U}   &
  \tcode{unsigned long long int}  &
  \tcode{unsigned long long int}\\
and \tcode{ll} or \tcode{LL}  &
                              &
                              \\\hline
\tcode{z} or \tcode{Z}                  &
  对应于 \tcode{std::size_t}\iref{support.types.layout} 的有符号整型 &
  对应于 \tcode{std::size_t} 的有符号整型 \\
                                        &
  &
  \tcode{std::size_t}\\\hline
Both \tcode{u} or \tcode{U}   &
  \tcode{std::size_t}         &
  \tcode{std::size_t}         \\
and \tcode{z} or \tcode{Z}  &
                              &
                              \\
\end{floattable}

\pnum
除了包含
\grammarterm{size-suffix} 的 \grammarterm{integer-literal} 外，
如果 \grammarterm{integer-literal} 的值
无法用其列表中的任何类型表示，并且
扩展整数类型\iref{basic.fundamental} 可以表示其值，
则它可以具有该扩展整数类型。
如果 \grammarterm{integer-literal} 的列表中的所有类型
都是有符号的，
则扩展整数类型是有符号的。
如果 \grammarterm{integer-literal} 的列表中的所有类型
都是无符号的，
则扩展整数类型是无符号的。
如果列表同时包含有符号和无符号类型，
则扩展整数类型可以是有符号或无符号的。
如果 \grammarterm{integer-literal}
不能用任何允许的类型表示，
则程序是病构的。
\begin{note}
带有 \tcode{z} 或 \tcode{Z} 后缀的 \grammarterm{integer-literal}
如果不能用 \tcode{std::size_t} 表示，则它是病构的。
\end{note}

\rSec2[lex.ccon]{字符字面量}

\indextext{literal!character}%
\begin{bnf}
\nontermdef{character-literal}\br
    \opt{encoding-prefix} \terminal{'} c-char-sequence \terminal{'}
\end{bnf}

\begin{bnf}
\nontermdef{encoding-prefix} \textnormal{one of}\br
    \terminal{u8}\quad\terminal{u}\quad\terminal{U}\quad\terminal{L}
\end{bnf}

\begin{bnf}
\nontermdef{c-char-sequence}\br
    c-char \opt{c-char-sequence}
\end{bnf}

\begin{bnf}
\nontermdef{c-char}\br
    basic-c-char\br
    escape-sequence\br
    universal-character-name
\end{bnf}

\begin{bnf}
\nontermdef{basic-c-char}\br
    \textnormal{除 \unicode{0027}{撇号}、}\br
    \bnfindent\textnormal{\unicode{005c}{反斜杠} 或换行符之外的翻译字符集的任何成员}
\end{bnf}

\begin{bnf}
\nontermdef{escape-sequence}\br
    simple-escape-sequence\br
    numeric-escape-sequence\br
    conditional-escape-sequence
\end{bnf}

\begin{bnf}
\nontermdef{simple-escape-sequence}\br
    \terminal{\textbackslash} simple-escape-sequence-char
\end{bnf}

\begin{bnf}
\nontermdef{simple-escape-sequence-char} \textnormal{one of}\br
    \terminal{'  "  ?  \textbackslash{} a  b  f  n  r  t  v}
\end{bnf}

\begin{bnf}
\nontermdef{numeric-escape-sequence}\br
    octal-escape-sequence\br
    hexadecimal-escape-sequence
\end{bnf}

\begin{bnf}
\nontermdef{simple-octal-digit-sequence}\br
    octal-digit \opt{simple-octal-digit-sequence}
\end{bnf}

\begin{bnf}
\nontermdef{octal-escape-sequence}\br
    \terminal{\textbackslash} octal-digit\br
    \terminal{\textbackslash} octal-digit octal-digit\br
    \terminal{\textbackslash} octal-digit octal-digit octal-digit\br
    \terminal{\textbackslash o\{} simple-octal-digit-sequence \terminal{\}}
\end{bnf}

\begin{bnf}
\nontermdef{hexadecimal-escape-sequence}\br
    \terminal{\textbackslash x} simple-hexadecimal-digit-sequence\br
    \terminal{\textbackslash x\{} simple-hexadecimal-digit-sequence \terminal{\}}
\end{bnf}

\begin{bnf}
\nontermdef{conditional-escape-sequence}\br
    \terminal{\textbackslash} conditional-escape-sequence-char
\end{bnf}

\begin{bnf}
\nontermdef{conditional-escape-sequence-char}\br
    \textnormal{不是} octal-digit\textnormal{、} simple-escape-sequence-char\textnormal{ 或字符 \terminal{N}、\terminal{o}、\terminal{u}、\terminal{U} 或 \terminal{x} 的基本字符集的任何成员}
\end{bnf}

\pnum
\indextext{literal!character}%
\indextext{literal!\idxcode{char8_t}}%
\indextext{literal!\idxcode{char16_t}}%
\indextext{literal!\idxcode{char32_t}}%
\indextext{literal!type of character}%
\indextext{type!\idxcode{char8_t}}%
\indextext{type!\idxcode{char16_t}}%
\indextext{type!\idxcode{char32_t}}%
\indextext{wide-character}%
\indextext{type!\idxcode{wchar_t}}%
\defnadj{多字符}{字面量} 是一个 \grammarterm{character-literal}，
其 \grammarterm{c-char-sequence} 由
多个 \grammarterm{c-char} 组成。
多字符字面量不应具有 \grammarterm{encoding-prefix}。
如果多字符字面量包含一个
无法在普通字面量编码中编码为单个码位单元的 \grammarterm{c-char}，
则程序是病构的。
多字符字面量是条件支持的。

\pnum
\grammarterm{character-literal} 的种类、
其类型及其关联的字符编码\iref{lex.charset}
由
其 \grammarterm{encoding-prefix} 和 \grammarterm{c-char-sequence} 确定，
如 \tref{lex.ccon.literal} 所定义。

\begin{floattable}{字符字面量}{lex.ccon.literal}
{l|l|l|l|l}
\topline
\lhdr{编码} & \chdr{种类} & \chdr{类型} & \chdr{关联的字符} & \rhdr{示例} \\
\lhdr{前缀} & \chdr{} & \chdr{} & \chdr{编码} & \\
\capsep
none &
\defnx{普通字符字面量}{literal!character!ordinary} &
\keyword{char} &
普通字面量 &
\tcode{'v'} \\ \cline{2-3}\cline{5-5}
 &
多字符字面量 &
\keyword{int} &
编码 &
\tcode{'abcd'} \\ \hline
\tcode{L} &
\defnx{宽字符字面量}{literal!character!wide} &
\keyword{wchar_t} &
宽字面量 &
\tcode{L'w'} \\
 & & & 编码 & \\ \hline
\tcode{u8} &
\defnx{UTF-8 字符字面量}{literal!character!UTF-8} &
\keyword{char8_t} &
UTF-8 &
\tcode{u8'x'} \\ \hline
\tcode{u} &
\defnx{UTF-16 字符字面量}{literal!character!UTF-16} &
\keyword{char16_t} &
UTF-16 &
\tcode{u'y'} \\ \hline
\tcode{U} &
\defnx{UTF-32 字符字面量}{literal!character!UTF-32} &
\keyword{char32_t} &
UTF-32 &
\tcode{U'z'} \\
\end{floattable}

\pnum
在翻译阶段 4 中，
使用翻译阶段 7 中 \grammarterm{character-literal} 类型的可表示值范围来确定
\grammarterm{character-literal} 的值。
多字符字面量具有
\impldef{不可编码字符字面量或多字符字面量的值}
值。
任何其他类型的 \grammarterm{character-literal}
的值确定如下：
\begin{itemize}
\item
具有由单个
\grammarterm{basic-c-char}、
\grammarterm{simple-escape-sequence} 或
\grammarterm{universal-character-name} 组成的 \grammarterm{c-char-sequence} 的 \grammarterm{character-literal}
是指定字符
在字面量的关联字符编码中编码的码位单元值。
如果指定字符
在字面量的关联字符编码中缺少表示，或者
如果它不能被编码为单个码位单元，
则程序是病构的。
\item
具有由
单个 \grammarterm{numeric-escape-sequence} 组成的 \grammarterm{c-char-sequence}
的 \grammarterm{character-literal} 具有如下值：
\begin{itemize}
\item
设 $v$ 为由
\grammarterm{octal-escape-sequence} 中
\grammarterm{octal-digit} 序列组成的八进制数或由
\grammarterm{hexadecimal-escape-sequence} 中
\grammarterm{hexadecimal-digit} 序列组成的十六进制数表示的整数值。
\item
如果 $v$ 不超过
\grammarterm{character-literal} 类型的可表示值范围，
则值为 $v$。
\item
否则，
如果 \grammarterm{character-literal} 的 \grammarterm{encoding-prefix}
不存在或为 \tcode{L}，并且
$v$ 不超过 \grammarterm{character-literal} 类型的底层类型对应的无符号类型的可表示值范围，
则该值为 \grammarterm{character-literal} 的类型 \tcode{T} 中与 $v$ 模 $2^N$ 同余的唯一值，其中 $N$ 是 \tcode{T} 的宽度。
\item
否则，程序是病构的。
\end{itemize}
\item
具有由
单个 \grammarterm{conditional-escape-sequence} 组成的 \grammarterm{c-char-sequence}
的 \grammarterm{character-literal}
是条件支持的，并且
具有 \impldef{\grammarterm{conditional-escape-sequence} 的值} 值。
\end{itemize}

\pnum
\indextext{backslash character}%
\indextext{\idxcode{\textbackslash}|see{backslash character}}%
\indextext{escape character|see{backslash character}}%
\grammarterm{simple-escape-sequence} 指定的字符
在 \tref{lex.ccon.esc} 中指定。
\begin{note}
为了与 \CppXIV{} 和 C 兼容，支持使用问号的转义序列。
\end{note}

\begin{floattable}{简单转义序列}{lex.ccon.esc}
{lll}
\topline
\lhdrx{2}{字符} &  \rhdr{\grammarterm{simple-escape-sequence}} \\ \capsep
\ucode{000a} & \uname{line feed}            & \tcode{\textbackslash n} \\
\ucode{0009} & \uname{character tabulation} & \tcode{\textbackslash t} \\
\ucode{000b} & \uname{line tabulation}      & \tcode{\textbackslash v} \\
\ucode{0008} & \uname{backspace}            & \tcode{\textbackslash b} \\
\ucode{000d} & \uname{carriage return}      & \tcode{\textbackslash r} \\
\ucode{000c} & \uname{form feed}            & \tcode{\textbackslash f} \\
\ucode{0007} & \uname{alert}                & \tcode{\textbackslash a} \\
\ucode{005c} & \uname{reverse solidus}      & \tcode{\textbackslash\textbackslash} \\
\ucode{003f} & \uname{question mark}        & \tcode{\textbackslash ?} \\
\ucode{0027} & \uname{apostrophe}           & \tcode{\textbackslash '} \\
\ucode{0022} & \uname{quotation mark}       & \tcode{\textbackslash "} \\
\end{floattable}
\rSec2[lex.fcon]{浮点数字面量}

\indextext{literal!floating-point}%
\begin{bnf}
\nontermdef{floating-point-literal}\br
    decimal-floating-point-literal\br
    hexadecimal-floating-point-literal
\end{bnf}

\begin{bnf}
\nontermdef{decimal-floating-point-literal}\br
    fractional-constant \opt{exponent-part} \opt{floating-point-suffix}\br
    digit-sequence exponent-part \opt{floating-point-suffix}
\end{bnf}

\begin{bnf}
\nontermdef{hexadecimal-floating-point-literal}\br
    hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part \opt{floating-point-suffix}\br
    hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part \opt{floating-point-suffix}
\end{bnf}

\begin{bnf}
\nontermdef{fractional-constant}\br
    \opt{digit-sequence} \terminal{.} digit-sequence\br
    digit-sequence \terminal{.}
\end{bnf}

\begin{bnf}
\nontermdef{hexadecimal-fractional-constant}\br
    \opt{hexadecimal-digit-sequence} \terminal{.} hexadecimal-digit-sequence\br
    hexadecimal-digit-sequence \terminal{.}
\end{bnf}

\begin{bnf}
\nontermdef{exponent-part}\br
    \terminal{e} \opt{sign} digit-sequence\br
    \terminal{E} \opt{sign} digit-sequence
\end{bnf}

\begin{bnf}
\nontermdef{binary-exponent-part}\br
    \terminal{p} \opt{sign} digit-sequence\br
    \terminal{P} \opt{sign} digit-sequence
\end{bnf}

\begin{bnf}
\nontermdef{sign} \textnormal{one of}\br
    \terminal{+  -}
\end{bnf}

\begin{bnf}
\nontermdef{digit-sequence}\br
    digit\br
    digit-sequence \opt{\terminal{'}} digit
\end{bnf}

\begin{bnf}
\nontermdef{floating-point-suffix} \textnormal{one of}\br
    \terminal{f  l  f16  f32  f64  f128  bf16  F  L  F16  F32  F64  F128  BF16}
\end{bnf}

\pnum
\indextext{literal!type of floating-point}%
\indextext{literal!\idxcode{float}}%
\indextext{suffix!\idxcode{F}}%
\indextext{suffix!\idxcode{f}}%
\indextext{suffix!\idxcode{L}}%
\indextext{suffix!\idxcode{l}}%
\indextext{literal!\idxcode{long double}}%
\grammarterm{floating-point-literal}\iref{basic.fundamental,basic.extended.fp}
的类型由
其 \grammarterm{floating-point-suffix} 确定，如 \tref{lex.fcon.type} 中所述。
\begin{note}
浮点后缀
\tcode{f16}、\tcode{f32}、\tcode{f64}、\tcode{f128}、\tcode{bf16}、
\tcode{F16}、\tcode{F32}、\tcode{F64}、\tcode{F128} 和 \tcode{BF16}
是条件支持的。参见 \ref{basic.extended.fp}。
\end{note}
\begin{simpletypetable}
{\grammarterm{floating-point-literal} 的类型}
{lex.fcon.type}
{ll}
\topline
\lhdr{\grammarterm{floating-point-suffix}} & \rhdr{类型} \\ \capsep
none & \keyword{double} \\
\tcode{f} or \tcode{F} & \keyword {float} \\
\tcode{l} or \tcode{L} & \keyword{long} \keyword{double} \\
\tcode{f16} or \tcode{F16} & \tcode{std::float16_t} \\
\tcode{f32} or \tcode{F32} & \tcode{std::float32_t} \\
\tcode{f64} or \tcode{F64} & \tcode{std::float64_t} \\
\tcode{f128} or \tcode{F128} & \tcode{std::float128_t} \\
\tcode{bf16} or \tcode{BF16} & \tcode{std::bfloat16_t} \\
\end{simpletypetable}

\pnum
\indextext{literal!floating-point}%
\grammarterm{floating-point-literal} 的 \defn{有效数}
是 \grammarterm{decimal-floating-point-literal} 的 \grammarterm{fractional-constant} 或 \grammarterm{digit-sequence}
或 \grammarterm{hexadecimal-floating-point-literal} 的 \grammarterm{hexadecimal-fractional-constant}
或 \grammarterm{hexadecimal-digit-sequence}。
在有效数中，
\grammarterm{digit} 或 \grammarterm{hexadecimal-digit} 的序列
和可选的小数点被解释为以 $N$ 为基数的实数 $s$，
其中 \grammarterm{decimal-floating-point-literal} 的 $N$ 为 10，
\grammarterm{hexadecimal-floating-point-literal} 的 $N$ 为 16。
\begin{note}
在确定值时，任何可选的单引号分隔符都将被忽略。
\end{note}
如果存在 \grammarterm{exponent-part} 或 \grammarterm{binary-exponent-part}，
则 \grammarterm{floating-point-literal} 的指数 $e$ 是将
可选 \grammarterm{sign} 和 \grammarterm{digit} 序列解释为以 10 为基数的整数的结果。
否则，指数 $e$ 为 0。
对于 \grammarterm{decimal-floating-point-literal}，字面量的缩放值为
$s \times 10^e$，对于 \grammarterm{hexadecimal-floating-point-literal}，则为
$s \times 2^e$。
\begin{example}
\grammarterm{floating-point-literal}
\tcode{49.625} 和 \tcode{0xC.68p+2} 具有相同的值。
\grammarterm{floating-point-literal}
\tcode{1.602'176'565e-19} 和 \tcode{1.602176565e-19}
具有相同的值。
\end{example}

\pnum
如果缩放值不在其类型的可表示值范围内，
则程序是病构的。
否则，\grammarterm{floating-point-literal} 的值
是可表示的缩放值，
否则是与缩放值最接近的较大或较小的可表示值，
以 \impldef{选择 \grammarterm{floating-point-literal} 的较大或较小值的方式} 选择。

\rSec2[lex.string]{字符串字面量}

\indextext{literal!string}%
\begin{bnf}
\nontermdef{string-literal}\br
    \opt{encoding-prefix} \terminal{"} \opt{s-char-sequence} \terminal{"}\br
    \opt{encoding-prefix} \terminal{R} raw-string
\end{bnf}

\begin{bnf}
\nontermdef{s-char-sequence}\br
    s-char \opt{s-char-sequence}
\end{bnf}

\begin{bnf}
\nontermdef{s-char}\br
    basic-s-char\br
    escape-sequence\br
    universal-character-name
\end{bnf}

\begin{bnf}
\nontermdef{basic-s-char}\br
    \textnormal{除 \unicode{0022}{引号}、}\br
    \bnfindent\textnormal{\unicode{005c}{反斜杠} 或换行符之外的翻译字符集的任何成员}
\end{bnf}

\begin{bnf}
\nontermdef{raw-string}\br
    \terminal{"} \opt{d-char-sequence} \terminal{(} \opt{r-char-sequence} \terminal{)} \opt{d-char-sequence} \terminal{"}
\end{bnf}

\begin{bnf}
\nontermdef{r-char-sequence}\br
    r-char \opt{r-char-sequence}
\end{bnf}

\begin{bnf}
\nontermdef{r-char}\br
    \textnormal{翻译字符集的任何成员，但 \unicode{0029}{右括号} 后跟}\br
    \bnfindent\textnormal{初始 \grammarterm{d-char-sequence}（可以为空）后跟 \unicode{0022}{引号} 除外}
\end{bnf}

\begin{bnf}
\nontermdef{d-char-sequence}\br
    d-char \opt{d-char-sequence}
\end{bnf}

\begin{bnf}
\nontermdef{d-char}\br
    \textnormal{除以下字符外的基本字符集的任何成员：}\br
    \bnfindent\textnormal{\unicode{0020}{空格}、\unicode{0028}{左括号}、\unicode{0029}{右括号}、\unicode{005c}{反斜杠}、}\br
    \bnfindent\textnormal{\unicode{0009}{水平制表}、\unicode{000b}{垂直制表}、\unicode{000c}{换页符} 和换行符}
\end{bnf}

\pnum
\indextext{literal!string}%
\indextext{character string}%
\indextext{string!type of}%
\indextext{type!\idxcode{wchar_t}}%
\indextext{prefix!\idxcode{L}}%
\indextext{literal!string!\idxcode{char16_t}}%
\indextext{type!\idxcode{char16_t}}%
\indextext{literal!string!\idxcode{char32_t}}%
\indextext{type!\idxcode{char32_t}}%
\grammarterm{string-literal} 的种类、
其类型和
其关联的字符编码\iref{lex.charset}
由其编码前缀和
\grammarterm{s-char} 或 \grammarterm{r-char} 序列确定，
如 \tref{lex.string.literal} 所定义，
其中 $n$ 是如下所述的编码码位单元的数量。

\begin{floattable}{字符串字面量}{lex.string.literal}
{llp{2.6cm}p{2.3cm}p{4.7cm}}
\topline
\lhdr{编码} & \chdr{种类} & \chdr{类型} & \chdr{关联的} & \rhdr{示例} \\
\lhdr{前缀}   & \chdr{} & \chdr{} & \chdr{字符}  & \rhdr{} \\
\lhdr{}         & \chdr{} & \chdr{} & \chdr{编码}   & \rhdr{} \\
\capsep
none &
\defnx{普通字符串字面量}{literal!string!ordinary} &
$n$ 个\newline \tcode{\keyword{const} \keyword{char}} 的数组 &
普通字面量编码 &
\tcode{"ordinary string"}\newline
\tcode{R"(ordinary raw string)"} \\
\tcode{L} &
\defnx{宽字符串字面量}{literal!string!wide} &
$n$ 个\newline \tcode{\keyword{const} \keyword{wchar_t}} 的数组 &
宽字面量\newline 编码 &
\tcode{L"wide string"}\newline
\tcode{LR"w(wide raw string)w"} \\
\tcode{u8} &
\defnx{UTF-8 字符串字面量}{literal!string!UTF-8} &
$n$ 个\newline \tcode{\keyword{const} \keyword{char8_t}} 的数组 &
UTF-8 &
\tcode{u8"UTF-8 string"}\newline
\tcode{u8R"x(UTF-8 raw string)x"} \\
\tcode{u} &
\defnx{UTF-16 字符串字面量}{literal!string!UTF-16} &
$n$ 个\newline \tcode{\keyword{const} \keyword{char16_t}} 的数组 &
UTF-16 &
\tcode{u"UTF-16 string"}\newline
\tcode{uR"y(UTF-16 raw string)y"} \\
\tcode{U} &
\defnx{UTF-32 字符串字面量}{literal!string!UTF-32} &
$n$ 个\newline \tcode{\keyword{const} \keyword{char32_t}} 的数组 &
UTF-32 &
\tcode{U"UTF-32 string"}\newline
\tcode{UR"z(UTF-32 raw string)z"} \\
\end{floattable}

\pnum
\indextext{literal!string!raw}%
前缀中包含 \tcode{R} 的 \grammarterm{string-literal}
\indextext{prefix!\idxcode{R}}%
是 \defn{原始字符串字面量}。
\grammarterm{d-char-sequence} 用作分隔符。
\grammarterm{raw-string} 的终止 \grammarterm{d-char-sequence} 与
初始 \grammarterm{d-char-sequence} 是相同的字符序列。\grammarterm{d-char-sequence}
最多应包含 16 个字符。

\pnum
\begin{note}
字符 \tcode{'('} 和 \tcode{')'} 可以出现在
\grammarterm{raw-string} 中。因此，\tcode{R"delimiter((a|b))delimiter"} 等价于
\tcode{"(a|b)"}。
\end{note}

\pnum
\begin{note}
原始字符串字面量中源文件换行符会导致
生成的执行字符串字面量中出现换行符。假设以下示例中行的开头没有
空格，则断言将成功：
\begin{codeblock}
const char* p = R"(a\
b
c)";
assert(std::strcmp(p, "a\\\nb\nc") == 0);
\end{codeblock}
\end{note}

\pnum
\begin{example}
原始字符串
\begin{codeblock}
R"a(
)\
a"
)a"
\end{codeblock}
等价于 \tcode{"\textbackslash n)\textbackslash \textbackslash \textbackslash na\textbackslash"\textbackslash n"}。原始字符串
\begin{codeblock}
R"(x = "\"y\"")"
\end{codeblock}
等价于 \tcode{"x = \textbackslash "\textbackslash\textbackslash\textbackslash "y\textbackslash\textbackslash\textbackslash "\textbackslash ""}.
\end{example}

\pnum
\indextext{literal!narrow-character}%
普通字符串字面量和 UTF-8 字符串字面量
也被称为 \defnx{窄字符串字面量}{literal!string!narrow}。

\pnum
\indextext{concatenation!string}%
任何相邻 \grammarterm{string-literal} 序列中的 \grammarterm{string-literal}
最多应具有一个唯一的 \grammarterm{encoding-prefix}。
序列的公共 \grammarterm{encoding-prefix} 是
该 \grammarterm{encoding-prefix}（如果有）。
\begin{note}
\grammarterm{string-literal} 的原始性
对确定公共 \grammarterm{encoding-prefix} 没有影响。
\end{note}

\pnum
在翻译阶段 6\iref{lex.phases} 中，
相邻的 \grammarterm{string-literal} 被连接起来。
保留各个 \grammarterm{string-literal} 内容的词法结构和分组。
\begin{example}
\begin{codeblock}
"\xA" "B"
\end{codeblock}
表示
连接后的码位单元 \tcode{'\textbackslash xA'} 和字符 \tcode{'B'}
（而不是单个码位单元 \tcode{'\textbackslash xAB'}）。
类似地，
\begin{codeblock}
R"(\u00)" "41"
\end{codeblock}
表示六个字符，
以反斜杠开头，以数字 \tcode{1} 结尾
（而不是由 \grammarterm{universal-character-name} 指定的单个字符 \tcode{'A'}）。

\tref{lex.string.concat} 有一些有效连接的示例。
\end{example}

\begin{floattable}{字符串字面量连接}{lex.string.concat}
{lll|lll|lll}
\topline
\multicolumn{2}{|c}{源} &
含义 &
\multicolumn{2}{c}{源} &
含义 &
\multicolumn{2}{c}{源} &
含义 \\
\tcode{u"a"} & \tcode{u"b"} & \tcode{u"ab"} &
\tcode{U"a"} & \tcode{U"b"} & \tcode{U"ab"} &
\tcode{L"a"} & \tcode{L"b"} & \tcode{L"ab"} \\
\tcode{u"a"} & \tcode{"b"}  & \tcode{u"ab"} &
\tcode{U"a"} & \tcode{"b"}  & \tcode{U"ab"} &
\tcode{L"a"} & \tcode{"b"}  & \tcode{L"ab"} \\
\tcode{"a"}  & \tcode{u"b"} & \tcode{u"ab"} &
\tcode{"a"}  & \tcode{U"b"} & \tcode{U"ab"} &
\tcode{"a"}  & \tcode{L"b"} & \tcode{L"ab"} \\
\end{floattable}

\pnum
求值 \grammarterm{string-literal} 会产生一个具有静态存储期\iref{basic.stc} 的字符串字面量对象。
\begin{note}
字符串字面量对象可能是非唯一的\iref{intro.object}。
\grammarterm{string-literal} 的连续求值是产生相同对象还是不同对象是
未指明的。
\end{note}
\begin{note}
\indextext{literal!string!undefined change to}%
尝试修改字符串字面量对象的效果是未定义的。
\end{note}

\pnum
\indextext{\idxcode{0}!string terminator}%
\indextext{\idxcode{0}!null character|see {character, null}}%
字符串字面量对象使用
与 \grammarterm{string-literal} 的 \grammarterm{s-char} 序列（最初来自非原始字符串字面量）和
\grammarterm{r-char} 序列（最初来自原始字符串字面量）相对应的码位单元值序列，
加上一个终止的 \unicode{0000}{null} 字符，
按以下顺序初始化：
\begin{itemize}
\item
由每个连续的
\grammarterm{basic-s-char}、
\grammarterm{r-char}、
\grammarterm{simple-escape-sequence}\iref{lex.ccon} 和
\grammarterm{universal-character-name}\iref{lex.charset} 序列表示的字符序列
使用 \grammarterm{string-literal} 的关联字符编码编码为码位单元序列。
如果字符在关联的字符编码中缺少表示，
则程序是病构的。
\begin{note}
任何字符在任何 Unicode 编码形式中都没有缺少表示。
\end{note}
当编码有状态字符编码时，
实现应以初始编码状态开始对第一个这样的序列进行编码，并以
前一个序列的最终编码状态开始对后续序列进行编码。
\begin{note}
编码的码位单元序列可能与
通过独立编码每个字符获得的码位单元序列不同。
\end{note}
\item
每个 \grammarterm{numeric-escape-sequence}\iref{lex.ccon}
贡献一个具有以下值的单个码位单元：
\begin{itemize}
\item
设 $v$ 为由
\grammarterm{octal-escape-sequence} 中
\grammarterm{octal-digit} 序列组成的八进制数或由
\grammarterm{hexadecimal-escape-sequence} 中
\grammarterm{hexadecimal-digit} 序列组成的十六进制数表示的整数值。
\item
如果 $v$ 不超过
\grammarterm{string-literal} 的数组元素类型的可表示值范围，
则值为 $v$。
\item
否则，
如果 \grammarterm{string-literal} 的 \grammarterm{encoding-prefix}
不存在或为 \tcode{L}，并且
$v$ 不超过 \grammarterm{string-literal} 的数组元素类型的底层类型对应的无符号类型的可表示值范围，
则该值为 \grammarterm{string-literal} 的数组元素类型 \tcode{T}
中与 $v$ 模 $2^N$ 同余的唯一值，其中 $N$ 是 \tcode{T} 的宽度。
\item
否则，程序是病构的。
\end{itemize}
当编码有状态字符编码时，
这些序列应对编码状态没有影响。
\item
每个 \grammarterm{conditional-escape-sequence}\iref{lex.ccon}
贡献一个
\impldef{\grammarterm{conditional-escape-sequence} 的码位单元序列}
码位单元序列。
当编码有状态字符编码时，
\impldef{\grammarterm{conditional-escape-sequence} 对编码状态的影响}
这些序列对编码状态有什么影响。
\end{itemize}

\rSec2[lex.string.uneval]{未求值字符串}

\begin{bnf}
\nontermdef{unevaluated-string}\br
    string-literal
\end{bnf}

\pnum
\grammarterm{unevaluated-string} 不应具有 \grammarterm{encoding-prefix}。

\pnum
\grammarterm{unevaluated-string} 中的每个 \grammarterm{universal-character-name} 和每个 \grammarterm{simple-escape-sequence} 都被
它表示的翻译字符集的成员替换。
包含
\grammarterm{numeric-escape-sequence} 或
\grammarterm{conditional-escape-sequence} 的
\grammarterm{unevaluated-string}
是病构的。

\pnum
\grammarterm{unevaluated-string} 从不求值，
其解释取决于它出现的上下文。

\rSec2[lex.bool]{布尔字面量}

\indextext{literal!boolean}%
\begin{bnf}
\nontermdef{boolean-literal}\br
    \terminal{false}\br
    \terminal{true}
\end{bnf}

\pnum
\indextext{Boolean literal}%
布尔字面量是关键字 \tcode{false} 和 \tcode{true}。
此类字面量具有类型 \tcode{bool}。

\rSec2[lex.nullptr]{指针字面量}

\indextext{literal!pointer}%
\begin{bnf}
\nontermdef{pointer-literal}\br
    \terminal{nullptr}
\end{bnf}

\pnum
指针字面量是关键字 \keyword{nullptr}。它具有类型
\tcode{std::nullptr_t}。
\begin{note}
\tcode{std::nullptr_t} 是一种既不是指针类型也不是成员指针类型的不同类型；
相反，此类型的纯右值是一个空指针常量，可以
转换为一个空指针值或空成员指针值。参见 \ref{conv.ptr}
和 \ref{conv.mem}。
\end{note}

\rSec2[lex.ext]{用户定义字面量}

\indextext{literal!user-defined}%
\begin{bnf}
\nontermdef{user-defined-literal}\br
    user-defined-integer-literal\br
    user-defined-floating-point-literal\br
    user-defined-string-literal\br
    user-defined-character-literal
\end{bnf}

\begin{bnf}
\nontermdef{user-defined-integer-literal}\br
    decimal-literal ud-suffix\br
    octal-literal ud-suffix\br
    hexadecimal-literal ud-suffix\br
    binary-literal ud-suffix
\end{bnf}

\begin{bnf}
\nontermdef{user-defined-floating-point-literal}\br
    fractional-constant \opt{exponent-part} ud-suffix\br
    digit-sequence exponent-part ud-suffix\br
    hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part ud-suffix\br
    hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part ud-suffix
\end{bnf}

\begin{bnf}
\nontermdef{user-defined-string-literal}\br
    string-literal ud-suffix
\end{bnf}

\begin{bnf}
\nontermdef{user-defined-character-literal}\br
    character-literal ud-suffix
\end{bnf}

\begin{bnf}
\nontermdef{ud-suffix}\br
    identifier
\end{bnf}

\pnum
如果一个记号同时匹配 \grammarterm{user-defined-literal} 和另一个 \grammarterm{literal} 种类，则
将其视为后者。
\begin{example}
\tcode{123_km}
是一个 \grammarterm{user-defined-literal}，但 \tcode{12LL} 是一个
\grammarterm{integer-literal}。
\end{example}
\grammarterm{user-defined-literal} 中 \grammarterm{ud-suffix} 之前的语法非终结符被认为是
可以匹配该非终结符的最长字符序列。

\pnum
\grammarterm{user-defined-literal} 被视为对字面量运算符或
字面量运算符模板\iref{over.literal} 的调用。
要确定具有 \grammarterm{ud-suffix} \placeholder{X} 的给定 \grammarterm{user-defined-literal} 占位符 {L} 的此调用的形式，
首先让 \placeholder{S} 为通过对字面量后缀标识符为 \placeholder{X} 的 \grammarterm{literal-operator-id}
进行非限定查找\iref{basic.lookup.unqual} 找到的声明集。
\placeholder{S} 不应为空。

\pnum
如果 \placeholder{L} 是 \grammarterm{user-defined-integer-literal}，则令 \placeholder{n} 为
没有 \grammarterm{ud-suffix} 的字面量。如果 \placeholder{S} 包含一个
参数类型为 \tcode{unsigned long long} 的字面量运算符，则字面量 \placeholder{L} 被视为
以下形式的调用
\begin{codeblock}
operator ""@\placeholder{X}@(@\placeholder{n}@ULL)
\end{codeblock}
否则，\placeholder{S} 应包含一个原始字面量运算符
或一个数字字面量运算符模板\iref{over.literal}，但不能同时包含两者。
如果 \placeholder{S} 包含一个原始字面量运算符，
则字面量 \placeholder{L} 被视为以下形式的调用
\begin{codeblock}
operator ""@\placeholder{X}@("@\placeholder{n}@")
\end{codeblock}
否则（\placeholder{S} 包含一个数字字面量运算符模板），
\placeholder{L} 被视为以下形式的调用
\begin{codeblock}
operator ""@\placeholder{X}@<'@$c_1$@', '@$c_2$@', ... '@$c_k$@'>()
\end{codeblock}
其中 \placeholder{n} 是源字符序列 $c_1c_2...c_k$。
\begin{note}
序列
$c_1c_2...c_k$ 只能包含来自基本字符集的字符。
\end{note}

\pnum
如果 \placeholder{L} 是 \grammarterm{user-defined-floating-point-literal}，则令 \placeholder{f} 为
没有 \grammarterm{ud-suffix} 的字面量。如果 \placeholder{S} 包含一个
参数类型为 \tcode{long double} 的字面量运算符，则字面量 \placeholder{L} 被视为
以下形式的调用
\begin{codeblock}
operator ""@\placeholder{X}@(@\placeholder{f}@L)
\end{codeblock}
否则，\placeholder{S} 应包含一个原始字面量运算符
或一个数字字面量运算符模板\iref{over.literal}，但不能同时包含两者。
如果 \placeholder{S} 包含一个原始字面量运算符，
则 \grammarterm{literal} \placeholder{L} 被视为以下形式的调用
\begin{codeblock}
operator ""@\placeholder{X}@("@\placeholder{f}@")
\end{codeblock}
否则（\placeholder{S} 包含一个数字字面量运算符模板），
\placeholder{L} 被视为以下形式的调用
\begin{codeblock}
operator ""@\placeholder{X}@<'@$c_1$@', '@$c_2$@', ... '@$c_k$@'>()
\end{codeblock}
其中 \placeholder{f} 是源字符序列 $c_1c_2...c_k$。
\begin{note}
序列
$c_1c_2...c_k$ 只能包含来自基本字符集的字符。
\end{note}

\pnum
如果 \placeholder{L} 是 \grammarterm{user-defined-string-literal}，
则令 \placeholder{str} 为没有 \grammarterm{ud-suffix} 的字面量，
并令 \placeholder{len} 为 \placeholder{str} 中码位单元的数量
（即，其长度不包括终止的空字符）。
如果 \placeholder{S} 包含一个字面量运算符模板，该模板具有
一个非类型模板参数，且 \placeholder{str} 是其
格式正确的 \grammarterm{template-argument}，
则字面量 \placeholder{L} 被视为以下形式的调用
\begin{codeblock}
operator ""@\placeholder{X}@<@\placeholder{str}{}@>()
\end{codeblock}
否则，字面量 \placeholder{L} 被视为以下形式的调用
\begin{codeblock}
operator ""@\placeholder{X}@(@\placeholder{str}{}@, @\placeholder{len}{}@)
\end{codeblock}

\pnum
如果 \placeholder{L} 是 \grammarterm{user-defined-character-literal}，则令 \placeholder{ch} 为
没有 \grammarterm{ud-suffix} 的字面量。
\placeholder{S} 应包含一个字面量运算符\iref{over.literal}，其唯一参数
具有 \placeholder{ch} 的类型，并且
字面量 \placeholder{L} 被视为
以下形式的调用
\begin{codeblock}
operator ""@\placeholder{X}@(@\placeholder{ch}{}@)
\end{codeblock}

\pnum
\begin{example}
\begin{codeblock}
long double operator ""_w(long double);
std::string operator ""_w(const char16_t*, std::size_t);
unsigned operator ""_w(const char*);
int main() {
  1.2_w;            // calls \tcode{operator ""_w(1.2L)}
  u"one"_w;         // calls \tcode{operator ""_w(u"one", 3)}
  12_w;             // calls \tcode{operator ""_w("12")}
  "two"_w;          // error: no applicable literal operator
}
\end{codeblock}
\end{example}

\pnum
在翻译阶段 6\iref{lex.phases} 中，相邻的 \grammarterm{string-literal} 被连接起来，
并且 \grammarterm{user-defined-string-literal} 被视为 \grammarterm{string-literal}
以用于该目的。在连接期间，\grammarterm{ud-suffix} 被移除并忽略，
并且连接过程如 \ref{lex.string} 中所述。在阶段
6 结束时，如果 \grammarterm{string-literal} 是至少涉及一个
\grammarterm{user-defined-string-literal} 的连接的结果，则所有参与的
\grammarterm{user-defined-string-literal} 都应具有相同的 \grammarterm{ud-suffix}，
并且该后缀将应用于连接的结果。

\pnum
\begin{example}
\begin{codeblock}
int main() {
  L"A" "B" "C"_x;   // OK, same as \tcode{L"ABC"_x}
  "P"_x "Q" "R"_y;  // error: two different \grammarterm{ud-suffix}{es}
}
\end{codeblock}
\end{example}
\indextext{literal|)}%
\indextext{conventions!lexical|)}